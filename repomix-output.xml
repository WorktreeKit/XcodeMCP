This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  environment-validator.vitest.test.ts
  functional.test.js
  functional.vitest.test.js
  integration.test.js
  mcp-handlers.test.js
  parameter-mismatch-prevention.vitest.test.js
  server-runtime.test.js
  simple-unit.test.js
  simple-unit.vitest.test.js
  simple-unit.vitest.test.ts
  xcode-server.test.js
.github/
  workflows/
    publish.yml
    test.yml
src/
  tools/
    BuildTools.ts
    InfoTools.ts
    ProjectTools.ts
    XCResultTools.ts
  types/
    index.ts
  utils/
    BuildLogParser.ts
    EnvironmentValidator.ts
    ErrorHelper.ts
    JXAExecutor.ts
    Logger.ts
    ParameterNormalizer.ts
    PathValidator.ts
    XCResultParser.ts
  index.ts
  XcodeServer.ts
.gitignore
.npmignore
LICENSE
package.json
README.md
slim-ui-tree.js
test-client.js
test-setup.js
test-tool-live.sh
test-tool.sh
tsconfig.json
vitest.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="__tests__/server-runtime.test.js">
import { spawn } from 'child_process';
import { jest } from '@jest/globals';

describe.skip('Server Runtime Tests', () => {
  test('should start server without crashing', (done) => {
    const serverProcess = spawn('node', ['index.js'], {
      cwd: process.cwd(),
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let hasStarted = false;
    
    serverProcess.stderr.on('data', (data) => {
      const output = data.toString();
      if (output.includes('Xcode MCP server running on stdio')) {
        hasStarted = true;
        serverProcess.kill('SIGTERM');
      }
    });

    serverProcess.on('close', (code) => {
      if (hasStarted) {
        expect(code).toBe(null); // Process was killed, not crashed
        done();
      } else {
        done(new Error(`Server failed to start, exit code: ${code}`));
      }
    });

    serverProcess.on('error', (error) => {
      done(error);
    });

    // Timeout after 5 seconds
    setTimeout(() => {
      if (!hasStarted) {
        serverProcess.kill('SIGKILL');
        done(new Error('Server startup timeout'));
      }
    }, 5000);
  }, 10000);

  test('should validate server can handle MCP list tools request', (done) => {
    const serverProcess = spawn('node', ['index.js'], {
      cwd: process.cwd(),
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let serverReady = false;

    serverProcess.stderr.on('data', (data) => {
      const output = data.toString();
      if (output.includes('Xcode MCP server running on stdio')) {
        serverReady = true;
        
        // Send a valid MCP request
        const listToolsRequest = {
          jsonrpc: '2.0',
          id: 1,
          method: 'tools/list',
          params: {}
        };
        
        serverProcess.stdin.write(JSON.stringify(listToolsRequest) + '\n');
      }
    });

    let responseReceived = false;
    serverProcess.stdout.on('data', (data) => {
      const output = data.toString();
      try {
        const response = JSON.parse(output);
        if (response.id === 1 && response.result && response.result.tools) {
          responseReceived = true;
          expect(response.result.tools.length).toBeGreaterThan(0);
          serverProcess.kill('SIGTERM');
          done();
        }
      } catch (e) {
        // Ignore JSON parse errors, might be partial data
      }
    });

    serverProcess.on('close', () => {
      if (!responseReceived && serverReady) {
        done(new Error('No valid response received'));
      }
    });

    serverProcess.on('error', (error) => {
      done(error);
    });

    // Timeout after 10 seconds
    setTimeout(() => {
      serverProcess.kill('SIGKILL');
      if (!responseReceived) {
        done(new Error('Test timeout'));
      }
    }, 10000);
  }, 15000);
});
</file>

<file path=".github/workflows/test.yml">
name: Run Tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  test:
    runs-on: macos-latest
    
    strategy:
      matrix:
        node-version: [18.x, 20.x, 22.x]
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    
    - name: Install dependencies
      run: npm ci
    
    - name: Check for Xcode
      id: check_xcode
      run: |
        # In CI, Xcode is installed but not accessible via JXA without a GUI session
        # Always skip Xcode-dependent tests in CI
        echo "has_xcode=false" >> $GITHUB_OUTPUT
        echo "Xcode is installed but not accessible via JXA in CI environment"
    
    - name: Run tests (with Xcode)
      if: steps.check_xcode.outputs.has_xcode == 'true'
      run: npm test
      env:
        NODE_ENV: test
    
    - name: Run tests (CI - without Xcode integration)
      if: steps.check_xcode.outputs.has_xcode == 'false'
      run: npm test
      env:
        NODE_ENV: test
        SKIP_XCODE_TESTS: true
    
    - name: Run linter (if available)
      run: npm run lint --if-present
      continue-on-error: true
</file>

<file path=".npmignore">
# Test files
__tests__/
jest.config.js
test.js
*_test.js
test_*.js
*_parser.js
debug_*.js
simple_*.js

# Development files
.gitignore
CLAUDE.md

# Git files
.git/
.github/

# macOS files
.DS_Store

# Logs
*.log
</file>

<file path="__tests__/environment-validator.vitest.test.ts">
import { vi, describe, test, expect, beforeEach, afterEach } from 'vitest';
import { spawn } from 'child_process';
import { existsSync } from 'fs';
import { platform } from 'os';
import { EnvironmentValidator } from '../src/utils/EnvironmentValidator.js';
import type { EnvironmentValidation, EnvironmentValidationResult } from '../src/types/index.js';

// Mock the child_process module
vi.mock('child_process', () => ({
  spawn: vi.fn()
}));

// Mock fs module
vi.mock('fs', () => ({
  existsSync: vi.fn()
}));

// Mock os module
vi.mock('os', () => ({
  platform: vi.fn()
}));

describe('EnvironmentValidator - XCLogParser Detection', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    // Default to macOS platform
    vi.mocked(platform).mockReturnValue('darwin');
    // Default to files existing
    vi.mocked(existsSync).mockReturnValue(true);
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('XCLogParser Detection Success Cases', () => {
    test('should detect XCLogParser with version command', async () => {
      // Mock successful which command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('/usr/local/bin/xclogparser', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      // Mock successful version command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === 'version') {
          return createMockProcess('XCLogParser 0.2.9', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(true);
      expect(result.message).toContain('XCLogParser found (XCLogParser 0.2.9)');
      expect(result.metadata?.version).toBe('XCLogParser 0.2.9');
      expect(result.metadata?.path).toBe('/usr/local/bin/xclogparser');
    });

    test('should detect XCLogParser with fallback to help when version fails', async () => {
      // Mock successful which command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('/opt/homebrew/bin/xclogparser', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      // Mock failed version command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === 'version') {
          return createMockProcess('', 'Unknown option: version', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock successful help command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === '--help') {
          return createMockProcess('Usage: xclogparser [options]...', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(true);
      expect(result.message).toContain('XCLogParser found (Unknown version (tool is working))');
      expect(result.metadata?.version).toBe('Unknown version (tool is working)');
      expect(result.metadata?.path).toBe('/opt/homebrew/bin/xclogparser');
    });

    test('should handle XCLogParser with different version output formats', async () => {
      const versionOutputs = [
        'xclogparser version 0.2.9',
        'Version: 0.2.9',
        '0.2.9',
        'XCLogParser-0.2.9'
      ];

      for (const versionOutput of versionOutputs) {
        vi.clearAllMocks();
        
        // Mock successful which command
        vi.mocked(spawn).mockImplementationOnce((command, args) => {
          if (command === 'which' && args[0] === 'xclogparser') {
            return createMockProcess('/usr/local/bin/xclogparser', '', 0);
          }
          return createMockProcess('', '', 1);
        });

        // Mock version command with different output
        vi.mocked(spawn).mockImplementationOnce((command, args) => {
          if (command === 'xclogparser' && args[0] === 'version') {
            return createMockProcess(versionOutput, '', 0);
          }
          return createMockProcess('', '', 1);
        });

        const result = await EnvironmentValidator['validateXCLogParser']();

        expect(result.valid).toBe(true);
        expect(result.message).toContain(`XCLogParser found (${versionOutput.trim()})`);
        expect(result.metadata?.version).toBe(versionOutput.trim());
      }
    });
  });

  describe('XCLogParser Detection Failure Cases', () => {
    test('should handle XCLogParser not found in PATH', async () => {
      // Mock failed which command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('', 'which: xclogparser: not found', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock checking common locations - all fail
      const commonPaths = [
        '/usr/local/bin/xclogparser',
        '/opt/homebrew/bin/xclogparser',
        '/usr/bin/xclogparser',
        '/opt/local/bin/xclogparser'
      ];

      for (const path of commonPaths) {
        vi.mocked(spawn).mockImplementationOnce((command, args) => {
          if (command === 'test' && args[0] === '-f' && args[1] === path) {
            return createMockProcess('', '', 1); // File doesn't exist
          }
          return createMockProcess('', '', 1);
        });
      }

      // Mock homebrew check
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'brew' && args[0] === '--prefix') {
          return createMockProcess('/opt/homebrew', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      expect(result.message).toBe('XCLogParser not found or not executable');
      expect(result.recoveryInstructions).toContain('Install XCLogParser using Homebrew: brew install xclogparser');
      expect(result.recoveryInstructions).toContain('Or download from GitHub: https://github.com/MobileNativeFoundation/XCLogParser');
      expect(result.degradedMode?.available).toBe(true);
      expect(result.degradedMode?.limitations).toContain('Build logs cannot be parsed');
    });

    test('should detect XCLogParser found but not executable', async () => {
      const foundPath = '/usr/local/bin/xclogparser';
      
      // Mock successful which command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess(foundPath, '', 0);
        }
        return createMockProcess('', '', 1);
      });

      // Mock failed version command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === 'version') {
          return createMockProcess('', 'Permission denied', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock failed help command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === '--help') {
          return createMockProcess('', 'Permission denied', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock successful which command again for error handling
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess(foundPath, '', 0);
        }
        return createMockProcess('', '', 1);
      });

      // Mock executable check that fails
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'test' && args[0] === '-x' && args[1] === foundPath) {
          return createMockProcess('', '', 1); // Not executable
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      // Just check that we got error recovery instructions since the exact implementation might vary
      expect(result.recoveryInstructions).toContain('Install XCLogParser using Homebrew: brew install xclogparser');
    });

    test('should detect XCLogParser in common location but not in PATH', async () => {
      const foundPath = '/opt/homebrew/bin/xclogparser';
      
      // Mock failed which command initially
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('', 'which: xclogparser: not found', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock first common path check that fails
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'test' && args[0] === '-f' && args[1] === '/usr/local/bin/xclogparser') {
          return createMockProcess('', '', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock second common path check that succeeds
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'test' && args[0] === '-f' && args[1] === foundPath) {
          return createMockProcess('', '', 0); // File exists
        }
        return createMockProcess('', '', 1);
      });

      // Mock executable check that succeeds
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'test' && args[0] === '-x' && args[1] === foundPath) {
          return createMockProcess('', '', 0); // Is executable
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      // Just check that we got basic recovery instructions since exact content varies
      expect(result.recoveryInstructions).toContain('Install XCLogParser using Homebrew: brew install xclogparser');
    });

    test('should handle command timeout scenarios', async () => {
      // Mock which command that fails to simulate timeout scenario 
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          // Return a failing process to simulate command not working
          return createMockProcess('', 'Command timed out', 1);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      expect(result.message).toBe('XCLogParser not found or not executable');
    });

    test('should handle homebrew detection for recovery instructions', async () => {
      // Mock failed which command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('', 'which: xclogparser: not found', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock all common path checks failing
      const commonPaths = [
        '/usr/local/bin/xclogparser',
        '/opt/homebrew/bin/xclogparser',
        '/usr/bin/xclogparser',
        '/opt/local/bin/xclogparser'
      ];

      for (const path of commonPaths) {
        vi.mocked(spawn).mockImplementationOnce((command, args) => {
          if (command === 'test' && args[0] === '-f' && args[1] === path) {
            return createMockProcess('', '', 1);
          }
          return createMockProcess('', '', 1);
        });
      }

      // Mock successful homebrew detection
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'brew' && args[0] === '--prefix') {
          return createMockProcess('/opt/homebrew', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      // Just check that we got recovery instructions since exact content varies
      expect(result.recoveryInstructions).toContain('Install XCLogParser using Homebrew: brew install xclogparser');
    });

    test('should handle homebrew not available', async () => {
      // Mock failed which command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('', 'which: xclogparser: not found', 1);
        }
        return createMockProcess('', '', 1);
      });

      // Mock all common path checks failing
      const commonPaths = [
        '/usr/local/bin/xclogparser',
        '/opt/homebrew/bin/xclogparser',
        '/usr/bin/xclogparser',
        '/opt/local/bin/xclogparser'
      ];

      for (const path of commonPaths) {
        vi.mocked(spawn).mockImplementationOnce((command, args) => {
          if (command === 'test' && args[0] === '-f' && args[1] === path) {
            return createMockProcess('', '', 1);
          }
          return createMockProcess('', '', 1);
        });
      }

      // Mock failed homebrew detection
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'brew' && args[0] === '--prefix') {
          return createMockProcess('', 'brew: command not found', 1);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      expect(result.recoveryInstructions).toContain('Install XCLogParser using Homebrew: brew install xclogparser');
      // Should not contain homebrew-specific debugging info
      expect(result.recoveryInstructions).not.toContain('Homebrew detected at:');
    });
  });

  describe('Environment Validation Integration', () => {
    test('should include XCLogParser validation in full environment check', async () => {
      // Mock platform
      vi.mocked(platform).mockReturnValue('darwin');
      
      // Mock Xcode existence
      vi.mocked(existsSync).mockReturnValue(true);

      // Mock all command executions for other validators
      vi.mocked(spawn).mockImplementation((command, args) => {
        // XCLogParser validation
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('/usr/local/bin/xclogparser', '', 0);
        }
        if (command === 'xclogparser' && args[0] === 'version') {
          return createMockProcess('XCLogParser 0.2.9', '', 0);
        }
        
        // OSAScript validation
        if (command === 'osascript') {
          return createMockProcess('test', '', 0);
        }
        
        // Xcode version validation
        if (command === 'defaults' || command === 'plutil') {
          return createMockProcess('15.0', '', 0);
        }
        
        return createMockProcess('', '', 0);
      });

      const result = await EnvironmentValidator.validateEnvironment();

      expect(result.xclogparser?.valid).toBe(true);
      expect(result.xclogparser?.message).toContain('XCLogParser found');
      expect(result.overall.nonCriticalFailures).not.toContain('xclogparser');
    });

    test('should handle XCLogParser failure in degraded mode', async () => {
      // Mock platform
      vi.mocked(platform).mockReturnValue('darwin');
      
      // Mock Xcode existence
      vi.mocked(existsSync).mockReturnValue(true);

      // Mock command executions
      vi.mocked(spawn).mockImplementation((command, args) => {
        // XCLogParser validation - fail
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('', 'not found', 1);
        }
        if (command === 'test' && args.includes('xclogparser')) {
          return createMockProcess('', '', 1);
        }
        if (command === 'brew') {
          return createMockProcess('', 'not found', 1);
        }
        
        // OSAScript validation - pass
        if (command === 'osascript') {
          return createMockProcess('test', '', 0);
        }
        
        // Xcode version validation - pass
        if (command === 'defaults' || command === 'plutil') {
          return createMockProcess('15.0', '', 0);
        }
        
        return createMockProcess('', '', 0);
      });

      const result = await EnvironmentValidator.validateEnvironment();

      expect(result.xclogparser?.valid).toBe(false);
      expect(result.xclogparser?.degradedMode?.available).toBe(true);
      expect(result.overall.canOperateInDegradedMode).toBe(true);
      expect(result.overall.nonCriticalFailures).toContain('xclogparser');
    });

    test('should get unavailable features when XCLogParser fails', async () => {
      const mockResults: EnvironmentValidation = {
        overall: { valid: false, canOperateInDegradedMode: true, criticalFailures: [], nonCriticalFailures: ['xclogparser'] },
        xclogparser: { valid: false, message: 'Not found' },
        xcode: { valid: true, message: 'Working' },
        permissions: { valid: true, message: 'Working' }
      };

      const unavailableFeatures = EnvironmentValidator.getUnavailableFeatures(mockResults);
      
      expect(unavailableFeatures).toContain('Build log parsing and detailed error reporting');
    });
  });

  describe('Edge Cases and Error Handling', () => {
    test('should handle malformed command output gracefully', async () => {
      // Mock which command returning unusual output
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('  /usr/local/bin/xclogparser  \n\n', '', 0); // With whitespace
        }
        return createMockProcess('', '', 1);
      });

      // Mock version command returning unusual output
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === 'version') {
          return createMockProcess('\n  XCLogParser 0.2.9  \n', '', 0); // With whitespace
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(true);
      expect(result.metadata?.version).toBe('XCLogParser 0.2.9'); // Trimmed
      expect(result.metadata?.path).toBe('/usr/local/bin/xclogparser'); // Trimmed
    });

    test('should handle empty command output', async () => {
      // Mock which command returning empty output but success
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'which' && args[0] === 'xclogparser') {
          return createMockProcess('', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      // Mock version command
      vi.mocked(spawn).mockImplementationOnce((command, args) => {
        if (command === 'xclogparser' && args[0] === 'version') {
          return createMockProcess('', '', 0);
        }
        return createMockProcess('', '', 1);
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(true);
      expect(result.metadata?.version).toBe(''); // Empty but valid
      expect(result.metadata?.path).toBe(''); // Empty but valid
    });

    test('should handle process spawn errors', async () => {
      // Mock spawn throwing an error
      vi.mocked(spawn).mockImplementationOnce(() => {
        const mockProcess = {
          stdout: { on: vi.fn() },
          stderr: { on: vi.fn() },
          on: vi.fn((event, callback) => {
            if (event === 'error') {
              setTimeout(() => callback(new Error('ENOENT: no such file or directory')), 10);
            }
          }),
          kill: vi.fn()
        };
        return mockProcess;
      });

      const result = await EnvironmentValidator['validateXCLogParser']();

      expect(result.valid).toBe(false);
      expect(result.message).toBe('XCLogParser not found or not executable');
    });
  });
});

/**
 * Helper function to create a mock child process
 */
function createMockProcess(stdout: string, stderr: string, exitCode: number, delay = 10) {
  let killed = false;
  
  const mockProcess = {
    stdout: { on: vi.fn() },
    stderr: { on: vi.fn() },
    on: vi.fn(),
    kill: vi.fn(() => {
      killed = true;
    })
  };

  // Set up the mock behavior
  mockProcess.stdout.on.mockImplementation((event, callback) => {
    if (event === 'data' && !killed) {
      setTimeout(() => {
        if (!killed) callback(Buffer.from(stdout));
      }, delay);
    }
  });

  mockProcess.stderr.on.mockImplementation((event, callback) => {
    if (event === 'data' && !killed) {
      setTimeout(() => {
        if (!killed) callback(Buffer.from(stderr));
      }, delay);
    }
  });

  mockProcess.on.mockImplementation((event, callback) => {
    if (event === 'close' && !killed) {
      setTimeout(() => {
        if (!killed) callback(exitCode);
      }, delay + 5);
    }
    if (event === 'error' && delay > 5000) {
      // Simulate timeout for commands with long delays
      setTimeout(() => {
        if (!killed) callback(new Error('Command timed out'));
      }, 5000);
    }
  });

  return mockProcess;
}
</file>

<file path="__tests__/functional.test.js">
import { jest } from '@jest/globals';

describe('XcodeMCP Server Functional Tests', () => {
  test('should validate server startup script syntax', async () => {
    // Test that the main script can be imported without syntax errors
    expect(async () => {
      await import('../dist/index.js');
    }).not.toThrow();
  });

  test('should export XcodeMCPServer class', async () => {
    const module = await import('../dist/index.js');
    expect(module.XcodeMCPServer).toBeDefined();
    expect(typeof module.XcodeMCPServer).toBe('function');
  });

  test('should validate package.json structure', async () => {
    const packageJson = await import('../package.json', { assert: { type: 'json' } });
    
    expect(packageJson.default.name).toBe('xcodemcp');
    expect(packageJson.default.type).toBe('module');
    expect(packageJson.default.scripts.start).toBeDefined();
    expect(packageJson.default.scripts.test).toBeDefined();
    expect(packageJson.default.dependencies['@modelcontextprotocol/sdk']).toBeDefined();
  });

  test('should validate tool definitions completeness', () => {
    // Test the tool definitions without instantiating the class
    const expectedTools = [
      'xcode_open_project',
      'xcode_build', 
      'xcode_clean',
      'xcode_test',
      'xcode_run',
      'xcode_debug',
      'xcode_stop',
      'xcode_get_schemes',
      'xcode_get_run_destinations',
      'xcode_set_active_scheme',
      'xcode_get_workspace_info',
      'xcode_get_projects',
      'xcode_open_file'
    ];

    expect(expectedTools.length).toBe(13);
    expect(expectedTools).toContain('xcode_build');
    expect(expectedTools).toContain('xcode_test');
    expect(expectedTools).toContain('xcode_run');
  });

  test('should validate JXA script generation patterns', () => {
    // Test script patterns that should be valid JavaScript
    const testScripts = [
      'const app = Application("Xcode");',
      'const workspace = app.activeWorkspaceDocument();',
      'if (!workspace) throw new Error("No active workspace");',
      'const result = workspace.build();',
      'return `Build started. Result ID: ${result.id()}`;'
    ];

    testScripts.forEach(script => {
      expect(() => {
        // Validate JavaScript syntax by attempting to create a function
        new Function(script);
      }).not.toThrow();
    });
  });

  test('should validate AppleScript dictionary coverage', () => {
    // Test that we cover the main Xcode AppleScript features
    const xcodeFeatures = [
      'workspace document operations',
      'build actions', 
      'test execution',
      'debugging',
      'scheme management',
      'project access',
      'file operations'
    ];

    expect(xcodeFeatures.length).toBeGreaterThan(5);
  });
});
</file>

<file path="__tests__/integration.test.js">
import { jest } from '@jest/globals';
import { EventEmitter } from 'events';

// Create the mock spawn function before importing anything
const mockSpawn = jest.fn();

// Mock child_process before any imports
jest.unstable_mockModule('child_process', () => ({
  spawn: mockSpawn
}));

// Mock fs/promises
jest.unstable_mockModule('fs/promises', () => ({
  readdir: jest.fn(),
  stat: jest.fn()
}));

// Mock MCP SDK
jest.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: jest.fn().mockImplementation(() => ({
    setRequestHandler: jest.fn(),
    connect: jest.fn()
  }))
}));

jest.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: jest.fn()
}));

jest.mock('@modelcontextprotocol/sdk/types.js', () => ({
  CallToolRequestSchema: 'CallToolRequestSchema',
  ErrorCode: {
    MethodNotFound: 'MethodNotFound',
    InternalError: 'InternalError'
  },
  ListToolsRequestSchema: 'ListToolsRequestSchema',
  McpError: class McpError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
}));

// Suppress console.error during tests
const originalConsoleError = console.error;
beforeAll(() => {
  console.error = jest.fn();
});

afterAll(() => {
  console.error = originalConsoleError;
});

// Skip integration tests when Xcode is not available
const describeIfXcode = process.env.SKIP_XCODE_TESTS ? describe.skip : describe;

describeIfXcode('Integration Tests', () => {
  let XcodeMCPServer;
  let mockProcess;

  beforeAll(async () => {
    const module = await import('../dist/index.js');
    XcodeMCPServer = module.default || module.XcodeMCPServer;
  });

  beforeEach(() => {
    mockProcess = new EventEmitter();
    mockProcess.stdout = new EventEmitter();
    mockProcess.stderr = new EventEmitter();
    mockProcess.kill = jest.fn();
    jest.clearAllMocks();
    mockSpawn.mockClear();
    mockSpawn.mockReturnValue(mockProcess);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('Complete Workflow Tests', () => {
    test('should handle complete build workflow', async () => {
      const server = new XcodeMCPServer();
      
      // Step 1: Open project
      const openPromise = server.openProject('/Users/test/TestApp.xcodeproj');
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Project opened successfully\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const openResult = await openPromise;
      expect(openResult.content[0].text).toBe('Project opened successfully');
      
      // Reset mock for next call
      mockProcess = new EventEmitter();
      mockProcess.stdout = new EventEmitter();
      mockProcess.stderr = new EventEmitter();
      mockSpawn.mockReturnValue(mockProcess);
      
      // Step 2: Get workspace info
      const infoPromise = server.getWorkspaceInfo();
      setTimeout(() => {
        const workspaceInfo = JSON.stringify({
          name: 'TestApp.xcodeproj',
          path: '/Users/test/TestApp.xcodeproj',
          loaded: true,
          activeScheme: 'TestApp',
          activeRunDestination: 'iPhone 15 Simulator'
        }, null, 2);
        mockProcess.stdout.emit('data', workspaceInfo);
        mockProcess.emit('close', 0);
      }, 10);
      
      const infoResult = await infoPromise;
      const workspaceData = JSON.parse(infoResult.content[0].text);
      expect(workspaceData.loaded).toBe(true);
      expect(workspaceData.activeScheme).toBe('TestApp');
      
      // Reset mock for next call
      mockProcess = new EventEmitter();
      mockProcess.stdout = new EventEmitter();
      mockProcess.stderr = new EventEmitter();
      mockSpawn.mockReturnValue(mockProcess);
      
      // Step 3: Build project
      const buildPromise = server.build('/Users/test/TestApp.xcodeproj');
      setTimeout(() => {
        mockProcess.stdout.emit('data', '/Users/test/TestApp.xcodeproj\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const buildResult = await buildPromise;
      expect(buildResult.content[0].text).toContain('BUILD SUCCESSFUL');
    });

    test('should handle test workflow with custom arguments', async () => {
      const server = new XcodeMCPServer();
      
      // Step 1: Get available schemes
      const schemesPromise = server.getSchemes();
      setTimeout(() => {
        const schemes = JSON.stringify([
          { name: 'TestApp', id: 'scheme-1', isActive: true },
          { name: 'TestApp-Tests', id: 'scheme-2', isActive: false }
        ], null, 2);
        mockProcess.stdout.emit('data', schemes);
        mockProcess.emit('close', 0);
      }, 10);
      
      const schemesResult = await schemesPromise;
      const schemes = JSON.parse(schemesResult.content[0].text);
      expect(schemes).toHaveLength(2);
      
      // Reset mock for next call
      mockProcess = new EventEmitter();
      mockProcess.stdout = new EventEmitter();
      mockProcess.stderr = new EventEmitter();
      mockSpawn.mockReturnValue(mockProcess);
      
      // Step 2: Set active scheme to test scheme
      const setSchemePromise = server.setActiveScheme('TestApp-Tests');
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Active scheme set to: TestApp-Tests\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const setSchemeResult = await setSchemePromise;
      expect(setSchemeResult.content[0].text).toContain('TestApp-Tests');
      
      // Reset mock for next call
      mockProcess = new EventEmitter();
      mockProcess.stdout = new EventEmitter();
      mockProcess.stderr = new EventEmitter();
      mockSpawn.mockReturnValue(mockProcess);
      
      // Step 3: Run tests with arguments
      const testArgs = ['--verbose', '--parallel-testing-enabled', 'YES'];
      const testPromise = server.test(testArgs);
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Test started. Result ID: test-456\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const testResult = await testPromise;
      expect(testResult.content[0].text).toContain('Test started');
    });
  });

  describe('Error Recovery Tests', () => {
    test('should handle Xcode not running error', async () => {
      const server = new XcodeMCPServer();
      
      const buildPromise = server.build('/Users/test/TestApp.xcodeproj');
      setTimeout(() => {
        mockProcess.stderr.emit('data', 'Error: Application "Xcode" is not running\n');
        mockProcess.emit('close', 1);
      }, 10);
      
      await expect(buildPromise).rejects.toThrow('JXA execution failed');
    });

    test('should handle invalid scheme name', async () => {
      const server = new XcodeMCPServer();
      
      const setSchemePromise = server.setActiveScheme('NonExistentScheme');
      setTimeout(() => {
        mockProcess.stderr.emit('data', 'Error: Scheme "NonExistentScheme" not found\n');
        mockProcess.emit('close', 1);
      }, 10);
      
      await expect(setSchemePromise).rejects.toThrow('JXA execution failed');
    });

    test('should handle invalid project path', async () => {
      const server = new XcodeMCPServer();
      
      const openPromise = server.openProject('/invalid/path/Project.xcodeproj');
      setTimeout(() => {
        mockProcess.stderr.emit('data', 'Error: File not found\n');
        mockProcess.emit('close', 1);
      }, 10);
      
      await expect(openPromise).rejects.toThrow('JXA execution failed');
    });
  });

  describe('Performance and Timeout Tests', () => {
    test('should handle slow JXA execution', async () => {
      const server = new XcodeMCPServer();
      
      const buildPromise = server.build('/Users/test/TestApp.xcodeproj');
      
      // Simulate slow response
      setTimeout(() => {
        mockProcess.stdout.emit('data', '/Users/test/TestApp.xcodeproj\n');
        mockProcess.emit('close', 0);
      }, 100); // 100ms delay
      
      const result = await buildPromise;
      expect(result.content[0].text).toContain('BUILD SUCCESSFUL');
    });

    test('should handle multiple concurrent operations', async () => {
      const server = new XcodeMCPServer();
      
      // Create multiple mock processes for concurrent calls
      const processes = [];
      mockSpawn.mockImplementation(() => {
        const proc = new EventEmitter();
        proc.stdout = new EventEmitter();
        proc.stderr = new EventEmitter();
        processes.push(proc);
        return proc;
      });
      
      // Start multiple operations concurrently
      const promises = [
        server.getSchemes(),
        server.getRunDestinations(),
        server.getWorkspaceInfo()
      ];
      
      // Simulate responses for all processes
      setTimeout(() => {
        processes.forEach((proc, index) => {
          const responses = [
            JSON.stringify([{ name: 'Scheme1', id: '1', isActive: true }]),
            JSON.stringify([{ name: 'iPhone 15', platform: 'iOS', architecture: 'arm64', isActive: true }]),
            JSON.stringify({ name: 'Test', loaded: true })
          ];
          proc.stdout.emit('data', responses[index]);
          proc.emit('close', 0);
        });
      }, 10);
      
      const results = await Promise.all(promises);
      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result).toHaveProperty('content');
        expect(result.content[0]).toHaveProperty('text');
      });
    });
  });

  describe('Real-world Scenario Tests', () => {
    test('should handle debugging workflow', async () => {
      const server = new XcodeMCPServer();
      
      // Step 1: Get run destinations
      const destPromise = server.getRunDestinations();
      setTimeout(() => {
        const destinations = JSON.stringify([
          { name: 'iPhone 15 Pro', platform: 'iOS', architecture: 'arm64', isActive: false },
          { name: 'iPhone 15 Simulator', platform: 'iOS Simulator', architecture: 'x86_64', isActive: true }
        ], null, 2);
        mockProcess.stdout.emit('data', destinations);
        mockProcess.emit('close', 0);
      }, 10);
      
      const destResult = await destPromise;
      const destinations = JSON.parse(destResult.content[0].text);
      const activeDestination = destinations.find(d => d.isActive);
      expect(activeDestination.name).toBe('iPhone 15 Simulator');
      
      // Reset mock
      mockProcess = new EventEmitter();
      mockProcess.stdout = new EventEmitter();
      mockProcess.stderr = new EventEmitter();
      mockSpawn.mockReturnValue(mockProcess);
      
      // Step 2: Start debugging
      const debugPromise = server.debug('TestApp', false);
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Debug started. Result ID: debug-789\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const debugResult = await debugPromise;
      expect(debugResult.content[0].text).toContain('Debug started');
    });

    test('should handle file operations workflow', async () => {
      const server = new XcodeMCPServer();
      
      // Open a source file at specific line
      const filePath = '/Users/test/TestApp/ViewController.swift';
      const lineNumber = 25;
      
      const openFilePromise = server.openFile(filePath, lineNumber);
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'File opened successfully\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await openFilePromise;
      expect(result.content[0].text).toBe('File opened successfully');
      
      // Verify the correct osascript call was made
      expect(mockSpawn).toHaveBeenCalledWith('osascript', ['-l', 'JavaScript', '-e', expect.any(String)]);
      const script = mockSpawn.mock.calls[0][2][2];
      expect(script).toContain(filePath);
      expect(script).toContain(lineNumber.toString());
    });
  });
});
</file>

<file path="__tests__/mcp-handlers.test.js">
import { jest } from '@jest/globals';

// Mock the MCP SDK
const mockServer = {
  setRequestHandler: jest.fn(),
  connect: jest.fn()
};

jest.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: jest.fn().mockImplementation(() => mockServer)
}));

jest.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: jest.fn()
}));

jest.mock('@modelcontextprotocol/sdk/types.js', () => ({
  CallToolRequestSchema: 'CallToolRequestSchema',
  ErrorCode: {
    MethodNotFound: 'MethodNotFound',
    InternalError: 'InternalError'
  },
  ListToolsRequestSchema: 'ListToolsRequestSchema',
  McpError: class McpError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
}));

// Mock child_process
const mockSpawn = jest.fn();
jest.mock('child_process', () => ({
  spawn: mockSpawn
}));

// Suppress console.error during tests
const originalConsoleError = console.error;
beforeAll(() => {
  console.error = jest.fn();
});

afterAll(() => {
  console.error = originalConsoleError;
});

// Skip MCP handler tests when Xcode is not available  
const describeIfXcode = process.env.SKIP_XCODE_TESTS ? describe.skip : describe;

describeIfXcode('MCP Tool Handlers', () => {
  let XcodeMCPServer;
  let server;
  let listToolsHandler;
  let callToolHandler;

  beforeAll(async () => {
    const module = await import('../dist/index.js');
    XcodeMCPServer = module.default || module.XcodeMCPServer;
  });

  beforeEach(() => {
    server = new XcodeMCPServer();
    
    // Extract the handlers that were registered
    const setRequestHandlerCalls = mockServer.setRequestHandler.mock.calls;
    
    const listToolsCall = setRequestHandlerCalls.find(call => call[0] === 'ListToolsRequestSchema');
    const callToolCall = setRequestHandlerCalls.find(call => call[0] === 'CallToolRequestSchema');
    
    listToolsHandler = listToolsCall ? listToolsCall[1] : null;
    callToolHandler = callToolCall ? callToolCall[1] : null;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('ListTools Handler', () => {
    test('should return all available tools', async () => {
      expect(listToolsHandler).toBeDefined();
      
      const result = await listToolsHandler();
      
      expect(result).toHaveProperty('tools');
      expect(Array.isArray(result.tools)).toBe(true);
      expect(result.tools.length).toBeGreaterThan(0);
      
      // Check for essential tools
      const toolNames = result.tools.map(tool => tool.name);
      expect(toolNames).toContain('xcode_open_project');
      expect(toolNames).toContain('xcode_build');
      expect(toolNames).toContain('xcode_test');
      expect(toolNames).toContain('xcode_run');
      expect(toolNames).toContain('xcode_debug');
    });

    test('should include proper tool schemas', async () => {
      const result = await listToolsHandler();
      
      const openProjectTool = result.tools.find(tool => tool.name === 'xcode_open_project');
      expect(openProjectTool).toHaveProperty('description');
      expect(openProjectTool).toHaveProperty('inputSchema');
      expect(openProjectTool.inputSchema).toHaveProperty('properties');
      expect(openProjectTool.inputSchema.properties).toHaveProperty('path');
      expect(openProjectTool.inputSchema.required).toContain('path');
    });

    test('should include optional parameter tools', async () => {
      const result = await listToolsHandler();
      
      const testTool = result.tools.find(tool => tool.name === 'xcode_test');
      expect(testTool.inputSchema.properties).toHaveProperty('commandLineArguments');
      expect(testTool.inputSchema.properties.commandLineArguments.type).toBe('array');
      
      const debugTool = result.tools.find(tool => tool.name === 'xcode_debug');
      expect(debugTool.inputSchema.properties).toHaveProperty('scheme');
      expect(debugTool.inputSchema.properties).toHaveProperty('skipBuilding');
    });
  });

  describe('CallTool Handler', () => {
    test('should handle unknown tool names', async () => {
      expect(callToolHandler).toBeDefined();
      
      const request = {
        params: {
          name: 'unknown_tool',
          arguments: {}
        }
      };
      
      await expect(callToolHandler(request)).rejects.toThrow('Unknown tool: unknown_tool');
    });

    test('should route to correct methods for known tools', async () => {
      // Mock the individual methods
      const mockExecuteJXA = jest.fn().mockResolvedValue('Success');
      server.executeJXA = mockExecuteJXA;

      const toolTests = [
        { name: 'xcode_build', args: {} },
        { name: 'xcode_clean', args: {} },
        { name: 'xcode_stop', args: {} },
        { name: 'xcode_get_schemes', args: {} },
        { name: 'xcode_get_run_destinations', args: {} },
        { name: 'xcode_get_workspace_info', args: {} },
        { name: 'xcode_get_projects', args: {} }
      ];

      for (const { name, args } of toolTests) {
        const request = {
          params: { name, arguments: args }
        };

        const result = await callToolHandler(request);
        
        expect(result).toHaveProperty('content');
        expect(Array.isArray(result.content)).toBe(true);
        expect(result.content[0]).toHaveProperty('type', 'text');
        expect(result.content[0]).toHaveProperty('text');
      }
    });

    test('should handle tools with parameters correctly', async () => {
      const mockExecuteJXA = jest.fn().mockResolvedValue('Project opened successfully');
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_open_project',
          arguments: {
            path: '/Users/test/TestProject.xcodeproj'
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content[0].text).toBe('Project opened successfully');
      expect(mockExecuteJXA).toHaveBeenCalled();
    });

    test('should handle array parameters', async () => {
      const mockExecuteJXA = jest.fn().mockResolvedValue('Test started. Result ID: test-123');
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_test',
          arguments: {
            commandLineArguments: ['--verbose', '--parallel-testing-enabled', 'YES']
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content[0].text).toBe('Test started. Result ID: test-123');
      expect(mockExecuteJXA).toHaveBeenCalled();
    });

    test('should handle optional parameters', async () => {
      const mockExecuteJXA = jest.fn().mockResolvedValue('Debug started. Result ID: debug-456');
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_debug',
          arguments: {
            scheme: 'TestScheme',
            skipBuilding: true
          }
        }
      };

      const result = await callToolHandler(request);
      
      expect(result.content[0].text).toBe('Debug started. Result ID: debug-456');
      expect(mockExecuteJXA).toHaveBeenCalled();
    });

    test('should propagate execution errors', async () => {
      const mockExecuteJXA = jest.fn().mockRejectedValue(new Error('JXA execution failed'));
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_build',
          arguments: {}
        }
      };

      await expect(callToolHandler(request)).rejects.toThrow('Tool execution failed: JXA execution failed');
    });
  });

  describe('Tool Input Validation', () => {
    test('should handle missing required parameters gracefully', async () => {
      const mockExecuteJXA = jest.fn();
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_open_project',
          arguments: {} // Missing required 'path' parameter
        }
      };

      // The method should handle undefined gracefully
      await expect(callToolHandler(request)).rejects.toThrow();
    });

    test('should handle undefined optional parameters', async () => {
      const mockExecuteJXA = jest.fn().mockResolvedValue('Test started');
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_test',
          arguments: {
            // commandLineArguments is optional and not provided
          }
        }
      };

      const result = await callToolHandler(request);
      expect(result).toBeDefined();
    });

    test('should handle boolean parameters correctly', async () => {
      const mockExecuteJXA = jest.fn().mockResolvedValue('Debug started');
      server.executeJXA = mockExecuteJXA;

      const request = {
        params: {
          name: 'xcode_debug',
          arguments: {
            skipBuilding: false
          }
        }
      };

      const result = await callToolHandler(request);
      expect(result).toBeDefined();
    });
  });
});
</file>

<file path="__tests__/simple-unit.test.js">
import { jest } from '@jest/globals';

// Mock dependencies
jest.mock('child_process', () => ({
  spawn: jest.fn().mockReturnValue({
    stdout: { on: jest.fn() },
    stderr: { on: jest.fn() },
    on: jest.fn()
  })
}));

jest.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: jest.fn().mockImplementation(() => ({
    setRequestHandler: jest.fn(),
    connect: jest.fn()
  }))
}));

jest.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: jest.fn()
}));

jest.mock('@modelcontextprotocol/sdk/types.js', () => ({
  CallToolRequestSchema: 'CallToolRequestSchema',
  ErrorCode: {
    MethodNotFound: 'MethodNotFound',
    InternalError: 'InternalError'
  },
  ListToolsRequestSchema: 'ListToolsRequestSchema',
  McpError: class McpError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
}));

// Suppress console.error during tests
const originalConsoleError = console.error;
beforeAll(() => {
  console.error = jest.fn();
});

afterAll(() => {
  console.error = originalConsoleError;
});

describe('XcodeMCPServer Basic Tests', () => {
  let XcodeMCPServer;

  beforeAll(async () => {
    const module = await import('../dist/index.js');
    XcodeMCPServer = module.XcodeMCPServer;
  });

  test('should be able to instantiate XcodeMCPServer', () => {
    expect(() => new XcodeMCPServer()).not.toThrow();
  });

  test('should have executeJXA method', () => {
    const server = new XcodeMCPServer();
    expect(typeof server.executeJXA).toBe('function');
  });

  test('should have all required tool methods', () => {
    const server = new XcodeMCPServer();
    
    const requiredMethods = [
      'openProject',
      'build',
      'clean',
      'test',
      'run',
      'debug',
      'stop',
      'getSchemes',
      'getRunDestinations',
      'setActiveScheme',
      'getWorkspaceInfo',
      'getProjects',
      'openFile'
    ];

    requiredMethods.forEach(method => {
      expect(typeof server[method]).toBe('function');
    });
  });

  test('should properly format JXA scripts for simple operations', () => {
    const server = new XcodeMCPServer();
    
    // Test that methods exist and can be called (though they will fail without proper mocking)
    expect(() => server.openProject('/test/path')).not.toThrow();
    expect(() => server.build()).not.toThrow();
    expect(() => server.clean()).not.toThrow();
  });
});
</file>

<file path="__tests__/simple-unit.vitest.test.ts">
import { vi, describe, test, expect, beforeAll, afterAll } from 'vitest';

// Mock dependencies
vi.mock('child_process', () => ({
  spawn: vi.fn().mockReturnValue({
    stdout: { on: vi.fn() },
    stderr: { on: vi.fn() },
    on: vi.fn()
  })
}));

vi.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: vi.fn().mockImplementation(() => ({
    setRequestHandler: vi.fn(),
    connect: vi.fn()
  }))
}));

vi.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: vi.fn()
}));

vi.mock('@modelcontextprotocol/sdk/types.js', () => ({
  CallToolRequestSchema: 'CallToolRequestSchema',
  ErrorCode: {
    MethodNotFound: 'MethodNotFound',
    InternalError: 'InternalError'
  },
  ListToolsRequestSchema: 'ListToolsRequestSchema',
  McpError: class McpError extends Error {
    constructor(public code: string, message: string) {
      super(message);
      this.code = code;
    }
  },
  CallToolResult: {} // Mock type
}));

describe('XcodeMCPServer Basic Tests', () => {
  let XcodeMCPServer: any;

  beforeAll(async () => {
    const module = await import('../src/index.js');
    XcodeMCPServer = module.XcodeMCPServer;
  });

  test('should be able to instantiate XcodeMCPServer', () => {
    expect(() => new XcodeMCPServer()).not.toThrow();
  });

  test('should have executeJXA method', () => {
    const server = new XcodeMCPServer();
    expect(typeof server.executeJXA).toBe('function');
  });

  test('should have all required tool methods', () => {
    const server = new XcodeMCPServer();
    
    const requiredMethods = [
      'openProject',
      'validateProjectPath',
      'findProjectDerivedData',
      'getLatestBuildLog',
      'parseBuildLog',
      'canParseLog',
      'getCustomDerivedDataLocationFromXcodePreferences'
    ];

    requiredMethods.forEach(method => {
      expect(typeof server[method]).toBe('function');
    });
  });

  test('should properly format JXA scripts for simple operations', () => {
    const server = new XcodeMCPServer();
    
    // Test that methods exist and can be called (though they will fail without proper mocking)
    expect(() => server.openProject('/test/path')).not.toThrow();
  });
});
</file>

<file path=".github/workflows/publish.yml">
name: Publish to npm

on:
  release:
    types: [published]

jobs:
  publish:
    runs-on: macos-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Fetch full history for proper versioning
        fetch-depth: 0
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        registry-url: 'https://registry.npmjs.org'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        # Use npm install instead of npm ci to avoid strict CI environment flags
        # that cause test failures during publishing
        npm install --prefer-offline --no-audit --progress=false
    
    - name: Verify package integrity
      run: |
        echo "Verifying package.json..."
        if [ ! -f package.json ]; then
          echo "❌ package.json not found"
          exit 1
        fi
        
        # Check if package name and version are defined
        PACKAGE_NAME=$(node -p "require('./package.json').name")
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        
        if [ "$PACKAGE_NAME" = "undefined" ] || [ -z "$PACKAGE_NAME" ]; then
          echo "❌ Package name is not defined in package.json"
          exit 1
        fi
        
        if [ "$PACKAGE_VERSION" = "undefined" ] || [ -z "$PACKAGE_VERSION" ]; then
          echo "❌ Package version is not defined in package.json"
          exit 1
        fi
        
        echo "✅ Package: $PACKAGE_NAME@$PACKAGE_VERSION"
    
    - name: Run tests
      run: |
        # Only run simple unit tests in CI, skip integration tests that require Xcode
        npm test -- __tests__/simple-unit.vitest.test.ts __tests__/environment-validator.vitest.test.ts
      env:
        NODE_ENV: test
        CI: true
      continue-on-error: false
    
    - name: Check if package already exists
      id: check_package
      run: |
        PACKAGE_NAME=$(node -p "require('./package.json').name")
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        
        # Check if this version already exists on npm
        if npm view "$PACKAGE_NAME@$PACKAGE_VERSION" version >/dev/null 2>&1; then
          echo "❌ Package $PACKAGE_NAME@$PACKAGE_VERSION already exists on npm"
          echo "exists=true" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "✅ Package $PACKAGE_NAME@$PACKAGE_VERSION is ready to publish"
          echo "exists=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Build package (if build script exists)
      run: |
        if npm run build --if-present; then
          echo "✅ Build completed successfully"
        else
          echo "ℹ️ No build script found, skipping build step"
        fi
    
    - name: Publish to npm
      if: steps.check_package.outputs.exists == 'false'
      run: |
        echo "Publishing package to npm..."
        
        # Publish with error handling
        if npm publish --access public; then
          PACKAGE_NAME=$(node -p "require('./package.json').name")
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          echo "✅ Successfully published $PACKAGE_NAME@$PACKAGE_VERSION to npm"
          
          # Output the published package URL
          echo "📦 Package URL: https://www.npmjs.com/package/$PACKAGE_NAME"
        else
          echo "❌ Failed to publish package to npm"
          exit 1
        fi
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
    
    - name: Create release summary
      if: success()
      run: |
        PACKAGE_NAME=$(node -p "require('./package.json').name")
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        
        echo "## 🚀 Package Published Successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Package:** \`$PACKAGE_NAME@$PACKAGE_VERSION\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**NPM URL:** https://www.npmjs.com/package/$PACKAGE_NAME" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Installation:** \`npm install $PACKAGE_NAME\`" >> $GITHUB_STEP_SUMMARY
    
    - name: Publish failure notification
      if: failure()
      run: |
        echo "## ❌ Package Publishing Failed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "The package could not be published to npm. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Common issues:" >> $GITHUB_STEP_SUMMARY
        echo "- NPM_TOKEN secret not configured" >> $GITHUB_STEP_SUMMARY
        echo "- Package version already exists" >> $GITHUB_STEP_SUMMARY
        echo "- Test failures" >> $GITHUB_STEP_SUMMARY
        echo "- Network connectivity issues" >> $GITHUB_STEP_SUMMARY
</file>

<file path="src/tools/InfoTools.ts">
import { JXAExecutor } from '../utils/JXAExecutor.js';
import { PathValidator } from '../utils/PathValidator.js';
import type { McpResult, OpenProjectCallback } from '../types/index.js';

export class InfoTools {
  public static async getWorkspaceInfo(projectPath: string, openProject: OpenProjectCallback): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const info = {
          name: workspace.name(),
          path: workspace.path(),
          loaded: workspace.loaded(),
          activeScheme: workspace.activeScheme() ? workspace.activeScheme().name() : null,
          activeRunDestination: workspace.activeRunDestination() ? workspace.activeRunDestination().name() : null
        };
        
        return JSON.stringify(info, null, 2);
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }

  public static async getProjects(projectPath: string, openProject: OpenProjectCallback): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const projects = workspace.projects();
        const projectInfo = projects.map(project => ({
          name: project.name(),
          id: project.id()
        }));
        
        return JSON.stringify(projectInfo, null, 2);
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }

  public static async openFile(filePath: string, lineNumber?: number): Promise<McpResult> {
    const validationError = PathValidator.validateFilePath(filePath);
    if (validationError) return validationError;
    
    const script = `
      (function() {
        const app = Application('Xcode');
        app.open(${JSON.stringify(filePath)});
        
        ${lineNumber ? `
        const docs = app.sourceDocuments();
        const doc = docs.find(d => d.path().includes(${JSON.stringify(filePath.split('/').pop())}));
        if (doc) {
          app.hack({document: doc, start: ${lineNumber}, stop: ${lineNumber}});
        }` : ''}
        
        return 'File opened successfully';
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }
}
</file>

<file path="src/utils/ErrorHelper.ts">
export class ErrorHelper {
  public static createErrorWithGuidance(message: string, guidance: string): string {
    return `${message}\n\n💡 To fix this:\n${guidance}`;
  }

  public static getXcodeNotFoundGuidance(): string {
    return [
      "• Install Xcode from the Mac App Store",
      "• Make sure Xcode is in your /Applications folder",
      "• Launch Xcode once to complete the installation",
      "• Accept the license agreement when prompted"
    ].join('\n');
  }

  public static getProjectNotFoundGuidance(projectPath: string): string {
    return [
      `• Check that the path is correct: ${projectPath}`,
      "• Use an absolute path (starting with /)",
      "• Make sure the file extension is .xcodeproj or .xcworkspace",
      "• Verify the project file hasn't been moved or deleted"
    ].join('\n');
  }

  public static getSchemeNotFoundGuidance(schemeName: string, availableSchemes: string[] = []): string {
    const guidance = [
      `• Check the scheme name spelling: '${schemeName}'`,
      "• Scheme names are case-sensitive"
    ];
    
    if (availableSchemes.length > 0) {
      guidance.push("• Available schemes:");
      availableSchemes.forEach(scheme => {
        guidance.push(`  - ${scheme}`);
      });
    } else {
      guidance.push("• Run 'Get Schemes' to see available schemes");
    }
    
    return guidance.join('\n');
  }

  public static getDestinationNotFoundGuidance(destination: string, availableDestinations: string[] = []): string {
    const guidance = [
      `• Check the destination name spelling: '${destination}'`,
      "• Destination names are case-sensitive"
    ];
    
    if (availableDestinations.length > 0) {
      guidance.push("• Available destinations:");
      availableDestinations.forEach(dest => {
        guidance.push(`  - ${dest}`);
      });
    } else {
      guidance.push("• Run 'Get Run Destinations' to see available destinations");
    }
    
    return guidance.join('\n');
  }

  public static getXcodeNotRunningGuidance(): string {
    return [
      "• Launch Xcode application",
      "• Make sure Xcode is not stuck on a license agreement",
      "• Try restarting Xcode if it's already open",
      "• Check Activity Monitor for any hanging Xcode processes"
    ].join('\n');
  }

  public static getNoWorkspaceGuidance(): string {
    return [
      "• Open a project in Xcode first",
      "• Make sure the project has finished loading",
      "• Try closing and reopening the project if it's already open",
      "• Check that the project file is not corrupted"
    ].join('\n');
  }

  public static getBuildLogNotFoundGuidance(): string {
    return [
      "• Try building the project again",
      "• Check that Xcode has permission to write to derived data",
      "• Clear derived data (Product → Clean Build Folder) and rebuild",
      "• Ensure XCLogParser is installed: brew install xclogparser"
    ].join('\n');
  }

  public static getJXAPermissionGuidance(): string {
    return [
      "• Go to System Preferences → Privacy & Security → Automation",
      "• Allow your terminal app to control Xcode",
      "• You may need to restart your terminal after granting permission",
      "• If using VS Code, allow 'Code' to control Xcode"
    ].join('\n');
  }

  public static parseCommonErrors(error: Error | { message?: string }): string | null {
    const errorMessage = error.message || error.toString();
    
    if (errorMessage.includes('Xcode got an error: Application isn\'t running')) {
      return this.createErrorWithGuidance(
        "Xcode is not running",
        this.getXcodeNotRunningGuidance()
      );
    }
    
    if (errorMessage.includes('No active workspace')) {
      return this.createErrorWithGuidance(
        "No active workspace found in Xcode",
        this.getNoWorkspaceGuidance()
      );
    }
    
    if (errorMessage.includes('not allowed assistive access')) {
      return this.createErrorWithGuidance(
        "Permission denied - automation access required",
        this.getJXAPermissionGuidance()
      );
    }
    
    if (errorMessage.includes('osascript: command not found')) {
      return this.createErrorWithGuidance(
        "macOS scripting tools not available",
        "• This MCP server requires macOS\n• Make sure you're running on a Mac with osascript available"
      );
    }
    
    return null;
  }
}
</file>

<file path="src/utils/Logger.ts">
import { createWriteStream, WriteStream } from 'fs';
import { mkdir } from 'fs/promises';
import path from 'path';

/**
 * Configurable logging system for XcodeMCP
 * Supports log levels: DEBUG, INFO, WARN, ERROR, SILENT
 * Logs to stderr by default, with optional file logging
 * Environment variables:
 * - LOG_LEVEL: Sets the minimum log level (default: INFO)
 * - XCODEMCP_LOG_FILE: Optional file path for logging
 * - XCODEMCP_CONSOLE_LOGGING: Enable/disable console output (default: true)
 */
export class Logger {
  public static readonly LOG_LEVELS = {
    SILENT: 0,
    ERROR: 1,
    WARN: 2,
    INFO: 3,
    DEBUG: 4
  } as const;

  public static readonly LOG_LEVEL_NAMES: Record<number, string> = {
    0: 'SILENT',
    1: 'ERROR',
    2: 'WARN',
    3: 'INFO',
    4: 'DEBUG'
  };

  private static instance: Logger | null = null;

  private logLevel: number;
  private consoleLogging: boolean;
  private logFile: string | undefined;
  private fileStream: WriteStream | null = null;

  constructor() {
    this.logLevel = this.parseLogLevel(process.env.LOG_LEVEL || 'INFO');
    this.consoleLogging = process.env.XCODEMCP_CONSOLE_LOGGING !== 'false';
    this.logFile = process.env.XCODEMCP_LOG_FILE;
    this.setupFileLogging();
  }

  /**
   * Get or create the singleton logger instance
   */
  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  /**
   * Parse log level from string (case insensitive)
   */
  private parseLogLevel(levelStr: string): number {
    const level = levelStr.toUpperCase();
    const logLevelValue = Logger.LOG_LEVELS[level as keyof typeof Logger.LOG_LEVELS];
    return logLevelValue !== undefined ? logLevelValue : Logger.LOG_LEVELS.INFO;
  }

  /**
   * Setup file logging if specified
   */
  private async setupFileLogging(): Promise<void> {
    if (!this.logFile) {
      return;
    }

    try {
      // Create parent directories if they don't exist
      const dir = path.dirname(this.logFile);
      await mkdir(dir, { recursive: true });
      
      // Create write stream
      this.fileStream = createWriteStream(this.logFile, { flags: 'a' });
      
      this.fileStream.on('error', (error: Error) => {
        // Fallback to stderr if file logging fails
        if (this.consoleLogging) {
          process.stderr.write(`Logger: Failed to write to log file: ${error.message}\n`);
        }
      });
    } catch (error) {
      // Fallback to stderr if file setup fails
      if (this.consoleLogging) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        process.stderr.write(`Logger: Failed to setup log file: ${errorMessage}\n`);
      }
    }
  }

  /**
   * Format log message with timestamp and level
   */
  private formatMessage(level: number, message: string, ...args: unknown[]): string {
    const timestamp = new Date().toISOString();
    const levelName = Logger.LOG_LEVEL_NAMES[level];
    const formattedArgs = args.length > 0 ? ' ' + args.map(arg => 
      typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
    ).join(' ') : '';
    
    return `[${timestamp}] [${levelName}] XcodeMCP: ${message}${formattedArgs}`;
  }

  /**
   * Write log message to configured outputs
   */
  private writeLog(level: number, message: string, ...args: unknown[]): void {
    if (level > this.logLevel) {
      return; // Skip if below configured log level
    }

    const formattedMessage = this.formatMessage(level, message, ...args);

    // Always write to stderr for MCP protocol compatibility (unless console logging disabled)
    if (this.consoleLogging) {
      process.stderr.write(formattedMessage + '\n');
    }

    // Write to file if configured
    if (this.fileStream && this.fileStream.writable) {
      this.fileStream.write(formattedMessage + '\n');
    }
  }

  /**
   * Log at DEBUG level
   */
  public debug(message: string, ...args: unknown[]): void {
    this.writeLog(Logger.LOG_LEVELS.DEBUG, message, ...args);
  }

  /**
   * Log at INFO level
   */
  public info(message: string, ...args: unknown[]): void {
    this.writeLog(Logger.LOG_LEVELS.INFO, message, ...args);
  }

  /**
   * Log at WARN level
   */
  public warn(message: string, ...args: unknown[]): void {
    this.writeLog(Logger.LOG_LEVELS.WARN, message, ...args);
  }

  /**
   * Log at ERROR level
   */
  public error(message: string, ...args: unknown[]): void {
    this.writeLog(Logger.LOG_LEVELS.ERROR, message, ...args);
  }

  /**
   * Flush any pending log writes (important for process exit)
   */
  public async flush(): Promise<void> {
    return new Promise<void>((resolve) => {
      if (this.fileStream && this.fileStream.writable) {
        this.fileStream.end(resolve);
      } else {
        resolve();
      }
    });
  }

  /**
   * Get current log level as string
   */
  public getLogLevel(): string {
    return Logger.LOG_LEVEL_NAMES[this.logLevel] || 'UNKNOWN';
  }

  /**
   * Check if a log level is enabled
   */
  public isLevelEnabled(level: number): boolean {
    return level <= this.logLevel;
  }

  // Static convenience methods
  public static debug(message: string, ...args: unknown[]): void {
    Logger.getInstance().debug(message, ...args);
  }

  public static info(message: string, ...args: unknown[]): void {
    Logger.getInstance().info(message, ...args);
  }

  public static warn(message: string, ...args: unknown[]): void {
    Logger.getInstance().warn(message, ...args);
  }

  public static error(message: string, ...args: unknown[]): void {
    Logger.getInstance().error(message, ...args);
  }

  public static async flush(): Promise<void> {
    if (Logger.instance) {
      await Logger.instance.flush();
    }
  }

  public static getLogLevel(): string {
    return Logger.getInstance().getLogLevel();
  }

  public static isLevelEnabled(level: number): boolean {
    return Logger.getInstance().isLevelEnabled(level);
  }
}

// Ensure proper cleanup on process exit
process.on('exit', async () => {
  await Logger.flush();
});

process.on('SIGINT', async () => {
  await Logger.flush();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  await Logger.flush();
  process.exit(0);
});
</file>

<file path="src/utils/ParameterNormalizer.ts">
export class ParameterNormalizer {
  
  public static normalizeDestinationName(destination: string): string {
    if (!destination || typeof destination !== 'string') {
      return destination;
    }
    
    // Remove extra whitespace and normalize case
    let normalized = destination.trim();
    
    // Common destination name variations
    const destinationMappings: Record<string, string> = {
      // iPhone variants
      'iphone': 'iPhone',
      'iphone-15': 'iPhone 15',
      'iphone-15-pro': 'iPhone 15 Pro',
      'iphone-15-pro-max': 'iPhone 15 Pro Max',
      'iphone-16': 'iPhone 16',
      'iphone-16-pro': 'iPhone 16 Pro',
      'iphone-16-pro-max': 'iPhone 16 Pro Max',
      'iphone-14': 'iPhone 14',
      'iphone-14-pro': 'iPhone 14 Pro',
      'iphone-14-pro-max': 'iPhone 14 Pro Max',
      'iphone-13': 'iPhone 13',
      'iphone-13-pro': 'iPhone 13 Pro',
      'iphone-13-pro-max': 'iPhone 13 Pro Max',
      
      // iPad variants
      'ipad': 'iPad',
      'ipad-air': 'iPad Air',
      'ipad-pro': 'iPad Pro',
      'ipad-mini': 'iPad mini',
      
      // Simulator variants
      'simulator': 'Simulator',
      'sim': 'Simulator',
      
      // Mac variants
      'mac': 'Mac',
      'my-mac': 'My Mac',
      'mymac': 'My Mac',
    };
    
    // Try exact mapping first
    const lowerNormalized = normalized.toLowerCase();
    if (destinationMappings[lowerNormalized]) {
      return destinationMappings[lowerNormalized];
    }
    
    // Try pattern matching for simulator names
    if (lowerNormalized.includes('simulator')) {
      // Handle "iPhone 15 Simulator" -> keep as is but normalize spacing
      normalized = normalized.replace(/\s+/g, ' ').trim();
      return normalized;
    }
    
    // Handle dash/underscore to space conversion for device names
    if (lowerNormalized.includes('-') || lowerNormalized.includes('_')) {
      normalized = normalized
        .replace(/[-_]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
      
      // Capitalize words appropriately
      normalized = this._capitalizeDeviceName(normalized);
    }
    
    return normalized;
  }
  
  public static normalizeSchemeName(schemeName: string): string {
    if (!schemeName || typeof schemeName !== 'string') {
      return schemeName;
    }
    
    // Remove extra whitespace
    let normalized = schemeName.trim();
    
    // Common scheme name patterns
    const schemeMappings: Record<string, string> = {
      // Test scheme variants
      'test': 'Tests',
      'tests': 'Tests',
      'unit-test': 'UnitTests',
      'unit-tests': 'UnitTests',
      'unittests': 'UnitTests',
      'integration-test': 'IntegrationTests',
      'integration-tests': 'IntegrationTests',
      'integrationtests': 'IntegrationTests',
      
      // Debug/Release variants
      'debug': 'Debug',
      'release': 'Release',
      'prod': 'Release',
      'production': 'Release',
      'dev': 'Debug',
      'development': 'Debug',
    };
    
    const lowerNormalized = normalized.toLowerCase();
    if (schemeMappings[lowerNormalized]) {
      return schemeMappings[lowerNormalized];
    }
    
    // Handle dash/underscore to space conversion, but preserve original casing
    if (normalized.includes('-') || normalized.includes('_')) {
      // Don't modify case for scheme names as they're often project-specific
      normalized = normalized.replace(/[-_]/g, ' ').replace(/\s+/g, ' ').trim();
    }
    
    return normalized;
  }
  
  private static _capitalizeDeviceName(name: string): string {
    const words = name.split(' ');
    return words.map(word => {
      const lower = word.toLowerCase();
      
      // Special cases
      if (lower === 'iphone') return 'iPhone';
      if (lower === 'ipad') return 'iPad';
      if (lower === 'mac') return 'Mac';
      if (lower === 'pro') return 'Pro';
      if (lower === 'max') return 'Max';
      if (lower === 'mini') return 'mini';
      if (lower === 'air') return 'Air';
      if (lower === 'simulator') return 'Simulator';
      
      // Numbers stay as-is
      if (/^\d+$/.test(word)) return word;
      
      // Default capitalization
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    }).join(' ');
  }
  
  // Fuzzy matching for when exact normalization doesn't work
  public static findBestMatch(input: string, availableOptions: string[]): string | null {
    if (!input || !availableOptions || !Array.isArray(availableOptions)) {
      return null;
    }
    
    const normalized = input.toLowerCase().trim();
    
    // Try exact match first
    const exactMatch = availableOptions.find(option => 
      option.toLowerCase() === normalized
    );
    if (exactMatch) return exactMatch;
    
    // Try partial match
    const partialMatches = availableOptions.filter(option =>
      option.toLowerCase().includes(normalized) || 
      normalized.includes(option.toLowerCase())
    );
    
    if (partialMatches.length === 1) {
      return partialMatches[0] || null;
    }
    
    // Try fuzzy matching for common typos
    const fuzzyMatches = availableOptions.filter(option => {
      const optionLower = option.toLowerCase();
      return this._calculateSimilarity(normalized, optionLower) > 0.7;
    });
    
    if (fuzzyMatches.length === 1) {
      return fuzzyMatches[0] || null;
    }
    
    return null;
  }
  
  private static _calculateSimilarity(str1: string, str2: string): number {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) {
      return 1.0;
    }
    
    const editDistance = this._levenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }
  
  private static _levenshteinDistance(str1: string, str2: string): number {
    const matrix: number[][] = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0]![j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i]![j] = matrix[i - 1]![j - 1]!;
        } else {
          matrix[i]![j] = Math.min(
            matrix[i - 1]![j - 1]! + 1,
            matrix[i]![j - 1]! + 1,
            matrix[i - 1]![j]! + 1
          );
        }
      }
    }
    
    return matrix[str2.length]![str1.length]!;
  }
}
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="slim-ui-tree.js">
// slim-ui-tree.js
// Usage:  node slim-ui-tree.js in.json out.json
// Keeps only id, type (t), label (l), frame (f) & children (c).

const fs   = require('fs');
const path = require('path');

if (process.argv.length < 4) {
  console.error('Usage: node slim-ui-tree.js <input.json> <output.json>');
  process.exit(1);
}

const [ , , inFile, outFile ] = process.argv;

/**
 * Recursively strips an AX-style node down to essentials.
 *  – Renames keys to 1-letter shorthands.
 *  – Omits heavy / redundant fields.
 */
function slim(node) {
  if (node == null || typeof node !== 'object') return node;

  // Extract label from raw field (pattern: label: 'text')
  const labelMatch = node.raw?.match(/label: '([^']+)'/);
  const extractedLabel = labelMatch ? labelMatch[1] : undefined;

  const slimmed = {
    t  : node.type,
    l  : extractedLabel || node.label || undefined,
  };

  // recurse if children present
  if (Array.isArray(node.children) && node.children.length) {
    slimmed.c = node.children.map(slim);
  }

  // drop undefined keys to save bytes
  Object.keys(slimmed).forEach(k => slimmed[k] === undefined && delete slimmed[k]);
  return slimmed;
}

try {
  const raw = JSON.parse(fs.readFileSync(inFile, 'utf8'));
  const slimmed = slim(raw.rootElement || raw);
  fs.writeFileSync(outFile, JSON.stringify(slimmed));
  const inKB  = fs.statSync(inFile).size  / 1024;
  const outKB = fs.statSync(outFile).size / 1024;
  console.log(`✓ Wrote ${path.basename(outFile)} (${outKB.toFixed(1)} KB, ` +
              `${(100 * outKB / inKB).toFixed(1)} % of original)`);
} catch (e) {
  console.error('⚠️  ' + e.message);
  process.exit(1);
}
</file>

<file path="test-client.js">
#!/usr/bin/env node

import { spawn } from 'child_process';
import { createInterface } from 'readline';

const server = spawn('node', ['dist/index.js'], {
  stdio: ['pipe', 'pipe', 'inherit']
});

const rl = createInterface({
  input: process.stdin,
  output: process.stdout,
  prompt: 'MCP> '
});

// Handle server output
server.stdout.on('data', (data) => {
  const lines = data.toString().split('\n').filter(line => line.trim());
  lines.forEach(line => {
    try {
      const parsed = JSON.parse(line);
      console.log('Server response:', JSON.stringify(parsed, null, 2));
    } catch {
      console.log('Server log:', line);
    }
  });
  rl.prompt();
});

// Initialize connection
const initMessage = JSON.stringify({
  jsonrpc: "2.0",
  id: 1,
  method: "initialize",
  params: {
    protocolVersion: "2024-11-05",
    capabilities: {},
    clientInfo: { name: "test-client", version: "1.0.0" }
  }
});

server.stdin.write(initMessage + '\n');

console.log('MCP Test Client - Type commands or "help" for examples');
rl.prompt();

rl.on('line', (input) => {
  const cmd = input.trim();
  
  if (cmd === 'help') {
    console.log('Examples:');
    console.log('  list - List all tools');
    console.log('  health - Check Xcode health');
    console.log('  quit - Exit');
  } else if (cmd === 'list') {
    const msg = JSON.stringify({
      jsonrpc: "2.0",
      id: Date.now(),
      method: "tools/list"
    });
    server.stdin.write(msg + '\n');
  } else if (cmd === 'health') {
    const msg = JSON.stringify({
      jsonrpc: "2.0",
      id: Date.now(),
      method: "tools/call",
      params: {
        name: "xcode_health",
        arguments: {}
      }
    });
    server.stdin.write(msg + '\n');
  } else if (cmd === 'quit') {
    server.kill();
    process.exit(0);
  } else if (cmd.startsWith('{')) {
    // Raw JSON input
    server.stdin.write(cmd + '\n');
  } else {
    console.log('Unknown command. Type "help" for examples.');
  }
  
  rl.prompt();
});

rl.on('close', () => {
  server.kill();
  process.exit(0);
});
</file>

<file path="test-setup.js">
import { vi } from 'vitest';

// Suppress console.error during tests
const originalConsoleError = console.error;
console.error = vi.fn();

// Mock file system operations that might not be available in test environment
vi.mock('fs', async () => {
  const actual = await vi.importActual('fs');
  return {
    ...actual,
    existsSync: vi.fn().mockReturnValue(true), // Default to file exists
  };
});

vi.mock('fs/promises', async () => {
  const actual = await vi.importActual('fs/promises');
  return {
    ...actual,
    stat: vi.fn().mockResolvedValue({ size: 1000, mtime: new Date() }),
  };
});

// Clean up after tests
afterAll(() => {
  console.error = originalConsoleError;
});
</file>

<file path="test-tool-live.sh">
#!/bin/bash

# Test script for MCP tools that shows output in real-time

if [ $# -lt 2 ]; then
    echo "Usage: $0 <tool_name> <json_args>"
    echo "Example: $0 xcresult_get_ui_hierarchy '{\"xcresult_path\": \"/path/to/file.xcresult\", \"test_id\": \"TestSuite/testMethod()\"}'"
    exit 1
fi

TOOL_NAME="$1"
ARGS="$2"

# Create the JSON RPC request
REQUEST="{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/call\", \"params\": {\"name\": \"$TOOL_NAME\", \"arguments\": $ARGS}}"

echo "🔧 Testing tool: $TOOL_NAME"
echo "📨 Request: $REQUEST"
echo "=" | tr '=' '-' | sed 's/./=/g' | head -c 50; echo
echo "⏳ Running (press Ctrl+C to stop)..."
echo

# Run the tool with live output - stderr goes to stderr, stdout gets processed
echo "$REQUEST" | node dist/index.js | (
    read -r response
    echo "📄 Response:"
    echo "$response" | jq . 2>/dev/null || echo "$response"
)
</file>

<file path="test-tool.sh">
#!/bin/bash

# Test script for MCP tools that shows both logs and JSON response

if [ $# -lt 2 ]; then
    echo "Usage: $0 <tool_name> <json_args>"
    echo "Example: $0 xcresult_get_ui_hierarchy '{\"xcresult_path\": \"/path/to/file.xcresult\", \"test_id\": \"TestSuite/testMethod()\"}'"
    exit 1
fi

TOOL_NAME="$1"
ARGS="$2"

# Create the JSON RPC request
REQUEST="{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/call\", \"params\": {\"name\": \"$TOOL_NAME\", \"arguments\": $ARGS}}"

echo "🔧 Testing tool: $TOOL_NAME"
echo "📨 Request: $REQUEST"
echo "=" | tr '=' '-' | sed 's/./=/g' | head -c 50; echo

# Run the tool and capture both stdout and stderr
TEMP_OUT=$(mktemp)
TEMP_ERR=$(mktemp)

echo "$REQUEST" | node dist/index.js > "$TEMP_OUT" 2> "$TEMP_ERR"

echo "📋 Logs:"
cat "$TEMP_ERR"
echo
echo "📄 Response:"
head -1 "$TEMP_OUT" | jq . 2>/dev/null || head -1 "$TEMP_OUT"

# Cleanup
rm "$TEMP_OUT" "$TEMP_ERR"
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "node",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowSyntheticDefaultImports": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": false,
    "preserveConstEnums": true,
    "allowUnusedLabels": false,
    "allowUnreachableCode": false,
    "exactOptionalPropertyTypes": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "noImplicitReturns": true,
    "noPropertyAccessFromIndexSignature": false,
    "noUncheckedIndexedAccess": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "verbatimModuleSyntax": false
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "__tests__",
    "coverage"
  ],
  "ts-node": {
    "esm": true
  }
}
</file>

<file path="__tests__/functional.vitest.test.js">
import { describe, test, expect } from 'vitest';

describe('XcodeMCP Server Functional Tests', () => {
  test('should validate server startup script syntax', async () => {
    // Test that the main script can be imported without syntax errors
    expect(async () => {
      await import('../dist/index.js');
    }).not.toThrow();
  });

  test('should export XcodeMCPServer class', async () => {
    const module = await import('../dist/index.js');
    expect(module.XcodeMCPServer).toBeDefined();
    expect(typeof module.XcodeMCPServer).toBe('function');
  });

  test('should validate package.json structure', async () => {
    const packageJson = await import('../package.json', { assert: { type: 'json' } });
    
    expect(packageJson.default.name).toBe('xcodemcp');
    expect(packageJson.default.type).toBe('module');
    expect(packageJson.default.scripts.start).toBeDefined();
    expect(packageJson.default.scripts.test).toBeDefined();
    expect(packageJson.default.dependencies['@modelcontextprotocol/sdk']).toBeDefined();
  });

  test('should validate tool definitions completeness', () => {
    // Test the tool definitions without instantiating the class
    const expectedTools = [
      'xcode_open_project',
      'xcode_build', 
      'xcode_clean',
      'xcode_test',
      'xcode_run',
      'xcode_debug',
      'xcode_stop',
      'xcode_get_schemes',
      'xcode_get_run_destinations',
      'xcode_set_active_scheme',
      'xcode_get_workspace_info',
      'xcode_get_projects',
      'xcode_open_file'
    ];

    expect(expectedTools.length).toBe(13);
    expect(expectedTools).toContain('xcode_build');
    expect(expectedTools).toContain('xcode_test');
    expect(expectedTools).toContain('xcode_run');
  });

  test('should validate JXA script generation patterns', () => {
    // Test script patterns that should be valid JavaScript
    const testScripts = [
      'const app = Application("Xcode");',
      'const workspace = app.activeWorkspaceDocument();',
      'if (!workspace) throw new Error("No active workspace");',
      'const result = workspace.build();',
      'return `Build started. Result ID: ${result.id()}`;'
    ];

    testScripts.forEach(script => {
      expect(() => {
        // Validate JavaScript syntax by attempting to create a function
        new Function(script);
      }).not.toThrow();
    });
  });

  test('should validate AppleScript dictionary coverage', () => {
    // Test that we cover the main Xcode AppleScript features
    const xcodeFeatures = [
      'workspace document operations',
      'build actions', 
      'test execution',
      'debugging',
      'scheme management',
      'project access',
      'file operations'
    ];

    expect(xcodeFeatures.length).toBeGreaterThan(5);
  });
});
</file>

<file path="__tests__/parameter-mismatch-prevention.vitest.test.js">
/**
 * Simplified tests to prevent parameter mismatch bugs like the xcode_run issue
 * Focus on catching "not defined" variable errors in function signatures
 */

import { describe, test, expect, beforeEach } from 'vitest';
import { XcodeMCPServer } from '../dist/index.js';

describe.skip('Parameter Mismatch Prevention', () => {
  let server;

  beforeEach(() => {
    server = new XcodeMCPServer();
  });

  describe('Function Parameter Counts', () => {
    test('functions have expected parameter counts (prevents signature mismatches)', () => {
      // These counts reflect the actual required parameters (without defaults)
      const expectedCounts = {
        build: 1,           // projectPath (schemeName and destination have defaults)
        clean: 1,           // projectPath
        test: 1,            // projectPath (commandLineArguments has default)
        run: 1,             // projectPath (commandLineArguments has default)  
        debug: 2,           // projectPath, scheme (skipBuilding has default)
        stop: 0,            // no parameters
        getSchemes: 1,      // projectPath
        getRunDestinations: 1, // projectPath
        setActiveScheme: 2, // projectPath, schemeName
        getWorkspaceInfo: 1, // projectPath
        getProjects: 1,     // projectPath
        openFile: 2,        // filePath, lineNumber
        openProject: 1      // projectPath
      };

      Object.entries(expectedCounts).forEach(([functionName, expectedCount]) => {
        const actualCount = server[functionName].length;
        expect(actualCount).toBe(expectedCount);
      });
    });
  });

  describe('Critical Function Signature Validation', () => {
    test('run function accepts projectPath as first parameter', () => {
      // This test specifically prevents the "actualProjectPath is not defined" bug
      expect(server.run.length).toBeGreaterThanOrEqual(1);
      
      // Verify function doesn't immediately throw on parameter access
      const functionString = server.run.toString();
      expect(functionString).toContain('projectPath');
      expect(functionString).not.toContain('actualProjectPath');
    });

    test('test function accepts projectPath as first parameter', () => {
      expect(server.test.length).toBeGreaterThanOrEqual(1);
      
      const functionString = server.test.toString();
      expect(functionString).toContain('projectPath');
    });

    test('debug function accepts projectPath as first parameter', () => {
      expect(server.debug.length).toBeGreaterThanOrEqual(1);
      
      const functionString = server.debug.toString();
      expect(functionString).toContain('projectPath');
    });

    test('all tool handler calls match function signatures', () => {
      // Check that the call site mapping in setupToolHandlers matches function signatures
      // This prevents runtime "not defined" errors
      
      const callMappings = [
        { tool: 'xcode_build', method: 'build', args: ['args.path', 'args.scheme', 'args.destination'] },
        { tool: 'xcode_clean', method: 'clean', args: ['args.path'] },
        { tool: 'xcode_test', method: 'test', args: ['args.path', 'args.commandLineArguments'] },
        { tool: 'xcode_run', method: 'run', args: ['args.path', 'args.commandLineArguments'] },
        { tool: 'xcode_debug', method: 'debug', args: ['args.path', 'args.scheme', 'args.skipBuilding'] },
        { tool: 'xcode_stop', method: 'stop', args: [] },
        { tool: 'xcode_get_schemes', method: 'getSchemes', args: ['args.path'] },
        { tool: 'xcode_set_active_scheme', method: 'setActiveScheme', args: ['args.path', 'args.schemeName'] },
        { tool: 'xcode_get_run_destinations', method: 'getRunDestinations', args: ['args.path'] },
        { tool: 'xcode_get_workspace_info', method: 'getWorkspaceInfo', args: ['args.path'] },
        { tool: 'xcode_get_projects', method: 'getProjects', args: ['args.path'] },
        { tool: 'xcode_open_file', method: 'openFile', args: ['args.filePath', 'args.lineNumber'] }
      ];

      callMappings.forEach(mapping => {
        const method = server[mapping.method];
        const requiredArgCount = method.length;
        const providedArgCount = mapping.args.length;
        
        expect(providedArgCount).toBeGreaterThanOrEqual(requiredArgCount);
      });
    });
  });

  describe('Variable Reference Validation', () => {
    test('run function does not reference undefined variables', () => {
      const functionString = server.run.toString();
      
      // Should not contain references to undefined variables like actualProjectPath
      expect(functionString).not.toContain('actualProjectPath');
      
      // Should use the parameter name consistently
      if (functionString.includes('getLatestBuildLog')) {
        expect(functionString).toContain('getLatestBuildLog(projectPath');
      }
    });

    test('test function does not reference undefined variables', () => {
      const functionString = server.test.toString();
      expect(functionString).not.toContain('actualProjectPath');
    });

    test('debug function does not reference undefined variables', () => {
      const functionString = server.debug.toString();
      expect(functionString).not.toContain('actualProjectPath');
    });
  });
});
</file>

<file path="__tests__/simple-unit.vitest.test.js">
import { vi, describe, test, expect, beforeAll, afterAll } from 'vitest';

// Mock dependencies
vi.mock('child_process', () => ({
  spawn: vi.fn().mockReturnValue({
    stdout: { on: vi.fn() },
    stderr: { on: vi.fn() },
    on: vi.fn()
  })
}));

vi.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: vi.fn().mockImplementation(() => ({
    setRequestHandler: vi.fn(),
    connect: vi.fn()
  }))
}));

vi.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: vi.fn()
}));

vi.mock('@modelcontextprotocol/sdk/types.js', () => ({
  CallToolRequestSchema: 'CallToolRequestSchema',
  ErrorCode: {
    MethodNotFound: 'MethodNotFound',
    InternalError: 'InternalError'
  },
  ListToolsRequestSchema: 'ListToolsRequestSchema',
  McpError: class McpError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
}));

describe('XcodeMCPServer Basic Tests', () => {
  let XcodeMCPServer;

  beforeAll(async () => {
    const module = await import('../dist/index.js');
    XcodeMCPServer = module.XcodeMCPServer;
  });

  test('should be able to instantiate XcodeMCPServer', () => {
    expect(() => new XcodeMCPServer()).not.toThrow();
  });

  test('should have executeJXA method', () => {
    const server = new XcodeMCPServer();
    expect(typeof server.executeJXA).toBe('function');
  });

  test.skip('should have all required tool methods', () => {
    // These are MCP tools, not instance methods
    // This test needs to be rewritten to test the tool handlers
  });

  test.skip('should properly format JXA scripts for simple operations', () => {
    // These are MCP tools, not instance methods
    // This test needs to be rewritten to test the tool handlers
  });
});
</file>

<file path="__tests__/xcode-server.test.js">
import { jest } from '@jest/globals';
import { EventEmitter } from 'events';
import * as childProcess from 'child_process';

// Get the mocked spawn function
const mockSpawn = jest.fn();
const spawn = mockSpawn; // Add alias for tests

// Mock the child_process module
jest.mock('child_process', () => ({
  spawn: mockSpawn
}));

// Mock the MCP SDK
jest.mock('@modelcontextprotocol/sdk/server/index.js', () => ({
  Server: jest.fn().mockImplementation(() => ({
    setRequestHandler: jest.fn(),
    connect: jest.fn().mockResolvedValue()
  }))
}));

jest.mock('@modelcontextprotocol/sdk/server/stdio.js', () => ({
  StdioServerTransport: jest.fn()
}));

jest.mock('@modelcontextprotocol/sdk/types.js', () => ({
  CallToolRequestSchema: 'CallToolRequestSchema',
  ErrorCode: {
    MethodNotFound: 'MethodNotFound',
    InternalError: 'InternalError'
  },
  ListToolsRequestSchema: 'ListToolsRequestSchema',
  McpError: class McpError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
}));

// Suppress console.error during tests
const originalConsoleError = console.error;
beforeAll(() => {
  console.error = jest.fn();
});

afterAll(() => {
  console.error = originalConsoleError;
});

// Skip tests when Xcode is not available
const describeIfXcode = process.env.SKIP_XCODE_TESTS ? describe.skip : describe;

describeIfXcode('XcodeMCPServer', () => {
  let XcodeMCPServer;
  let mockProcess;

  beforeAll(async () => {
    // Import after mocks are set up
    const module = await import('../dist/index.js');
    XcodeMCPServer = module.XcodeMCPServer;
  });

  beforeEach(() => {
    // Create a mock process that behaves like osascript
    mockProcess = new EventEmitter();
    mockProcess.stdout = new EventEmitter();
    mockProcess.stderr = new EventEmitter();
    mockProcess.kill = jest.fn();
    
    jest.clearAllMocks();
    mockSpawn.mockReturnValue(mockProcess);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('executeJXA', () => {
    test('should execute JXA script successfully', async () => {
      const server = new XcodeMCPServer();
      const testScript = 'Application("Xcode").name()';
      
      // Execute the method asynchronously
      const resultPromise = server.executeJXA(testScript);
      
      // Simulate successful execution
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Xcode\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalledWith('osascript', ['-l', 'JavaScript', '-e', testScript]);
      expect(result).toBe('Xcode');
    });

    test('should handle JXA execution errors', async () => {
      const server = new XcodeMCPServer();
      const testScript = 'invalid script';
      
      const resultPromise = server.executeJXA(testScript);
      
      // Simulate error
      setTimeout(() => {
        mockProcess.stderr.emit('data', 'Error: Script failed\n');
        mockProcess.emit('close', 1);
      }, 10);
      
      await expect(resultPromise).rejects.toThrow('JXA execution failed: Error: Script failed');
    });
  });

  describe('Tool argument validation', () => {
    test('should generate correct JXA script for openProject', async () => {
      const server = new XcodeMCPServer();
      const testPath = '/Users/test/TestProject.xcodeproj';
      
      // Mock successful execution
      const resultPromise = server.openProject(testPath);
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Project opened successfully\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalled();
      const spawnArgs = spawn.mock.calls[0][2];
      expect(spawnArgs[0]).toContain(testPath);
      expect(result.content[0].text).toBe('Project opened successfully');
    });

    test('should generate correct JXA script for test with arguments', async () => {
      const server = new XcodeMCPServer();
      const testPath = '/Users/test/TestProject.xcodeproj';
      const testArgs = ['--verbose', '--parallel-testing-enabled', 'YES'];
      
      const resultPromise = server.test(testPath, testArgs);
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Test started. Result ID: test-123\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalled();
      const spawnArgs = spawn.mock.calls[0][2];
      expect(spawnArgs[0]).toContain(JSON.stringify(testArgs));
      expect(result.content[0].text).toBe('Test started. Result ID: test-123');
    });

    test('should generate correct JXA script for debug with optional parameters', async () => {
      const server = new XcodeMCPServer();
      const scheme = 'TestScheme';
      const skipBuilding = true;
      
      const resultPromise = server.debug(scheme, skipBuilding);
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Debug started. Result ID: debug-456\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalled();
      const spawnArgs = spawn.mock.calls[0][2];
      expect(spawnArgs[0]).toContain(`scheme: "${scheme}"`);
      expect(spawnArgs[0]).toContain('skipBuilding: true');
      expect(result.content[0].text).toBe('Debug started. Result ID: debug-456');
    });
  });

  describe('JSON parsing for complex responses', () => {
    test('should parse schemes response correctly', async () => {
      const server = new XcodeMCPServer();
      const mockSchemesResponse = JSON.stringify([
        { name: 'MyApp', id: 'scheme-1', isActive: true },
        { name: 'MyApp-Tests', id: 'scheme-2', isActive: false }
      ], null, 2);
      
      const resultPromise = server.getSchemes();
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', mockSchemesResponse);
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(result.content[0].text).toBe(mockSchemesResponse);
    });

    test('should parse workspace info response correctly', async () => {
      const server = new XcodeMCPServer();
      const mockWorkspaceInfo = JSON.stringify({
        name: 'TestWorkspace.xcworkspace',
        path: '/Users/test/TestWorkspace.xcworkspace',
        loaded: true,
        activeScheme: 'MyApp',
        activeRunDestination: 'iPhone 15 Simulator'
      }, null, 2);
      
      const resultPromise = server.getWorkspaceInfo();
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', mockWorkspaceInfo);
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(result.content[0].text).toBe(mockWorkspaceInfo);
    });
  });

  describe('Edge cases and error handling', () => {
    test('should handle empty command line arguments', async () => {
      const server = new XcodeMCPServer();
      
      const resultPromise = server.test([]);
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'Test started. Result ID: test-empty\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalled();
      const spawnArgs = spawn.mock.calls[0][2];
      // Should not contain withCommandLineArguments when empty
      expect(spawnArgs[0]).not.toContain('withCommandLineArguments');
    });

    test('should handle scheme name with special characters', async () => {
      const server = new XcodeMCPServer();
      const schemeName = "My-App's Test Scheme";
      
      const resultPromise = server.setActiveScheme(schemeName);
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', `Active scheme set to: ${schemeName}\n`);
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalled();
      const spawnArgs = spawn.mock.calls[0][2];
      expect(spawnArgs[0]).toContain(schemeName);
    });

    test('should handle file path with spaces', async () => {
      const server = new XcodeMCPServer();
      const filePath = '/Users/test/My Project/Source File.swift';
      const lineNumber = 42;
      
      const resultPromise = server.openFile(filePath, lineNumber);
      
      setTimeout(() => {
        mockProcess.stdout.emit('data', 'File opened successfully\n');
        mockProcess.emit('close', 0);
      }, 10);
      
      const result = await resultPromise;
      
      expect(spawn).toHaveBeenCalled();
      const spawnArgs = spawn.mock.calls[0][2];
      expect(spawnArgs[0]).toContain(filePath);
      expect(spawnArgs[0]).toContain(lineNumber.toString());
    });
  });

  describe('Script generation validation', () => {
    test('should generate valid JavaScript syntax', async () => {
      const server = new XcodeMCPServer();
      
      // Test multiple methods to ensure they generate valid JS
      const methods = [
        () => server.build(),
        () => server.clean(),
        () => server.stop(),
        () => server.getSchemes(),
        () => server.getRunDestinations(),
        () => server.getWorkspaceInfo(),
        () => server.getProjects()
      ];
      
      for (const method of methods) {
        const resultPromise = method();
        
        setTimeout(() => {
          mockProcess.stdout.emit('data', 'Success\n');
          mockProcess.emit('close', 0);
        }, 10);
        
        await resultPromise;
        
        // Verify that osascript was called with JavaScript flag
        expect(mockSpawn).toHaveBeenCalledWith('osascript', expect.arrayContaining(['-l', 'JavaScript']));
        
        // Reset mock for next iteration
        mockSpawn.mockClear();
        mockProcess = new EventEmitter();
        mockProcess.stdout = new EventEmitter();
        mockProcess.stderr = new EventEmitter();
        spawn.mockReturnValue(mockProcess);
      }
    });
  });
});
</file>

<file path="src/utils/PathValidator.ts">
import { existsSync } from 'fs';
import path from 'path';
import { ErrorHelper } from './ErrorHelper.js';
import type { McpResult } from '../types/index.js';

export class PathValidator {
  public static validateProjectPath(projectPath: string, parameterName: string = 'xcodeproj'): McpResult | null {
    if (!projectPath) {
      const guidance = [
        `• Specify the absolute path to your .xcodeproj or .xcworkspace file using the "${parameterName}" parameter`,
        "• Example: /Users/username/MyApp/MyApp.xcodeproj",
        "• You can drag the project file from Finder to get the path"
      ].join('\n');
      return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Missing required parameter: ${parameterName}`, guidance) }] };
    }
    
    if (!path.isAbsolute(projectPath)) {
      const guidance = [
        "• Use an absolute path starting with /",
        "• Example: /Users/username/MyApp/MyApp.xcodeproj",
        "• Avoid relative paths like ./MyApp.xcodeproj"
      ].join('\n');
      return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Project path must be absolute, got: ${projectPath}`, guidance) }] };
    }
    
    if (!existsSync(projectPath)) {
      return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Project file does not exist: ${projectPath}`, ErrorHelper.getProjectNotFoundGuidance(projectPath)) }] };
    }
    
    if (projectPath.endsWith('.xcodeproj')) {
      const pbxprojPath = path.join(projectPath, 'project.pbxproj');
      if (!existsSync(pbxprojPath)) {
        const guidance = [
          "• The project file appears to be corrupted or incomplete",
          "• Try recreating the project in Xcode",
          "• Check if you have the correct permissions to access the file",
          "• Make sure the project wasn't partially copied"
        ].join('\n');
        return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Project is missing project.pbxproj file: ${pbxprojPath}`, guidance) }] };
      }
    }
    
    if (projectPath.endsWith('.xcworkspace')) {
      const workspaceDataPath = path.join(projectPath, 'contents.xcworkspacedata');
      if (!existsSync(workspaceDataPath)) {
        const guidance = [
          "• The workspace file appears to be corrupted or incomplete",
          "• Try recreating the workspace in Xcode",
          "• Check if you have the correct permissions to access the file",
          "• Make sure the workspace wasn't partially copied"
        ].join('\n');
        return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Workspace is missing contents.xcworkspacedata file: ${workspaceDataPath}`, guidance) }] };
      }
    }

    return null;
  }

  public static validateFilePath(filePath: string): McpResult | null {
    if (!path.isAbsolute(filePath)) {
      const guidance = [
        "• Use an absolute path starting with /",
        "• Example: /Users/username/MyApp/ViewController.swift",
        "• You can drag the file from Xcode navigator to get the path"
      ].join('\n');
      return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`File path must be absolute, got: ${filePath}`, guidance) }] };
    }
    
    if (!existsSync(filePath)) {
      const guidance = [
        `• Check that the file path is correct: ${filePath}`,
        "• Make sure the file hasn't been moved or deleted",
        "• Verify you have permission to access the file",
        "• Try refreshing the project navigator in Xcode"
      ].join('\n');
      return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`File does not exist: ${filePath}`, guidance) }] };
    }

    return null;
  }
}
</file>

<file path=".gitignore">
node_modules/
CLAUDE.md
coverage/
dist/
</file>

<file path="vitest.config.js">
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    testTimeout: 10000,
    setupFiles: ['./test-setup.js'],
    include: ['__tests__/**/*.vitest.test.{js,ts}'],
    exclude: ['node_modules', 'dist'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        '__tests__/',
        'test-setup.js',
        'vitest.config.js',
        'dist/'
      ]
    }
  },
  esbuild: {
    target: 'es2022'
  }
});
</file>

<file path="src/utils/JXAExecutor.ts">
import { spawn, ChildProcess } from 'child_process';

export class JXAExecutor {
  /**
   * Execute a JavaScript for Automation (JXA) script
   * @param script - The JXA script to execute
   * @param timeoutMs - Timeout in milliseconds (default: 30 seconds)
   * @returns Promise that resolves with the script output or rejects with an error
   */
  public static async execute(script: string, timeoutMs: number = 30000): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      try {
        const osascript: ChildProcess = spawn('osascript', ['-l', 'JavaScript', '-e', script]);
        let stdout = '';
        let stderr = '';

        // Add cleanup handlers to prevent process leaks
        const cleanup = () => {
          if (osascript && !osascript.killed) {
            try {
              osascript.kill('SIGTERM');
            } catch (killError) {
              // Ignore kill errors
            }
          }
        };

        // Set a timeout to prevent hanging
        const timeout = setTimeout(() => {
          cleanup();
          reject(new Error(`JXA execution timed out after ${timeoutMs / 1000} seconds`));
        }, timeoutMs);

        osascript.stdout?.on('data', (data: Buffer) => {
          stdout += data.toString();
        });

        osascript.stderr?.on('data', (data: Buffer) => {
          stderr += data.toString();
        });

        osascript.on('close', (code: number | null) => {
          clearTimeout(timeout);
          try {
            if (code !== 0) {
              reject(new Error(`JXA execution failed: ${stderr}`));
            } else {
              resolve(stdout.trim());
            }
          } catch (handlerError) {
            // Prevent any handler errors from crashing
            reject(new Error(`JXA handler error: ${handlerError}`));
          }
        });

        osascript.on('error', (error: Error) => {
          clearTimeout(timeout);
          cleanup();
          reject(new Error(`Failed to spawn osascript: ${error.message}`));
        });

      } catch (spawnError) {
        reject(new Error(`Failed to create JXA process: ${spawnError}`));
      }
    });
  }
}
</file>

<file path="src/tools/ProjectTools.ts">
import { JXAExecutor } from '../utils/JXAExecutor.js';
import { PathValidator } from '../utils/PathValidator.js';
import { ParameterNormalizer } from '../utils/ParameterNormalizer.js';
import { ErrorHelper } from '../utils/ErrorHelper.js';
import type { McpResult, OpenProjectCallback } from '../types/index.js';

export class ProjectTools {
  public static async ensureXcodeIsRunning(): Promise<McpResult | null> {
    // First check if Xcode is already running
    const checkScript = `
      (function() {
        try {
          const app = Application('Xcode');
          if (app.running()) {
            return 'Xcode is already running';
          } else {
            return 'Xcode is not running';
          }
        } catch (error) {
          return 'Xcode is not running: ' + error.message;
        }
      })()
    `;
    
    try {
      const checkResult = await JXAExecutor.execute(checkScript);
      if (checkResult.includes('already running')) {
        return null; // All good, Xcode is running
      }
    } catch (error) {
      // Continue to launch Xcode
    }
    
    // Get the Xcode path from xcode-select
    let xcodePath: string;
    try {
      const { spawn } = await import('child_process');
      const xcodeSelectResult = await new Promise<string>((resolve, reject) => {
        const process = spawn('xcode-select', ['-p']);
        let stdout = '';
        let stderr = '';
        
        process.stdout.on('data', (data) => {
          stdout += data.toString();
        });
        
        process.stderr.on('data', (data) => {
          stderr += data.toString();
        });
        
        process.on('close', (code) => {
          if (code === 0) {
            resolve(stdout.trim());
          } else {
            reject(new Error(`xcode-select failed with code ${code}: ${stderr}`));
          }
        });
      });
      
      if (!xcodeSelectResult || xcodeSelectResult.trim() === '') {
        return {
          content: [{
            type: 'text',
            text: '❌ No Xcode installation found\n\n💡 To fix this:\n• Install Xcode from the Mac App Store\n• Run: sudo xcode-select -s /Applications/Xcode.app/Contents/Developer'
          }]
        };
      }
      
      // Convert from Developer path to app path
      xcodePath = xcodeSelectResult.replace('/Contents/Developer', '');
      
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `❌ Failed to determine Xcode path: ${error instanceof Error ? error.message : String(error)}\n\n💡 Ensure Xcode is properly installed and xcode-select is configured`
        }]
      };
    }
    
    // Launch Xcode
    const launchScript = `
      (function() {
        try {
          const app = Application(${JSON.stringify(xcodePath)});
          app.launch();
          
          // Wait for Xcode to start
          let attempts = 0;
          while (!app.running() && attempts < 30) {
            delay(1);
            attempts++;
          }
          
          if (app.running()) {
            return 'Xcode launched successfully from ' + ${JSON.stringify(xcodePath)};
          } else {
            return 'Failed to launch Xcode - timed out after 30 seconds';
          }
        } catch (error) {
          return 'Failed to launch Xcode: ' + error.message;
        }
      })()
    `;
    
    try {
      const launchResult = await JXAExecutor.execute(launchScript);
      if (launchResult.includes('launched successfully')) {
        return null; // Success
      } else {
        return {
          content: [{
            type: 'text',
            text: `❌ ${launchResult}\n\n💡 Try:\n• Manually launching Xcode once\n• Checking Xcode installation\n• Ensuring sufficient system resources`
          }]
        };
      }
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: `❌ Failed to launch Xcode: ${error instanceof Error ? error.message : String(error)}`
        }]
      };
    }
  }

  public static async openProject(projectPath: string): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;
    
    // Ensure Xcode is running before trying to open project
    const xcodeError = await this.ensureXcodeIsRunning();
    if (xcodeError) return xcodeError;
    
    const script = `
      const app = Application('Xcode');
      app.open(${JSON.stringify(projectPath)});
      'Project opened successfully';
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }

  public static async waitForProjectToLoad(maxRetries: number = 30, retryDelayMs: number = 1000): Promise<McpResult | null> {
    const checkScript = `
      (function() {
        try {
          const app = Application('Xcode');
          const workspace = app.activeWorkspaceDocument();
          if (!workspace) {
            return JSON.stringify({ loaded: false, reason: 'No active workspace' });
          }
          
          // Try to access schemes - this will fail if project is still loading
          const schemes = workspace.schemes();
          if (schemes.length === 0) {
            return JSON.stringify({ loaded: false, reason: 'Schemes not loaded yet' });
          }
          
          // Try to access destinations - this might also fail during loading
          const destinations = workspace.runDestinations();
          
          return JSON.stringify({ loaded: true, schemes: schemes.length, destinations: destinations.length });
        } catch (error) {
          return JSON.stringify({ loaded: false, reason: error.message });
        }
      })()
    `;

    for (let retry = 0; retry < maxRetries; retry++) {
      try {
        const result = await JXAExecutor.execute(checkScript);
        const status = JSON.parse(result);
        
        if (status.loaded) {
          return null; // Success - project is loaded
        }
        
        if (retry === maxRetries - 1) {
          return {
            content: [{
              type: 'text',
              text: `❌ Project failed to load after ${maxRetries} attempts (${maxRetries * retryDelayMs / 1000}s)\n\nLast status: ${status.reason}\n\n💡 Try:\n• Manually opening the project in Xcode\n• Checking if the project file is corrupted\n• Ensuring sufficient system resources`
            }]
          };
        }
        
        // Wait before next retry
        await new Promise(resolve => setTimeout(resolve, retryDelayMs));
      } catch (error) {
        if (retry === maxRetries - 1) {
          return {
            content: [{
              type: 'text',
              text: `❌ Failed to check project loading status: ${error instanceof Error ? error.message : String(error)}`
            }]
          };
        }
        await new Promise(resolve => setTimeout(resolve, retryDelayMs));
      }
    }
    
    return null; // This shouldn't be reached
  }

  public static async openProjectAndWaitForLoad(projectPath: string): Promise<McpResult> {
    // First check if project is already open and loaded
    try {
      const checkScript = `
        (function() {
          try {
            const app = Application('Xcode');
            const workspace = app.activeWorkspaceDocument();
            if (!workspace) {
              return JSON.stringify({ isOpen: false });
            }
            
            // Check if it's the right project
            const workspacePath = workspace.path();
            if (workspacePath === ${JSON.stringify(projectPath)}) {
              // Try to access schemes to see if it's fully loaded
              const schemes = workspace.schemes();
              return JSON.stringify({ isOpen: true, isLoaded: schemes.length > 0 });
            }
            
            return JSON.stringify({ isOpen: false, differentProject: workspacePath });
          } catch (error) {
            return JSON.stringify({ isOpen: false, error: error.message });
          }
        })()
      `;
      
      const result = await JXAExecutor.execute(checkScript);
      const status = JSON.parse(result);
      
      if (status.isOpen && status.isLoaded) {
        return { content: [{ type: 'text', text: 'Project is already open and loaded' }] };
      }
    } catch (error) {
      // Continue with opening the project
    }

    // Open the project
    const openResult = await this.openProject(projectPath);
    if (openResult.content?.[0]?.type === 'text' && openResult.content[0].text.includes('Error')) {
      return openResult;
    }

    // Wait for the project to load
    const waitResult = await this.waitForProjectToLoad();
    if (waitResult) {
      return waitResult;
    }

    return { content: [{ type: 'text', text: 'Project opened and loaded successfully' }] };
  }

  public static async closeProject(): Promise<McpResult> {
    // Simplified close project to prevent crashes - just close without complex error handling
    const closeScript = `
      (function() {
        try {
          const app = Application('Xcode');
          const workspace = app.activeWorkspaceDocument();
          if (!workspace) {
            return 'No workspace to close (already closed)';
          }
          
          // Simple close without saving
          workspace.close({ saving: false });
          return 'Project close initiated';
        } catch (error) {
          return 'Close completed (may have had dialogs): ' + error.message;
        }
      })()
    `;
    
    try {
      const result = await JXAExecutor.execute(closeScript);
      return { content: [{ type: 'text', text: result }] };
    } catch (error) {
      // Even if JXA fails, consider it successful to prevent crashes
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { content: [{ type: 'text', text: `Project close completed with issues: ${errorMessage}` }] };
    }
  }

  public static async getSchemes(projectPath: string, openProject: OpenProjectCallback): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const schemes = workspace.schemes();
        const activeScheme = workspace.activeScheme();
        
        const schemeInfo = schemes.map(scheme => ({
          name: scheme.name(),
          id: scheme.id(),
          isActive: activeScheme && scheme.id() === activeScheme.id()
        }));
        
        return JSON.stringify(schemeInfo, null, 2);
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }

  public static async setActiveScheme(
    projectPath: string, 
    schemeName: string, 
    openProject: OpenProjectCallback
  ): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    // Normalize the scheme name for better matching
    const normalizedSchemeName = ParameterNormalizer.normalizeSchemeName(schemeName);

    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const schemes = workspace.schemes();
        const schemeNames = schemes.map(scheme => scheme.name());
        
        // Try exact match first
        let targetScheme = schemes.find(scheme => scheme.name() === ${JSON.stringify(normalizedSchemeName)});
        
        // If not found, try original name
        if (!targetScheme) {
          targetScheme = schemes.find(scheme => scheme.name() === ${JSON.stringify(schemeName)});
        }
        
        if (!targetScheme) {
          throw new Error('Scheme not found. Available: ' + JSON.stringify(schemeNames));
        }
        
        workspace.activeScheme = targetScheme;
        return 'Active scheme set to: ' + targetScheme.name();
      })()
    `;
    
    try {
      const result = await JXAExecutor.execute(script);
      return { content: [{ type: 'text', text: result }] };
    } catch (error) {
      const enhancedError = ErrorHelper.parseCommonErrors(error as Error);
      if (enhancedError) {
        return { content: [{ type: 'text', text: enhancedError }] };
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('not found')) {
        try {
          // Extract available schemes from error message if present
          let availableSchemes: string[] = [];
          if (errorMessage.includes('Available:')) {
            const availablePart = errorMessage.split('Available: ')[1];
            // Find the JSON array part
            const jsonMatch = availablePart?.match(/\[.*?\]/);
            if (jsonMatch) {
              availableSchemes = JSON.parse(jsonMatch[0]);
            }
          }
            
          // Try to find a close match with fuzzy matching
          const bestMatch = ParameterNormalizer.findBestMatch(schemeName, availableSchemes);
          let guidance = ErrorHelper.getSchemeNotFoundGuidance(schemeName, availableSchemes);
          
          if (bestMatch && bestMatch !== schemeName) {
            guidance += `\n• Did you mean '${bestMatch}'?`;
          }
          
          return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Scheme '${schemeName}' not found`, guidance) }] };
        } catch {
          return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Scheme '${schemeName}' not found`, ErrorHelper.getSchemeNotFoundGuidance(schemeName)) }] };
        }
      }
      
      return { content: [{ type: 'text', text: `Failed to set active scheme: ${errorMessage}` }] };
    }
  }

  public static async getRunDestinations(projectPath: string, openProject: OpenProjectCallback): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const destinations = workspace.runDestinations();
        const activeDestination = workspace.activeRunDestination();
        
        const destInfo = destinations.map(dest => ({
          name: dest.name(),
          platform: dest.platform(),
          architecture: dest.architecture(),
          isActive: activeDestination && dest.name() === activeDestination.name()
        }));
        
        return JSON.stringify(destInfo, null, 2);
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }
}
</file>

<file path="src/utils/EnvironmentValidator.ts">
import { spawn, ChildProcess } from 'child_process';
import { existsSync, readFileSync } from 'fs';
import { platform } from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import type { EnvironmentValidation, EnvironmentValidationResult } from '../types/index.js';

export class EnvironmentValidator {
  private static validationResults: EnvironmentValidation = {
    overall: { valid: false, canOperateInDegradedMode: false, criticalFailures: [], nonCriticalFailures: [] }
  };

  /**
   * Validates the entire environment and returns detailed results
   */
  public static async validateEnvironment(): Promise<EnvironmentValidation> {
    const results: EnvironmentValidation = {
      os: await this.validateOS(),
      xcode: await this.validateXcode(),
      xclogparser: await this.validateXCLogParser(),
      osascript: await this.validateOSAScript(),
      permissions: await this.validatePermissions(),
      overall: { valid: false, canOperateInDegradedMode: false, criticalFailures: [], nonCriticalFailures: [] }
    };

    // Determine overall validity and degraded mode capability
    const criticalFailures = ['os', 'osascript'].filter(key => !results[key]?.valid);
    const nonCriticalFailures = ['xcode', 'xclogparser', 'permissions'].filter(key => !results[key]?.valid);

    results.overall = {
      valid: criticalFailures.length === 0 && nonCriticalFailures.length === 0,
      canOperateInDegradedMode: criticalFailures.length === 0,
      criticalFailures,
      nonCriticalFailures
    };

    this.validationResults = results;
    return results;
  }

  /**
   * Validates macOS environment
   */
  private static async validateOS(): Promise<EnvironmentValidationResult> {
    if (platform() !== 'darwin') {
      return {
        valid: false,
        message: 'XcodeMCP requires macOS to operate',
        recoveryInstructions: [
          'This MCP server only works on macOS',
          'Xcode and its automation features are macOS-exclusive',
          'Consider using this server on a Mac or macOS virtual machine'
        ]
      };
    }

    return {
      valid: true,
      message: 'macOS environment detected',
      recoveryInstructions: []
    };
  }

  /**
   * Validates Xcode installation
   */
  private static async validateXcode(): Promise<EnvironmentValidationResult> {
    const possibleXcodePaths = [
      '/Applications/Xcode.app',
      '/Applications/Xcode-beta.app'
    ];
    
    // Also check for versioned Xcode installations
    try {
      const { readdirSync } = await import('fs');
      const appDir = readdirSync('/Applications');
      const versionedXcodes = appDir
        .filter(name => name.startsWith('Xcode-') && name.endsWith('.app'))
        .map(name => `/Applications/${name}`);
      possibleXcodePaths.push(...versionedXcodes);
    } catch (error) {
      // Ignore errors when scanning for versioned Xcodes
    }

    let xcodeFound = false;
    let xcodePath: string | null = null;

    for (const path of possibleXcodePaths) {
      if (existsSync(path)) {
        xcodeFound = true;
        xcodePath = path;
        break;
      }
    }

    if (!xcodeFound) {
      return {
        valid: false,
        message: 'Xcode not found in /Applications',
        recoveryInstructions: [
          'Download and install Xcode from the Mac App Store',
          'Ensure Xcode is installed in /Applications/Xcode.app',
          'Launch Xcode once to complete installation and accept license',
          'If using Xcode beta, ensure it is in /Applications/Xcode-beta.app'
        ]
      };
    }

    // Check if Xcode can be launched and get version
    try {
      const version = await this.getXcodeVersion(xcodePath!);
      
      return {
        valid: true,
        message: `Xcode found at ${xcodePath} (version ${version})`,
        recoveryInstructions: []
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        valid: false,
        message: `Xcode found but appears to be corrupted or not properly installed: ${errorMessage}`,
        recoveryInstructions: [
          'Try launching Xcode manually to complete setup',
          'Accept the license agreement if prompted',
          'Install additional components if requested',
          'Restart Xcode if it hangs on first launch',
          'Consider reinstalling Xcode if problems persist'
        ]
      };
    }
  }

  /**
   * Validates XCLogParser installation
   */
  private static async validateXCLogParser(): Promise<EnvironmentValidationResult> {
    try {
      // First check if xclogparser exists in PATH
      const whichResult = await this.executeCommand('which', ['xclogparser']);
      const xclogparserPath = whichResult.trim();
      
      // Try to get version using the 'version' subcommand
      let version: string;
      try {
        version = await this.executeCommand('xclogparser', ['version']);
      } catch (versionError) {
        // Some versions might use different command structure, try help as fallback
        try {
          await this.executeCommand('xclogparser', ['--help']);
          // If we get help output, xclogparser is working but version command might be different
          version = 'Unknown version (tool is working)';
        } catch (helpError) {
          throw new Error(`xclogparser found at ${xclogparserPath} but cannot execute: ${(versionError as Error).message}`);
        }
      }
      
      return {
        valid: true,
        message: `XCLogParser found (${version.trim()})`,
        recoveryInstructions: [],
        metadata: { 
          version: version.trim(),
          path: xclogparserPath
        }
      };
    } catch (error) {
      // Add more detailed error information for debugging
      const errorDetails: string[] = [];
      let xclogparserLocation: string | null = null;
      
      // Check if it's a PATH issue
      try {
        const whichResult = await this.executeCommand('which', ['xclogparser']);
        xclogparserLocation = whichResult.trim();
        errorDetails.push(`xclogparser found at ${xclogparserLocation} but failed to execute`);
        errorDetails.push(`Error: ${(error as Error).message}`);
        
        // Check if it's a permission issue
        try {
          await this.executeCommand('test', ['-x', xclogparserLocation]);
        } catch (permError) {
          errorDetails.push(`Permission issue: ${xclogparserLocation} is not executable`);
          errorDetails.push('Try: chmod +x ' + xclogparserLocation);
        }
      } catch (whichError) {
        errorDetails.push('xclogparser not found in PATH');
        errorDetails.push(`Current PATH: ${process.env.PATH}`);
        
        // Check common installation locations
        const commonPaths = [
          '/usr/local/bin/xclogparser',
          '/opt/homebrew/bin/xclogparser',
          '/usr/bin/xclogparser',
          '/opt/local/bin/xclogparser' // MacPorts
        ];
        
        for (const checkPath of commonPaths) {
          try {
            await this.executeCommand('test', ['-f', checkPath]);
            xclogparserLocation = checkPath;
            errorDetails.push(`Found at ${checkPath} but not in PATH`);
            
            // Check if it's executable
            try {
              await this.executeCommand('test', ['-x', checkPath]);
              errorDetails.push('Add to PATH: export PATH="$PATH:' + path.dirname(checkPath) + '"');
            } catch (execError) {
              errorDetails.push(`File exists but not executable: chmod +x ${checkPath}`);
            }
            break;
          } catch (testError) {
            // File doesn't exist at this path
          }
        }
        
        if (!xclogparserLocation) {
          // Check if Homebrew is installed and where it would put xclogparser
          try {
            const brewPrefix = await this.executeCommand('brew', ['--prefix']);
            const brewPath = path.join(brewPrefix.trim(), 'bin/xclogparser');
            errorDetails.push(`Homebrew detected at: ${brewPrefix.trim()}`);
            errorDetails.push(`Expected xclogparser location: ${brewPath}`);
          } catch (brewError) {
            // Homebrew not found or not working
          }
        }
      }
      
      return {
        valid: false,
        message: 'XCLogParser not found or not executable',
        recoveryInstructions: [
          'Install XCLogParser using Homebrew: brew install xclogparser',
          'Or download from GitHub: https://github.com/MobileNativeFoundation/XCLogParser',
          'Ensure xclogparser is in your PATH',
          'Note: Build log parsing will be unavailable without XCLogParser',
          '',
          'Debugging information:',
          ...errorDetails.map(detail => `  • ${detail}`)
        ],
        degradedMode: {
          available: true,
          limitations: ['Build logs cannot be parsed', 'Error details from builds will be limited']
        }
      };
    }
  }

  /**
   * Validates osascript availability
   */
  private static async validateOSAScript(): Promise<EnvironmentValidationResult> {
    try {
      const version = await this.executeCommand('osascript', ['-l', 'JavaScript', '-e', '"test"']);
      if (version.trim() === 'test') {
        return {
          valid: true,
          message: 'JavaScript for Automation (JXA) is available',
          recoveryInstructions: []
        };
      } else {
        throw new Error('Unexpected output from osascript');
      }
    } catch (error) {
      return {
        valid: false,
        message: 'JavaScript for Automation (JXA) not available',
        recoveryInstructions: [
          'Ensure you are running on macOS (osascript is a macOS system tool)',
          'Check if JavaScript for Automation is enabled in System Preferences',
          'Try running "osascript -l JavaScript -e \\"return \'test\'\\"" manually',
          'This is a critical component - the server cannot function without it'
        ]
      };
    }
  }

  /**
   * Get the actual Xcode application path
   */
  private static async getXcodePath(): Promise<string> {
    try {
      // First try to get from xcode-select
      const developerDir = await this.executeCommand('xcode-select', ['-p']);
      const xcodeAppPath = developerDir.trim().replace('/Contents/Developer', '');
      
      // Verify this Xcode app exists
      await this.executeCommand('test', ['-d', xcodeAppPath]);
      return xcodeAppPath;
    } catch {
      // Fall back to searching /Applications for any Xcode app
      try {
        const result = await this.executeCommand('find', ['/Applications', '-name', 'Xcode*.app', '-type', 'd', '-maxdepth', '1']);
        const xcodePaths = result.trim().split('\n').filter(path => path.length > 0);
        
        if (xcodePaths.length > 0 && xcodePaths[0]) {
          // Return the first Xcode found
          return xcodePaths[0];
        }
      } catch {
        // Last resort - try the standard path
        return '/Applications/Xcode.app';
      }
    }
    
    return '/Applications/Xcode.app';
  }

  /**
   * Validates automation permissions
   */
  private static async validatePermissions(): Promise<EnvironmentValidationResult> {
    try {
      // Get the actual Xcode path first
      const xcodePath = await this.getXcodePath();
      
      // Try a simple Xcode automation command to test permissions using the actual path
      const result = await this.executeCommand('osascript', [
        '-l', 'JavaScript', '-e',
        `Application("${xcodePath}").version()`
      ]);
      
      if (result && result.trim()) {
        return {
          valid: true,
          message: 'Xcode automation permissions are working',
          recoveryInstructions: []
        };
      } else {
        throw new Error('No version returned from Xcode');
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message.toLowerCase() : String(error).toLowerCase();
      
      if (errorMessage.includes('not allowed assistive access') || 
          errorMessage.includes('not authorized') ||
          errorMessage.includes('permission')) {
        return {
          valid: false,
          message: 'Automation permissions not granted',
          recoveryInstructions: [
            'Open System Preferences → Privacy & Security → Automation',
            'Find your terminal application (Terminal, iTerm, VS Code, etc.)',
            'Enable permission to control "Xcode"',
            'You may need to restart your terminal after granting permission',
            'If using VS Code, look for "Code" in the automation list'
          ]
        };
      } else if (errorMessage.includes("application isn't running")) {
        return {
          valid: false,
          message: 'Cannot test permissions - Xcode not running',
          recoveryInstructions: [
            'Launch Xcode to test automation permissions',
            'Permissions will be validated when Xcode operations are attempted',
            'This is not critical for server startup'
          ],
          degradedMode: {
            available: true,
            limitations: ['Permission validation deferred until Xcode operations']
          }
        };
      } else {
        const errorMsg = error instanceof Error ? error.message : String(error);
        return {
          valid: false,
          message: `Permission check failed: ${errorMsg}`,
          recoveryInstructions: [
            'Ensure Xcode is properly installed',
            'Try launching Xcode manually first',
            'Check System Preferences → Privacy & Security → Automation',
            'Grant permission for your terminal to control Xcode'
          ]
        };
      }
    }
  }

  /**
   * Gets Xcode version
   */
  private static async getXcodeVersion(xcodePath: string): Promise<string> {
    const infoPlistPath = path.join(xcodePath, 'Contents/Info.plist');
    
    if (!existsSync(infoPlistPath)) {
      throw new Error('Info.plist not found');
    }

    try {
      const result = await this.executeCommand('defaults', [
        'read', infoPlistPath, 'CFBundleShortVersionString'
      ]);
      return result.trim();
    } catch (error) {
      // Fallback to plutil if defaults doesn't work
      try {
        const result = await this.executeCommand('plutil', [
          '-extract', 'CFBundleShortVersionString', 'raw', infoPlistPath
        ]);
        return result.trim();
      } catch (fallbackError) {
        const fallbackErrorMessage = fallbackError instanceof Error ? fallbackError.message : String(fallbackError);
        throw new Error(`Cannot read Xcode version: ${fallbackErrorMessage}`);
      }
    }
  }

  /**
   * Executes a command and returns stdout
   */
  private static async executeCommand(command: string, args: string[] = [], timeout = 5000): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const process: ChildProcess = spawn(command, args);
      let stdout = '';
      let stderr = '';

      const timer = setTimeout(() => {
        process.kill();
        reject(new Error(`Command timed out: ${command} ${args.join(' ')}`));
      }, timeout);

      process.stdout?.on('data', (data: Buffer) => {
        stdout += data.toString();
      });

      process.stderr?.on('data', (data: Buffer) => {
        stderr += data.toString();
      });

      process.on('close', (code: number | null) => {
        clearTimeout(timer);
        if (code === 0) {
          resolve(stdout);
        } else {
          reject(new Error(`Command failed with exit code ${code}: ${stderr || 'No error details'}`));
        }
      });

      process.on('error', (error: Error) => {
        clearTimeout(timer);
        reject(new Error(`Failed to start command: ${error.message}`));
      });
    });
  }

  /**
   * Generates a human-readable validation summary
   */
  private static generateValidationSummary(results: EnvironmentValidation): string {
    const summary = ['XcodeMCP Environment Validation Report', ''];
    
    // Overall status
    if (results.overall.valid) {
      summary.push('✅ All systems operational');
    } else if (results.overall.canOperateInDegradedMode) {
      summary.push('⚠️  Can operate with limitations');
    } else {
      summary.push('❌ Critical failures detected - server cannot operate');
    }
    
    summary.push('');

    // Component status
    Object.entries(results).forEach(([component, result]) => {
      if (component === 'overall' || !result) return;
      
      // Type guard to check if this is an EnvironmentValidationResult
      if ('valid' in result) {
        const validationResult = result as EnvironmentValidationResult;
        const status = validationResult.valid ? '✅' : '❌';
        summary.push(`${status} ${component.toUpperCase()}: ${validationResult.message || 'Status unknown'}`);
        
        if (!validationResult.valid && validationResult.recoveryInstructions && validationResult.recoveryInstructions.length > 0) {
          summary.push('   Recovery instructions:');
          validationResult.recoveryInstructions.forEach((instruction: string) => {
            summary.push(`   • ${instruction}`);
          });
          summary.push('');
        }
      }
    });

    return summary.join('\n');
  }

  /**
   * Checks if the environment can operate in degraded mode
   */
  public static canOperateInDegradedMode(results: EnvironmentValidation | null = null): boolean {
    const validationResults = results || this.validationResults;
    return validationResults.overall?.canOperateInDegradedMode ?? false;
  }

  /**
   * Gets the list of features unavailable in current environment
   */
  public static getUnavailableFeatures(results: EnvironmentValidation | null = null): string[] {
    const validationResults = results || this.validationResults;
    const unavailable: string[] = [];

    if (!validationResults.xclogparser?.valid) {
      unavailable.push('Build log parsing and detailed error reporting');
    }

    if (!validationResults.xcode?.valid) {
      unavailable.push('All Xcode operations (build, test, run, debug)');
    }

    if (!validationResults.permissions?.valid) {
      unavailable.push('Xcode automation (may work after granting permissions)');
    }

    return unavailable;
  }

  /**
   * Gets the version from package.json
   */
  private static getVersion(): string {
    try {
      const __filename = fileURLToPath(import.meta.url);
      const __dirname = path.dirname(__filename);
      const packageJsonPath = path.join(__dirname, '../../package.json');
      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
      return packageJson.version || 'unknown';
    } catch (error) {
      return 'unknown';
    }
  }

  /**
   * Creates a configuration health check report
   */
  public static async createHealthCheckReport(): Promise<string> {
    const results = await this.validateEnvironment();
    const version = this.getVersion();
    const report = [
      `XcodeMCP Configuration Health Check (v${version})`,
      '='.repeat(50),
      '',
      this.generateValidationSummary(results),
      ''
    ];

    if (!results.overall.valid) {
      report.push('IMMEDIATE ACTIONS REQUIRED:');
      
      results.overall.criticalFailures.forEach(component => {
        const result = results[component];
        if (result && 'valid' in result) {
          const validationResult = result as EnvironmentValidationResult;
          report.push(`\n${component.toUpperCase()} FAILURE:`);
          validationResult.recoveryInstructions?.forEach((instruction: string) => {
            report.push(`• ${instruction}`);
          });
        }
      });

      if (results.overall.nonCriticalFailures.length > 0) {
        report.push('\nOPTIONAL IMPROVEMENTS:');
        results.overall.nonCriticalFailures.forEach(component => {
          const result = results[component];
          if (result && 'valid' in result) {
            const validationResult = result as EnvironmentValidationResult;
            report.push(`\n${component.toUpperCase()}:`);
            validationResult.recoveryInstructions?.forEach((instruction: string) => {
              report.push(`• ${instruction}`);
            });
          }
        });
      }
    }

    const unavailableFeatures = this.getUnavailableFeatures(results);
    if (unavailableFeatures.length > 0) {
      report.push('\nLIMITED FUNCTIONALITY:');
      unavailableFeatures.forEach(feature => {
        report.push(`• ${feature}`);
      });
    }

    return report.join('\n');
  }
}
</file>

<file path="src/types/index.ts">
// Type definitions for XcodeMCP
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';

export interface McpContent {
  type: 'text' | 'image' | 'resource';
  text?: string;
  data?: string;
  mimeType?: string;
}

export type McpResult = CallToolResult;

export interface BuildLogInfo {
  path: string;
  mtime: Date;
}

export interface ParsedBuildResults {
  errors: string[];
  warnings: string[];
  buildStatus?: string;
}

export interface EnvironmentValidationResult {
  valid: boolean;
  message?: string;
  recoveryInstructions?: string[];
  degradedMode?: {
    available: boolean;
    limitations?: string[];
  };
  metadata?: Record<string, any>;
}

export interface OverallValidationResult {
  valid: boolean;
  canOperateInDegradedMode: boolean;
  criticalFailures: string[];
  nonCriticalFailures: string[];
}

export interface EnvironmentValidation {
  overall: OverallValidationResult;
  xcode?: EnvironmentValidationResult;
  osascript?: EnvironmentValidationResult;
  xclogparser?: EnvironmentValidationResult;
  permissions?: EnvironmentValidationResult;
  [key: string]: EnvironmentValidationResult | OverallValidationResult | undefined;
}

export interface ToolLimitations {
  blocked: boolean;
  degraded: boolean;
  reason?: string;
  instructions?: string[];
}

export interface JXAScheme {
  name(): string;
}

export interface JXADestination {
  name(): string;
}

export interface JXAWorkspace {
  schemes(): JXAScheme[];
  runDestinations(): JXADestination[];
  activeScheme: JXAScheme;
  activeRunDestination: JXADestination;
  build(): void;
  clean(): JXAActionResult;
  test(options?: { withCommandLineArguments?: string[] }): JXAActionResult;
  run(options?: { withCommandLineArguments?: string[] }): JXAActionResult;
  debug(options?: { scheme?: string; skipBuilding?: boolean }): JXAActionResult;
  stop(): void;
}

export interface JXAActionResult {
  id(): string;
  completed(): boolean;
}

export interface JXAApplication {
  activeWorkspaceDocument(): JXAWorkspace | null;
}

export interface OpenProjectCallback {
  (projectPath: string): Promise<McpResult>;
}

export interface CommonErrorPattern {
  pattern: RegExp;
  message: string;
  guidance?: string;
}

export interface NormalizedName {
  original: string;
  normalized: string;
}

// Child process types for JXA execution
export interface SpawnOptions {
  stdio?: string | string[];
  env?: NodeJS.ProcessEnv;
  cwd?: string;
  uid?: number;
  gid?: number;
  shell?: boolean | string;
}

export interface ChildProcessResult {
  stdout: string;
  stderr: string;
  code: number;
}

// XCResult attachment interface - flexible to handle variations in xcresulttool output
export interface TestAttachment {
  payloadId?: string;
  payload_uuid?: string;
  payloadUUID?: string;
  uniform_type_identifier?: string;
  uniformTypeIdentifier?: string;
  filename?: string;
  name?: string;
  payloadSize?: number;
  payload_size?: number;
  timestamp?: number;
}
</file>

<file path="src/utils/BuildLogParser.ts">
import { spawn, ChildProcess } from 'child_process';
import { readdir, stat, readFile } from 'fs/promises';
import path from 'path';
import os from 'os';
import { Logger } from './Logger.js';
import type { BuildLogInfo, ParsedBuildResults } from '../types/index.js';

interface XCLogParserIssue {
  documentURL?: string;
  startingLineNumber?: number;
  startingColumnNumber?: number;
  title: string;
}

interface XCLogParserResult {
  errors?: XCLogParserIssue[];
  warnings?: XCLogParserIssue[];
  buildStatus?: string;
}

export class BuildLogParser {
  public static async findProjectDerivedData(projectPath: string): Promise<string | null> {
    const customDerivedDataLocation = await this.getCustomDerivedDataLocationFromXcodePreferences();
    
    // Extract the actual project name from .xcodeproj or .xcworkspace files
    let projectName: string;
    let actualProjectPath = projectPath;
    
    // If projectPath points to a .xcodeproj file, get its directory
    if (projectPath.endsWith('.xcodeproj') || projectPath.endsWith('.xcworkspace')) {
      actualProjectPath = path.dirname(projectPath);
      projectName = path.basename(projectPath, path.extname(projectPath));
    } else {
      // projectPath is a directory, find project files inside it
      try {
        const files = await readdir(actualProjectPath);
        const projectFile = files.find(file => file.endsWith('.xcodeproj') || file.endsWith('.xcworkspace'));
        if (projectFile) {
          projectName = path.basename(projectFile, path.extname(projectFile));
        } else {
          // Fallback to directory name if no project files found
          projectName = path.basename(actualProjectPath, path.extname(actualProjectPath));
        }
      } catch {
        // Fallback to directory name if we can't read the directory
        projectName = path.basename(actualProjectPath, path.extname(actualProjectPath));
      }
    }
    
    let derivedDataPath: string;
    
    if (!customDerivedDataLocation) {
      derivedDataPath = path.join(os.homedir(), 'Library/Developer/Xcode/DerivedData');
    } else if (customDerivedDataLocation.startsWith('/')) {
      derivedDataPath = customDerivedDataLocation;
    } else {
      const localProjectPath = path.dirname(projectPath);
      derivedDataPath = path.join(localProjectPath, customDerivedDataLocation);
    }

    try {
      const dirs = await readdir(derivedDataPath);
      const matches = dirs.filter(dir => dir.startsWith(`${projectName}-`));
      
      if (matches.length === 0) return null;
      
      // Find the correct DerivedData folder by verifying WorkspacePath in info.plist
      for (const match of matches) {
        const fullPath = path.join(derivedDataPath, match);
        const infoPlistPath = path.join(fullPath, 'info.plist');
        
        try {
          const plistContent = await readFile(infoPlistPath, 'utf8');
          const workspacePathMatch = plistContent.match(/<key>WorkspacePath<\/key>\s*<string>(.*?)<\/string>/);
          
          if (workspacePathMatch && workspacePathMatch[1]) {
            const workspacePath = workspacePathMatch[1];
            // Resolve both paths to absolute paths for comparison
            const resolvedProjectPath = path.resolve(actualProjectPath);
            const resolvedWorkspacePath = path.resolve(workspacePath);
            
            // Check if paths match exactly, or if workspace path is inside the project directory
            if (resolvedProjectPath === resolvedWorkspacePath || 
                resolvedWorkspacePath.startsWith(resolvedProjectPath + path.sep) ||
                resolvedProjectPath.startsWith(resolvedWorkspacePath + path.sep)) {
              return fullPath;
            }
          }
        } catch (plistError) {
          // Continue to next match if info.plist can't be read
          continue;
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  }
  
  public static async getCustomDerivedDataLocationFromXcodePreferences(): Promise<string | null> {
    return new Promise<string | null>((resolve) => {
      const defaults: ChildProcess = spawn('defaults', ['read', 'com.apple.dt.Xcode', 'IDECustomDerivedDataLocation']);
      let stdout = '';
      let stderr = '';

      defaults.stdout?.on('data', (data: Buffer) => {
        stdout += data.toString();
      });

      defaults.stderr?.on('data', (data: Buffer) => {
        stderr += data.toString();
      });

      defaults.on('close', (code: number | null) => {
        if (code === 0 && stdout.trim()) {
          resolve(stdout.trim());
        } else {
          resolve(null);
        }
      });

      defaults.on('error', () => {
        resolve(null);
      });
    });
  }

  public static async getLatestBuildLog(projectPath: string): Promise<BuildLogInfo | null> {
    const derivedData = await this.findProjectDerivedData(projectPath);
    if (!derivedData) return null;
    
    const logsDir = path.join(derivedData, 'Logs', 'Build');
    
    try {
      const files = await readdir(logsDir);
      const logFiles = files.filter(file => file.endsWith('.xcactivitylog'));
      
      if (logFiles.length === 0) return null;
      
      let latestLog: BuildLogInfo | null = null;
      let latestTime = 0;
      
      for (const logFile of logFiles) {
        const fullPath = path.join(logsDir, logFile);
        const stats = await stat(fullPath);
        if (stats.mtime.getTime() > latestTime) {
          latestTime = stats.mtime.getTime();
          latestLog = { path: fullPath, mtime: stats.mtime };
        }
      }
      
      return latestLog;
    } catch (error) {
      return null;
    }
  }

  public static async getRecentBuildLogs(projectPath: string, sinceTime: number): Promise<BuildLogInfo[]> {
    const derivedData = await this.findProjectDerivedData(projectPath);
    if (!derivedData) return [];
    
    const logsDir = path.join(derivedData, 'Logs', 'Build');
    
    try {
      const files = await readdir(logsDir);
      const logFiles = files.filter(file => file.endsWith('.xcactivitylog'));
      
      if (logFiles.length === 0) return [];
      
      const recentLogs: BuildLogInfo[] = [];
      
      for (const logFile of logFiles) {
        const fullPath = path.join(logsDir, logFile);
        const stats = await stat(fullPath);
        
        // Include logs modified since the test started (with 30 second buffer for clock differences)
        if (stats.mtime.getTime() >= sinceTime - 30000) {
          recentLogs.push({ path: fullPath, mtime: stats.mtime });
        }
      }
      
      // Sort by modification time (newest first)
      recentLogs.sort((a, b) => b.mtime.getTime() - a.mtime.getTime());
      
      return recentLogs;
    } catch (error) {
      return [];
    }
  }

  public static async getLatestTestLog(projectPath: string): Promise<BuildLogInfo | null> {
    const derivedData = await this.findProjectDerivedData(projectPath);
    if (!derivedData) return null;
    
    const logsDir = path.join(derivedData, 'Logs', 'Test');
    
    try {
      const files = await readdir(logsDir);
      const testResultDirs = files.filter(file => file.endsWith('.xcresult'));
      
      if (testResultDirs.length === 0) return null;
      
      let latestLog: BuildLogInfo | null = null;
      let latestTime = 0;
      
      for (const resultDir of testResultDirs) {
        const fullPath = path.join(logsDir, resultDir);
        const stats = await stat(fullPath);
        if (stats.mtime.getTime() > latestTime) {
          latestTime = stats.mtime.getTime();
          latestLog = { path: fullPath, mtime: stats.mtime };
        }
      }
      
      return latestLog;
    } catch (error) {
      return null;
    }
  }

  public static async parseBuildLog(logPath: string, retryCount = 0, maxRetries = 6): Promise<ParsedBuildResults> {
    const delays = [1000, 2000, 3000, 5000, 8000, 13000];
    return new Promise<ParsedBuildResults>((resolve) => {
      const command: ChildProcess = spawn('xclogparser', ['parse', '--file', logPath, '--reporter', 'issues']);
      let stdout = '';
      let stderr = '';
      
      // Ensure child process cleanup on exit
      const cleanup = () => {
        if (command && !command.killed) {
          command.kill('SIGTERM');
        }
      };
      process.once('exit', cleanup);
      process.once('SIGTERM', cleanup);
      process.once('SIGINT', cleanup);
      
      command.stdout?.on('data', (data: Buffer) => {
        stdout += data.toString();
      });
      
      command.stderr?.on('data', (data: Buffer) => {
        stderr += data.toString();
      });
      
      command.on('close', (code: number | null) => {
        // Remove cleanup handlers once process closes
        process.removeListener('exit', cleanup);
        process.removeListener('SIGTERM', cleanup);
        process.removeListener('SIGINT', cleanup);
        if (code !== 0) {
          const errorMessage = stderr.trim() || 'No error details available';
          
          if (errorMessage.includes('not a valid SLF log') || 
              errorMessage.includes('not a valid xcactivitylog file') ||
              errorMessage.includes('corrupted') || 
              errorMessage.includes('incomplete') ||
              errorMessage.includes('Error while parsing') ||
              errorMessage.includes('Failed to parse')) {
            
            if (retryCount < maxRetries) {
              Logger.warn(`XCLogParser failed (attempt ${retryCount + 1}/${maxRetries + 1}): ${errorMessage}`);
              Logger.debug(`Retrying in ${delays[retryCount]}ms...`);
              
              setTimeout(async () => {
                const result = await this.parseBuildLog(logPath, retryCount + 1, maxRetries);
                resolve(result);
              }, delays[retryCount]!);
              return;
            }
            
            Logger.error('xclogparser failed:', stderr);
            resolve({
              errors: [
                'XCLogParser failed to parse the build log.',
                '',
                'This may indicate:',
                '• The log file is corrupted or incomplete',
                '• An unsupported Xcode version was used',
                '• XCLogParser needs to be updated',
                '',
                `Error details: ${errorMessage}`
              ],
              warnings: []
            });
            return;
          }
        }
        
        try {
          const result: XCLogParserResult = JSON.parse(stdout);
          
          const errors = (result.errors || []).map(error => {
            const fileName = error.documentURL ? error.documentURL.replace('file://', '') : 'Unknown file';
            const line = error.startingLineNumber;
            const column = error.startingColumnNumber;
            
            let location = fileName;
            if (line && line > 0) {
              location += `:${line}`;
              if (column && column > 0) {
                location += `:${column}`;
              }
            }
            
            return `${location}: ${error.title}`;
          });
          
          const warnings = (result.warnings || []).map(warning => {
            const fileName = warning.documentURL ? warning.documentURL.replace('file://', '') : 'Unknown file';
            const line = warning.startingLineNumber;
            const column = warning.startingColumnNumber;
            
            let location = fileName;
            if (line && line > 0) {
              location += `:${line}`;
              if (column && column > 0) {
                location += `:${column}`;
              }
            }
            
            return `${location}: ${warning.title}`;
          });
          
          const buildResult: ParsedBuildResults = {
            errors,
            warnings
          };
          if (result.buildStatus) {
            buildResult.buildStatus = result.buildStatus;
          }
          resolve(buildResult);
        } catch (parseError) {
          const errorMessage = parseError instanceof Error ? parseError.message : String(parseError);
          Logger.error('Failed to parse xclogparser output:', parseError);
          resolve({
            errors: [
              'Failed to parse XCLogParser JSON output.',
              '',
              'This may indicate:',
              '• XCLogParser returned unexpected output format',
              '• The build log contains unusual data',
              '• XCLogParser version incompatibility',
              '',
              `Parse error: ${errorMessage}`
            ],
            warnings: []
          });
        }
      });
      
      command.on('error', (err: Error) => {
        Logger.error('Failed to run xclogparser:', err);
        resolve({
          errors: [
            'XCLogParser is required to parse Xcode build logs but is not installed.',
            '',
            'Please install XCLogParser using one of these methods:',
            '• Homebrew: brew install xclogparser',
            '• From source: https://github.com/MobileNativeFoundation/XCLogParser',
            '',
            'XCLogParser is a professional tool for parsing Xcode\'s binary log format.'
          ],
          warnings: []
        });
      });
    });
  }

  public static async canParseLog(logPath: string): Promise<boolean> {
    return new Promise<boolean>((resolve) => {
      const command: ChildProcess = spawn('xclogparser', ['parse', '--file', logPath, '--reporter', 'issues']);
      let hasOutput = false;
      
      command.stdout?.on('data', () => {
        hasOutput = true;
      });
      
      command.on('close', (code: number | null) => {
        resolve(code === 0 && hasOutput);
      });
      
      command.on('error', () => {
        resolve(false);
      });
      
      const timeoutId = setTimeout(() => {
        command.kill();
        resolve(false);
      }, 5000);

      command.on('close', () => {
        clearTimeout(timeoutId);
      });
    });
  }

  public static async parseTestResults(_xcresultPath: string): Promise<ParsedBuildResults> {
    // For now, return a simple result indicating tests completed
    // The xcresult format is complex and the tool API has changed
    return {
      errors: [],
      warnings: [],
    };
  }
}
</file>

<file path="src/index.ts">
#!/usr/bin/env node

import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { createServer } from 'http';
import { XcodeServer } from './XcodeServer.js';
import { Logger } from './utils/Logger.js';
import type { EnvironmentValidation } from './types/index.js';

// Handle uncaught exceptions and unhandled promise rejections 
process.on('uncaughtException', (error) => {
  Logger.error('🚨 UNCAUGHT EXCEPTION - This may indicate a bug that needs fixing:', error);
  Logger.error('Stack trace:', error.stack);
  // Log to stderr as well for visibility
  console.error('🚨 XcodeMCP: Uncaught exception detected:', error.message);
  // Don't exit immediately - log and continue for MCP server stability
});

process.on('unhandledRejection', (reason, promise) => {
  Logger.error('🚨 UNHANDLED PROMISE REJECTION - This may indicate a bug that needs fixing:', reason);
  Logger.error('Promise:', promise);
  // Log to stderr as well for visibility
  console.error('🚨 XcodeMCP: Unhandled promise rejection:', reason);
  // Don't exit - log and continue
});

process.on('SIGTERM', () => {
  Logger.info('Received SIGTERM, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  Logger.info('Received SIGINT, shutting down gracefully');
  process.exit(0);
});

export class XcodeMCPServer extends XcodeServer {
  public async start(port?: number): Promise<void> {
    try {
      // Initialize logging system
      Logger.info('Starting server and validating environment...');
      Logger.debug('Log level set to:', Logger.getLogLevel());
      
      const validation: EnvironmentValidation = await this.validateEnvironment();
      
      if (!validation.overall.valid) {
        if (validation.overall.canOperateInDegradedMode) {
          Logger.warn('Starting in degraded mode due to configuration issues');
          Logger.warn('Some features may be unavailable');
          Logger.info('Run the "xcode_health_check" tool for detailed diagnostics');
        } else {
          Logger.error('Critical configuration issues detected');
          Logger.error('Server may not function properly');
          Logger.error('Please run the "xcode_health_check" tool to resolve issues');
        }
      } else {
        Logger.info('Environment validation passed - all systems operational');
      }

      if (port) {
        // Store active SSE transports by session ID
        const sseTransports = new Map<string, SSEServerTransport>();
        
        // Create HTTP server for SSE transport
        const httpServer = createServer(async (req, res) => {
          const url = new URL(req.url!, `http://localhost:${port}`);
          
          if (req.method === 'GET' && url.pathname === '/sse') {
            // Handle SSE connection
            const transport = new SSEServerTransport('/message', res);
            await this.server.connect(transport);
            
            // Store the transport by session ID
            sseTransports.set(transport.sessionId, transport);
            Logger.info(`SSE connection established with session ID: ${transport.sessionId}`);
            
            // Clean up when connection closes
            transport.onclose = () => {
              sseTransports.delete(transport.sessionId);
              Logger.info(`SSE connection closed for session: ${transport.sessionId}`);
            };
            
          } else if (req.method === 'POST' && url.pathname === '/message') {
            // Handle POST messages - route to the correct transport
            const sessionId = url.searchParams.get('sessionId');
            
            if (!sessionId) {
              res.writeHead(400, { 'Content-Type': 'text/plain' });
              res.end('Missing sessionId parameter');
              return;
            }
            
            const transport = sseTransports.get(sessionId);
            if (!transport) {
              res.writeHead(404, { 'Content-Type': 'text/plain' });
              res.end('Session not found. Please establish SSE connection first.');
              return;
            }
            
            try {
              await transport.handlePostMessage(req, res);
            } catch (error) {
              Logger.error('Error handling POST message:', error);
              if (!res.headersSent) {
                res.writeHead(500, { 'Content-Type': 'text/plain' });
                res.end('Internal server error');
              }
            }
            
          } else if (req.method === 'GET' && url.pathname === '/') {
            // MCP Server Discovery - provide server capabilities and endpoints
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ 
              protocolVersion: '2024-11-05',
              capabilities: {
                tools: {},
                logging: {}
              },
              serverInfo: {
                name: 'xcode-mcp-server',
                version: '1.7.4'
              },
              transport: {
                type: 'sse',
                endpoints: {
                  sse: '/sse',
                  message: '/message'
                }
              },
              status: 'running',
              activeSessions: sseTransports.size
            }));
          } else if (req.method === 'GET' && url.pathname === '/.well-known/mcp') {
            // MCP Discovery endpoint
            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({
              protocolVersion: '2024-11-05',
              serverInfo: {
                name: 'xcode-mcp-server',
                version: '1.7.4'
              },
              capabilities: {
                tools: {},
                logging: {}
              },
              transport: {
                type: 'sse',
                sseEndpoint: '/sse',
                messageEndpoint: '/message'
              }
            }));
          } else {
            res.writeHead(404, { 'Content-Type': 'text/plain' });
            res.end('Not found');
          }
        });

        httpServer.listen(port, () => {
          Logger.info(`Server started successfully on port ${port} with SSE transport`);
          Logger.info(`SSE endpoint: http://localhost:${port}/sse`);
          Logger.info(`Status page: http://localhost:${port}/`);
        });
      } else {
        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        Logger.info('Server started successfully on stdio');
      }
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error('Failed to start server:', errorMessage);
      Logger.warn('Attempting to start in minimal mode...');
      
      try {
        // Attempt to start in minimal mode without validation
        if (port) {
          Logger.warn('Minimal mode does not support HTTP/SSE - falling back to stdio');
        }
        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        Logger.warn('Server started in minimal mode (validation failed)');
        Logger.info('Use "xcode_health_check" tool to diagnose startup issues');
      } catch (fallbackError) {
        const fallbackErrorMessage = fallbackError instanceof Error ? fallbackError.message : String(fallbackError);
        Logger.error('Critical failure - unable to start server:', fallbackErrorMessage);
        await Logger.flush();
        process.exit(1);
      }
    }
  }
}

// Only run if not in test environment
if (process.env.NODE_ENV !== 'test') {
  const server = new XcodeMCPServer();
  
  // Check for port argument
  const portArg = process.argv.find(arg => arg.startsWith('--port='));
  const portValue = portArg?.split('=')[1];
  const port = portValue ? parseInt(portValue, 10) : undefined;
  
  server.start(port).catch(async (error: unknown) => {
    const errorMessage = error instanceof Error ? error.message : String(error);
    Logger.error('Server startup failed:', errorMessage);
    await Logger.flush();
    process.exit(1);
  });
}
</file>

<file path="README.md">
# XcodeMCP

[![npm version](https://img.shields.io/npm/v/xcodemcp.svg)](https://www.npmjs.com/package/xcodemcp)
[![Test Status](https://github.com/lapfelix/XcodeMCP/actions/workflows/test.yml/badge.svg)](https://github.com/lapfelix/XcodeMCP/actions/workflows/test.yml)

Model Context Protocol (MCP) server that controls Xcode directly through JavaScript for Automation (JXA).

## What it does

- Controls Xcode directly through JavaScript for Automation (not xcodebuild CLI)
- Opens projects, builds, runs, tests, and debugs from within Xcode
- Parses build logs with precise error locations using [XCLogParser](https://github.com/MobileNativeFoundation/XCLogParser)
- Provides comprehensive environment validation and health checks
- Supports graceful degradation when optional dependencies are missing

## Requirements

- macOS with Xcode installed
- Node.js 18+
- XCLogParser (recommended): `brew install xclogparser`

## Usage

### Quick Install

[<img src="https://img.shields.io/badge/VS_Code-VS_Code?style=flat-square&label=Install%20Server&color=0098FF" alt="Install in VS Code">](https://insiders.vscode.dev/redirect/mcp/install?name=xcodemcp&config=%7B%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22xcodemcp%40latest%22%5D%7D)
[<img alt="Install in VS Code Insiders" src="https://img.shields.io/badge/VS_Code_Insiders-VS_Code_Insiders?style=flat-square&label=Install%20Server&color=24bfa5">](https://insiders.vscode.dev/redirect/mcp/install?name=xcodemcp&config=%7B%22command%22%3A%22npx%22%2C%22args%22%3A%5B%22xcodemcp%40latest%22%5D%7D&quality=insiders)
[<img src="https://cursor.com/deeplink/mcp-install-dark.svg" height=20 alt="Install MCP Server">](https://cursor.com/install-mcp?name=XcodeMCP&config=eyJjb21tYW5kIjoibnB4IHhjb2RlbWNwQGxhdGVzdCIsImVudiI6e319)

XCLogParser is recommended but optional:
```bash
brew install xclogparser
```

### Install from npm

Run directly with npx:
```bash
npx -y xcodemcp@latest
```

Or install globally:
```bash
npm install -g xcodemcp
```

### MCP Configuration

Add to your MCP configuration:
```json
{
  "mcpServers": {
    "xcodemcp": {
      "command": "npx",
      "args": ["-y", "xcodemcp@latest"],
      "env": {
        "LOG_LEVEL": "INFO"
      }
    }
  }
}
```

### Claude Code CLI Setup

To add XcodeMCP to Claude Code using the command line:
```bash
claude mcp add-json XcodeMCP '{
  "command": "npx",
  "args": ["-y", "xcodemcp@latest"],
  "env": {
    "LOG_LEVEL": "INFO"
  }
}'
```

### Development Setup

For local development:
```bash
git clone https://github.com/lapfelix/XcodeMCP.git
cd XcodeMCP
npm install

# Run in development mode (TypeScript)
npm run dev:ts

# Or build and run compiled version
npm run build
npm start
```

## Available Tools

**Project Management:**
- `xcode_open_project` - Open projects and workspaces
- `xcode_get_workspace_info` - Get workspace status and details
- `xcode_get_projects` - List projects in workspace
- `xcode_open_file` - Open files with optional line number

**Build Operations:**
- `xcode_build` - Build with detailed error parsing
- `xcode_clean` - Clean build artifacts
- `xcode_test` - Run tests with optional arguments
- `xcode_run` - Run the active scheme
- `xcode_debug` - Start debugging session
- `xcode_stop` - Stop current operation

**Configuration:**
- `xcode_get_schemes` - List available schemes
- `xcode_set_active_scheme` - Switch active scheme
- `xcode_get_run_destinations` - List simulators and devices

**XCResult Analysis:**
- `xcresult_browse` - Browse test results and analyze failures
- `xcresult_browser_get_console` - Get console output for specific tests
- `xcresult_summary` - Quick overview of test results
- `xcresult_get_screenshot` - Extract screenshots from test failures
- `xcresult_get_ui_hierarchy` - Get UI hierarchy as AI-readable JSON with timestamp selection
- `xcresult_get_ui_element` - Get detailed properties of specific UI elements by index
- `xcresult_list_attachments` - List all attachments for a test
- `xcresult_export_attachment` - Export specific attachments from test results

**Diagnostics:**
- `xcode_health_check` - Environment validation and troubleshooting

## XCResult Analysis Features

XcodeMCP provides comprehensive tools for analyzing Xcode test results (.xcresult files), making it easy to debug test failures and extract valuable information:

### Test Result Analysis
- **Browse Results**: Navigate through test hierarchies, view pass/fail status, and examine detailed test information
- **Console Logs**: Extract console output and test activities with precise timestamps for debugging
- **Quick Summaries**: Get overview statistics including pass rates, failure counts, and duration

### Visual Debugging
- **Screenshot Extraction**: Extract PNG screenshots from test failures using ffmpeg frame extraction from video attachments
- **Timestamp Precision**: Specify exact timestamps to capture UI state at specific moments during test execution

### UI Hierarchy Analysis
- **AI-Readable Format**: Extract UI hierarchies as compressed JSON with single-letter properties (`t`=type, `l`=label, `f`=frame, `c`=children, `j`=index)
- **Timestamp Selection**: Automatically find the closest UI hierarchy capture to any specified timestamp
- **Element Deep-Dive**: Use index references to get full details of any UI element, including accessibility properties and frame information
- **Size Optimization**: 75%+ size reduction compared to full hierarchy data while maintaining all essential information

### Attachment Management
- **Complete Inventory**: List all attachments (screenshots, videos, debug descriptions, UI hierarchies) for any test
- **Selective Export**: Export specific attachments by index or type
- **Smart Detection**: Automatically identify and categorize different attachment types

### Usage Examples

```bash
# Browse test results
xcresult_browse "/path/to/TestResults.xcresult"

# Get console output to find failure timestamps
xcresult_browser_get_console "/path/to/TestResults.xcresult" "MyTest/testMethod()"

# Get UI hierarchy at specific timestamp (AI-readable slim version)
xcresult_get_ui_hierarchy "/path/to/TestResults.xcresult" "MyTest/testMethod()" 45.25

# Get full UI hierarchy (with size warning)
xcresult_get_ui_hierarchy "/path/to/TestResults.xcresult" "MyTest/testMethod()" 45.25 true

# Get detailed properties of a specific UI element
xcresult_get_ui_element "/path/to/ui_hierarchy_full.json" 15

# Extract screenshot at failure point
xcresult_get_screenshot "/path/to/TestResults.xcresult" "MyTest/testMethod()" 30.71
```

## Configuration

### Logging Configuration

XcodeMCP supports configurable logging to help with debugging and monitoring:

#### Environment Variables

- **`LOG_LEVEL`**: Controls logging verbosity (default: `INFO`)
  - `SILENT`: No logging output
  - `ERROR`: Only error messages
  - `WARN`: Warnings and errors
  - `INFO`: General operational information (recommended)
  - `DEBUG`: Detailed diagnostic information

- **`XCODEMCP_LOG_FILE`**: Optional file path for logging
  - Logs are written to the specified file in addition to stderr
  - Parent directories are created automatically
  - Example: `/tmp/xcodemcp.log` or `~/Library/Logs/xcodemcp.log`

- **`XCODEMCP_CONSOLE_LOGGING`**: Enable/disable console output (default: `true`)
  - Set to `false` to disable stderr logging (useful when using file logging only)

#### Examples

**Debug logging with file output:**
```json
{
  "mcpServers": {
    "xcodemcp": {
      "command": "npx",
      "args": ["-y", "xcodemcp@latest"],
      "env": {
        "LOG_LEVEL": "DEBUG",
        "XCODEMCP_LOG_FILE": "~/Library/Logs/xcodemcp.log"
      }
    }
  }
}
```

**Silent mode (no logging):**
```json
{
  "mcpServers": {
    "xcodemcp": {
      "command": "npx", 
      "args": ["-y", "xcodemcp@latest"],
      "env": {
        "LOG_LEVEL": "SILENT"
      }
    }
  }
}
```

**File-only logging:**
```json
{
  "mcpServers": {
    "xcodemcp": {
      "command": "npx",
      "args": ["-y", "xcodemcp@latest"], 
      "env": {
        "LOG_LEVEL": "INFO",
        "XCODEMCP_LOG_FILE": "/tmp/xcodemcp.log",
        "XCODEMCP_CONSOLE_LOGGING": "false"
      }
    }
  }
}
```

All logs are properly formatted with timestamps and log levels, and stderr output maintains compatibility with the MCP protocol.

## Troubleshooting

### XCLogParser Not Found

If you see a warning that XCLogParser is not found even though it's installed:

1. **Verify installation:**
   ```bash
   which xclogparser
   xclogparser version
   ```

2. **Common issues and solutions:**
   - **PATH issue**: If `which xclogparser` returns nothing, add the installation directory to your PATH:
     ```bash
     # For Homebrew on Intel Macs
     export PATH="/usr/local/bin:$PATH"
     
     # For Homebrew on Apple Silicon Macs
     export PATH="/opt/homebrew/bin:$PATH"
     ```
   
   - **Wrong command**: Older documentation may reference `xclogparser --version`, but the correct command is `xclogparser version` (without dashes)
   
   - **Permission issue**: Ensure xclogparser is executable:
     ```bash
     chmod +x $(which xclogparser)
     ```

3. **Environment validation**: Run the health check to get detailed diagnostics:
   ```bash
   echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/call", "params": {"name": "xcode_health_check", "arguments": {}}}' | npx xcodemcp
   ```

**Note**: XcodeMCP can operate without XCLogParser, but build error parsing will be limited.

## Example Output

**Build with errors:**
```
❌ BUILD FAILED (2 errors)

ERRORS:
  • /path/HandsDownApp.swift:7:18: Expected 'func' keyword in instance method declaration
  • /path/MenuBarManager.swift:98:13: Invalid redeclaration of 'toggleItem'
```

**Health check:**
```
✅ All systems operational

✅ OS: macOS environment detected
✅ XCODE: Xcode found at /Applications/Xcode.app (version 16.4)
✅ XCLOGPARSER: XCLogParser found (XCLogParser 0.2.41)
✅ OSASCRIPT: JavaScript for Automation (JXA) is available
✅ PERMISSIONS: Xcode automation permissions are working
```
</file>

<file path="src/tools/XCResultTools.ts">
import { existsSync } from 'fs';
import { spawn } from 'child_process';
import { tmpdir } from 'os';
import { join } from 'path';
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { XCResultParser } from '../utils/XCResultParser.js';
import { Logger } from '../utils/Logger.js';
import type { McpResult, TestAttachment } from '../types/index.js';

export class XCResultTools {
  /**
   * Browse xcresult file - list tests or show specific test details
   */
  public static async xcresultBrowse(
    xcresultPath: string,
    testId?: string,
    includeConsole: boolean = false
  ): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);

      if (testId) {
        // Show specific test details
        const details = await parser.formatTestDetails(testId, includeConsole);
        return { content: [{ type: 'text', text: details }] };
      } else {
        // List all tests
        const testList = await parser.formatTestList();
        
        let usage = '\n\n💡 Usage:\n';
        usage += '  View test details: xcresult_browse <path> <test-id-or-index>\n';
        usage += '  View with console: xcresult_browse <path> <test-id-or-index> true\n';
        usage += '  Get console only: xcresult_browser_get_console <path> <test-id-or-index>\n';
        usage += '  Get UI hierarchy: xcresult_get_ui_hierarchy <path> <test-id-or-index> [timestamp]\n';
        usage += '  Get screenshot: xcresult_get_screenshot <path> <test-id-or-index> <timestamp>\n';
        usage += '  Examples:\n';
        usage += `    xcresult_browse "${xcresultPath}" 5\n`;
        usage += `    xcresult_browse "${xcresultPath}" "SomeTest/testMethod()" true\n`;
        usage += `    xcresult_get_ui_hierarchy "${xcresultPath}" 5 120.5\n`;
        usage += `    xcresult_get_screenshot "${xcresultPath}" 5 120.5\n`;
        
        return { content: [{ type: 'text', text: testList + usage }] };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to analyze XCResult: ${errorMessage}`
      );
    }
  }

  /**
   * Get console output for a specific test
   */
  public static async xcresultBrowserGetConsole(
    xcresultPath: string,
    testId: string
  ): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    if (!testId || testId.trim() === '') {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Test ID or index is required'
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);
      
      // First find the test node to get the actual test identifier
      const testNode = await parser.findTestNode(testId);
      if (!testNode) {
        return { 
          content: [{ 
            type: 'text', 
            text: `❌ Test '${testId}' not found\n\nRun xcresult_browse "${xcresultPath}" to see all available tests` 
          }] 
        };
      }

      let output = `📟 Console Output for: ${testNode.name}\n`;
      output += '='.repeat(80) + '\n\n';

      // Get console output
      const consoleOutput = await parser.getConsoleOutput(testNode.nodeIdentifier);
      output += `Console Log:\n${consoleOutput}\n\n`;

      // Get test activities
      if (testNode.nodeIdentifier) {
        output += `🔬 Test Activities:\n`;
        const activities = await parser.getTestActivities(testNode.nodeIdentifier);
        output += activities;
      }

      // Check if output is very long and should be saved to a file
      const lineCount = output.split('\n').length;
      const charCount = output.length;
      
      // If output is longer than 20 lines or 2KB, save to file
      if (lineCount > 20 || charCount > 2000) {
        const { writeFile } = await import('fs/promises');
        const { tmpdir } = await import('os');
        const { join } = await import('path');
        
        // Create a unique filename
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const safeTestName = testNode.name.replace(/[^a-zA-Z0-9]/g, '_');
        const filename = `console_output_${safeTestName}_${timestamp}.txt`;
        const filePath = join(tmpdir(), filename);
        
        await writeFile(filePath, output, 'utf-8');
        
        const fileSizeKB = Math.round(charCount / 1024);
        
        return { 
          content: [{ 
            type: 'text', 
            text: `📟 Console Output for: ${testNode.name}\n` +
                  `📄 Output saved to file (${lineCount} lines, ${fileSizeKB} KB): ${filePath}\n\n` +
                  `💡 The console output was too large to display directly. ` +
                  `You can read the file to access the complete console log and test activities.`
          }] 
        };
      }

      return { content: [{ type: 'text', text: output }] };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to get console output: ${errorMessage}`
      );
    }
  }

  /**
   * Get a quick summary of an xcresult file
   */
  public static async xcresultSummary(xcresultPath: string): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);
      const analysis = await parser.analyzeXCResult();

      let output = `📊 XCResult Summary - ${xcresultPath}\n`;
      output += '='.repeat(80) + '\n\n';
      output += `Result: ${analysis.summary.result === 'Failed' ? '❌' : '✅'} ${analysis.summary.result}\n`;
      output += `Total: ${analysis.totalTests} | Passed: ${analysis.passedTests} ✅ | Failed: ${analysis.failedTests} ❌ | Skipped: ${analysis.skippedTests} ⏭️\n`;
      output += `Pass Rate: ${analysis.passRate.toFixed(1)}%\n`;
      output += `Duration: ${analysis.duration}\n\n`;

      if (analysis.failedTests > 0) {
        output += `❌ Failed Tests:\n`;
        for (const failure of analysis.summary.testFailures.slice(0, 5)) {
          output += `  • ${failure.testName}: ${failure.failureText.substring(0, 100)}${failure.failureText.length > 100 ? '...' : ''}\n`;
        }
        if (analysis.summary.testFailures.length > 5) {
          output += `  ... and ${analysis.summary.testFailures.length - 5} more\n`;
        }
        output += '\n';
      }

      output += `💡 Use 'xcresult_browse "${xcresultPath}"' to explore detailed results.`;

      return { content: [{ type: 'text', text: output }] };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to analyze XCResult: ${errorMessage}`
      );
    }
  }

  /**
   * List all attachments for a test
   */
  public static async xcresultListAttachments(
    xcresultPath: string,
    testId: string
  ): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    if (!testId || testId.trim() === '') {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Test ID or index is required'
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);
      
      // First find the test node to get the actual test identifier
      const testNode = await parser.findTestNode(testId);
      if (!testNode) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' not found. Run xcresult_browse "${xcresultPath}" to see all available tests`
        );
      }

      if (!testNode.nodeIdentifier) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' does not have a valid identifier for attachment retrieval`
        );
      }

      // Get test attachments
      const attachments = await parser.getTestAttachments(testNode.nodeIdentifier);
      
      let output = `📎 Attachments for test: ${testNode.name}\n`;
      output += `Found ${attachments.length} attachments\n`;
      output += '='.repeat(80) + '\n\n';
      
      if (attachments.length === 0) {
        output += 'No attachments found for this test.\n';
      } else {
        attachments.forEach((att, index) => {
          const filename = att.name || att.filename || 'unnamed';
          output += `[${index + 1}] ${filename}\n`;
          
          // Determine type from identifier or filename
          let type = att.uniform_type_identifier || att.uniformTypeIdentifier || '';
          if (!type || type === 'unknown') {
            // Infer type from filename extension or special patterns
            const ext = filename.toLowerCase().split('.').pop();
            if (ext === 'jpeg' || ext === 'jpg') type = 'public.jpeg';
            else if (ext === 'png') type = 'public.png';
            else if (ext === 'mp4') type = 'public.mpeg-4';
            else if (ext === 'mov') type = 'com.apple.quicktime-movie';
            else if (ext === 'txt') type = 'public.plain-text';
            else if (filename.toLowerCase().includes('app ui hierarchy')) type = 'ui-hierarchy';
            else if (filename.toLowerCase().includes('ui snapshot')) type = 'ui-snapshot';
            else if (filename.toLowerCase().includes('synthesized event')) type = 'synthesized-event';
            else type = 'unknown';
          }
          
          output += `    Type: ${type}\n`;
          if (att.payloadSize || att.payload_size) {
            output += `    Size: ${att.payloadSize || att.payload_size} bytes\n`;
          }
          output += '\n';
        });
        
        output += '\n💡 To export a specific attachment, use xcresult_export_attachment with the attachment index.\n';
      }
      
      return { content: [{ type: 'text', text: output }] };

    } catch (error) {
      if (error instanceof McpError) {
        throw error;
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to list attachments: ${errorMessage}`
      );
    }
  }


  /**
   * Export a specific attachment by index
   */
  public static async xcresultExportAttachment(
    xcresultPath: string,
    testId: string,
    attachmentIndex: number,
    convertToJson: boolean = false
  ): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    if (!testId || testId.trim() === '') {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Test ID or index is required'
      );
    }

    if (attachmentIndex < 1) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Attachment index must be 1 or greater'
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);
      
      // First find the test node to get the actual test identifier
      const testNode = await parser.findTestNode(testId);
      if (!testNode) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' not found. Run xcresult_browse "${xcresultPath}" to see all available tests`
        );
      }

      if (!testNode.nodeIdentifier) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' does not have a valid identifier for attachment retrieval`
        );
      }

      // Get test attachments
      const attachments = await parser.getTestAttachments(testNode.nodeIdentifier);
      
      if (attachments.length === 0) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `No attachments found for test '${testNode.name}'.`
        );
      }

      if (attachmentIndex > attachments.length) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Invalid attachment index ${attachmentIndex}. Test has ${attachments.length} attachments.`
        );
      }

      const attachment = attachments[attachmentIndex - 1];
      if (!attachment) {
        throw new McpError(
          ErrorCode.InternalError,
          `Attachment at index ${attachmentIndex} not found`
        );
      }

      const attachmentId = attachment.payloadId || attachment.payload_uuid || attachment.payloadUUID;
      if (!attachmentId) {
        throw new McpError(
          ErrorCode.InternalError,
          'Attachment does not have a valid ID for export'
        );
      }

      const filename = attachment.filename || attachment.name || `attachment_${attachmentIndex}`;
      
      // Determine type from identifier or filename first
      let type = attachment.uniform_type_identifier || attachment.uniformTypeIdentifier || '';
      if (!type || type === 'unknown') {
        // Infer type from filename extension or special patterns
        const ext = filename.toLowerCase().split('.').pop();
        if (ext === 'jpeg' || ext === 'jpg') type = 'public.jpeg';
        else if (ext === 'png') type = 'public.png';
        else if (ext === 'mp4') type = 'public.mpeg-4';
        else if (ext === 'mov') type = 'com.apple.quicktime-movie';
        else if (ext === 'txt') type = 'public.plain-text';
        else if (filename.toLowerCase().includes('app ui hierarchy')) type = 'ui-hierarchy';
        else if (filename.toLowerCase().includes('ui snapshot')) type = 'ui-snapshot';
        else if (filename.toLowerCase().includes('synthesized event')) type = 'synthesized-event';
        else type = 'unknown';
      }

      const exportedPath = await parser.exportAttachment(attachmentId, filename);
      
      // Handle UI hierarchy files specially  
      if (type === 'ui-hierarchy') {
        if (convertToJson) {
          const hierarchyJson = await this.convertUIHierarchyToJSON(exportedPath);
          return { 
            content: [{ 
              type: 'text', 
              text: JSON.stringify(hierarchyJson)
            }] 
          };
        }
        
        // Return the raw UI hierarchy content (it's already AI-friendly)
        const { readFile } = await import('fs/promises');
        const hierarchyContent = await readFile(exportedPath, 'utf-8');
        return { 
          content: [{ 
            type: 'text', 
            text: `UI Hierarchy for: ${filename}\nType: ${type}\n\n${hierarchyContent}`
          }] 
        };
      }

      return { 
        content: [{ 
          type: 'text', 
          text: `Attachment exported to: ${exportedPath}\nFilename: ${filename}\nType: ${type}`
        }] 
      };

    } catch (error) {
      if (error instanceof McpError) {
        throw error;
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to export attachment: ${errorMessage}`
      );
    }
  }

  /**
   * Get UI hierarchy attachment from test as JSON (slim AI-readable version by default)
   */
  public static async xcresultGetUIHierarchy(
    xcresultPath: string,
    testId: string,
    timestamp?: number,
    fullHierarchy: boolean = false,
    rawFormat: boolean = false
  ): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    if (!testId || testId.trim() === '') {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Test ID or index is required'
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);
      
      // First find the test node to get the actual test identifier
      const testNode = await parser.findTestNode(testId);
      if (!testNode) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' not found. Run xcresult_browse "${xcresultPath}" to see all available tests`
        );
      }

      if (!testNode.nodeIdentifier) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' does not have a valid identifier for attachment retrieval`
        );
      }

      // Get test attachments
      const attachments = await parser.getTestAttachments(testNode.nodeIdentifier);
      
      if (attachments.length === 0) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `No attachments found for test '${testNode.name}'. This test may not have UI snapshots.`
        );
      }

      Logger.info(`Found ${attachments.length} attachments for test ${testNode.name}`);
      
      // Log all attachment details for debugging
      Logger.info('All attachments:');
      attachments.forEach((att, index) => {
        Logger.info(`  ${index + 1}. Name: ${att.name || att.filename || 'unnamed'}, Type: ${att.uniform_type_identifier || att.uniformTypeIdentifier || 'unknown'}`);
      });

      // Look for App UI hierarchy attachments (text-based)
      const uiHierarchyAttachments = this.findAppUIHierarchyAttachments(attachments);
      if (uiHierarchyAttachments.length === 0) {
        const attachmentNames = attachments.map(a => a.name || a.filename || 'unnamed').join(', ');
        throw new McpError(
          ErrorCode.InvalidParams,
          `No App UI hierarchy attachments found for test '${testNode.name}'. Available attachments: ${attachmentNames}`
        );
      }

      // If timestamp is provided, find the closest UI hierarchy attachment
      let selectedAttachment = uiHierarchyAttachments[0];
      if (timestamp !== undefined && uiHierarchyAttachments.length > 1) {
        Logger.info(`Looking for UI hierarchy closest to timestamp ${timestamp}s`);
        const closestAttachment = this.findClosestUISnapshot(uiHierarchyAttachments, timestamp);
        if (closestAttachment) {
          selectedAttachment = closestAttachment;
        }
      } else if (uiHierarchyAttachments.length > 1) {
        Logger.info(`Multiple UI hierarchy attachments found (${uiHierarchyAttachments.length}). Using the first one. Specify a timestamp to select a specific one.`);
      }

      if (!selectedAttachment) {
        throw new McpError(
          ErrorCode.InternalError,
          `No valid UI hierarchy found for test '${testNode.name}'`
        );
      }

      // If raw format is requested, return the original accessibility tree text
      if (rawFormat) {
        const attachmentId = selectedAttachment.payloadId || selectedAttachment.payload_uuid || selectedAttachment.payloadUUID;
        if (!attachmentId) {
          throw new McpError(
            ErrorCode.InternalError,
            'UI hierarchy attachment does not have a valid ID for export'
          );
        }

        const filename = selectedAttachment.filename || selectedAttachment.name || 'ui-hierarchy';
        const exportedPath = await parser.exportAttachment(attachmentId, filename);
        
        const { readFile } = await import('fs/promises');
        const hierarchyContent = await readFile(exportedPath, 'utf-8');
        
        const timestampInfo = timestamp !== undefined && selectedAttachment.timestamp !== undefined
          ? ` (closest to ${timestamp}s, actual: ${selectedAttachment.timestamp}s)`
          : '';

        return { 
          content: [{ 
            type: 'text', 
            text: `🌲 Raw UI Hierarchy for test '${testNode.name}'${timestampInfo}:\n\n${hierarchyContent}`
          }] 
        };
      }

      // Export and convert text-based UI hierarchy to JSON
      const hierarchyData = await this.exportTextUIHierarchyAsJSON(parser, selectedAttachment, testNode.name);
      
      if (fullHierarchy) {
        // Save full JSON to file with warning
        const jsonFilename = `ui_hierarchy_full_${testNode.name.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.json`;
        const jsonPath = await this.saveUIHierarchyJSON(hierarchyData, jsonFilename);
        
        const fileSizeKB = Math.round(JSON.stringify(hierarchyData).length / 1024);
        
        return { 
          content: [{ 
            type: 'text', 
            text: `⚠️  LARGE FILE WARNING: Full UI hierarchy exported (${fileSizeKB} KB)\n\n` +
                  `📄 Full hierarchy: ${jsonPath}\n\n` +
                  `💡 For AI analysis, consider using the slim version instead:\n` +
                  `   xcresult_get_ui_hierarchy "${xcresultPath}" "${testId}" ${timestamp || ''} false`
          }] 
        };
      } else {
        // Default: Create and save slim AI-readable version
        const slimData = this.createSlimUIHierarchy(hierarchyData);
        const slimFilename = `ui_hierarchy_${testNode.name.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.json`;
        const slimPath = await this.saveUIHierarchyJSON(slimData, slimFilename);
        
        // Also save full data for element lookup
        const fullFilename = `ui_hierarchy_full_${testNode.name.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.json`;
        const fullPath = await this.saveUIHierarchyJSON(hierarchyData, fullFilename);
        
        // Try to find a screenshot at the specified timestamp
        let screenshotInfo = '';
        const screenshotTimestamp = timestamp || selectedAttachment.timestamp;
        if (screenshotTimestamp !== undefined) {
          try {
            const screenshotResult = await this.xcresultGetScreenshot(
              xcresultPath, 
              testId, 
              screenshotTimestamp
            );
            if (screenshotResult && screenshotResult.content?.[0] && 'text' in screenshotResult.content[0]) {
              const textContent = screenshotResult.content[0];
              if (textContent.type === 'text' && typeof textContent.text === 'string') {
                // Extract the screenshot path from the result text
                const pathMatch = textContent.text.match(/Screenshot extracted .+: (.+)/);
                if (pathMatch && pathMatch[1]) {
                  screenshotInfo = `\n📸 Screenshot at timestamp ${screenshotTimestamp}s: ${pathMatch[1]}`;
                }
              }
            }
          } catch (error) {
            // Screenshot extraction failed, continue without it
            Logger.info(`Could not extract screenshot at timestamp ${screenshotTimestamp}s: ${error}`);
          }
        }
        
        return { 
          content: [{ 
            type: 'text', 
            text: `🤖 AI-readable UI hierarchy: ${slimPath}\n\n` +
                  `💡 Slim version properties:\n` +
                  `  • t = type (element type like Button, StaticText, etc.)\n` +
                  `  • l = label (visible text/accessibility label)\n` +
                  `  • c = children (array of child elements)\n` +
                  `  • j = index (reference to full element in original JSON)\n\n` +
                  `🔍 Use xcresult_get_ui_element "${fullPath}" <index> to get full details of any element.\n` +
                  `⚠️  To get the full hierarchy (several MB), use: full_hierarchy=true${screenshotInfo}`
          }] 
        };
      }

    } catch (error) {
      if (error instanceof McpError) {
        throw error;
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to get UI hierarchy: ${errorMessage}`
      );
    }
  }

  /**
   * Get screenshot from failed test - returns direct screenshot or extracts from video
   */
  public static async xcresultGetScreenshot(
    xcresultPath: string,
    testId: string,
    timestamp: number
  ): Promise<McpResult> {
    // Validate xcresult path
    if (!existsSync(xcresultPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `XCResult file not found: ${xcresultPath}`
      );
    }

    if (!xcresultPath.endsWith('.xcresult')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Path must be an .xcresult file: ${xcresultPath}`
      );
    }

    // Check if xcresult is readable
    if (!XCResultParser.isXCResultReadable(xcresultPath)) {
      throw new McpError(
        ErrorCode.InternalError,
        `XCResult file is not readable or incomplete: ${xcresultPath}`
      );
    }

    if (!testId || testId.trim() === '') {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Test ID or index is required'
      );
    }

    try {
      const parser = new XCResultParser(xcresultPath);
      
      // First find the test node to get the actual test identifier
      const testNode = await parser.findTestNode(testId);
      if (!testNode) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' not found. Run xcresult_browse "${xcresultPath}" to see all available tests`
        );
      }

      if (!testNode.nodeIdentifier) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Test '${testId}' does not have a valid identifier for attachment retrieval`
        );
      }

      // Get test attachments
      const attachments = await parser.getTestAttachments(testNode.nodeIdentifier);
      
      if (attachments.length === 0) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `No attachments found for test '${testNode.name}'. This test may not have failed or may not have generated screenshots/videos.`
        );
      }

      Logger.info(`Found ${attachments.length} attachments for test ${testNode.name}`);

      // Look for video attachment first (gives us actual PNG images)
      const videoAttachment = this.findVideoAttachment(attachments);
      if (videoAttachment) {
        const screenshotPath = await this.extractScreenshotFromVideo(parser, videoAttachment, testNode.name, timestamp);
        return { 
          content: [{ 
            type: 'text', 
            text: `Screenshot extracted from video for test '${testNode.name}' at ${timestamp}s: ${screenshotPath}` 
          }] 
        };
      }

      // Look for direct image attachment (PNG or JPEG) as fallback
      const closestImageResult = this.findClosestImageAttachment(attachments, timestamp);
      if (closestImageResult) {
        const screenshotPath = await this.exportScreenshotAttachment(parser, closestImageResult.attachment);
        const timeDiff = closestImageResult.timeDifference;
        const timeDiffText = timeDiff === 0 
          ? 'at exact timestamp' 
          : timeDiff > 0 
            ? `${timeDiff.toFixed(2)}s after requested time` 
            : `${Math.abs(timeDiff).toFixed(2)}s before requested time`;
            
        return { 
          content: [{ 
            type: 'text', 
            text: `Screenshot exported for test '${testNode.name}' (${timeDiffText}): ${screenshotPath}` 
          }] 
        };
      }

      // No suitable attachments found
      const attachmentTypes = attachments.map(a => a.uniform_type_identifier || a.uniformTypeIdentifier || 'unknown').join(', ');
      throw new McpError(
        ErrorCode.InvalidParams,
        `No screenshot or video attachments found for test '${testNode.name}'. Available attachment types: ${attachmentTypes}`
      );

    } catch (error) {
      if (error instanceof McpError) {
        throw error;
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      
      if (errorMessage.includes('xcresulttool')) {
        throw new McpError(
          ErrorCode.InternalError,
          `XCResult parsing failed. Make sure Xcode Command Line Tools are installed: ${errorMessage}`
        );
      }
      
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to get screenshot: ${errorMessage}`
      );
    }
  }

  /**
   * Find App UI hierarchy attachments (text-based)
   */
  private static findAppUIHierarchyAttachments(attachments: TestAttachment[]): TestAttachment[] {
    return attachments.filter(attachment => {
      const name = attachment.name || attachment.filename || '';
      return name.includes('App UI hierarchy');
    });
  }

  /**
   * Find UI Snapshot attachments (legacy method)
   */
  // private static findUISnapshotAttachments(attachments: TestAttachment[]): TestAttachment[] {
  //   return attachments.filter(attachment => {
  //     const name = attachment.name || attachment.filename || '';
  //     // Look for both "UI Snapshot" and "App UI hierarchy" attachments
  //     return name.includes('UI Snapshot') || name.includes('App UI hierarchy');
  //   });
  // }

  /**
   * Find the UI snapshot closest to a given timestamp
   */
  private static findClosestUISnapshot(attachments: TestAttachment[], timestamp: number): TestAttachment | undefined {
    if (attachments.length === 0) {
      return undefined;
    }
    
    // If only one attachment, return it
    if (attachments.length === 1) {
      return attachments[0];
    }
    
    let closest = attachments[0];
    let minDifference = Infinity;
    let attachmentsWithTimestamps = 0;
    
    // Log available attachments and their timestamps for debugging
    Logger.info(`Finding closest attachment to timestamp ${timestamp}s among ${attachments.length} attachments`);
    
    for (const attachment of attachments) {
      // Use timestamp if available, otherwise try to extract from name
      let attachmentTime = attachment.timestamp;
      
      // If no direct timestamp, try alternative approaches
      if (attachmentTime === undefined || isNaN(attachmentTime)) {
        // Try to extract timestamp from attachment name if it contains time info
        if (attachment.name) {
          const timeMatch = attachment.name.match(/t\s*=\s*([\d.]+)s/);
          if (timeMatch && timeMatch[1]) {
            attachmentTime = parseFloat(timeMatch[1]);
          }
        }
      }
      
      // Log attachment details for debugging
      Logger.info(`  Attachment "${attachment.name}" - timestamp: ${attachmentTime}, type: ${attachment.uniform_type_identifier || attachment.uniformTypeIdentifier || 'unknown'}`);
      
      if (attachmentTime !== undefined && !isNaN(attachmentTime)) {
        attachmentsWithTimestamps++;
        // Both timestamps should be in seconds
        const difference = Math.abs(attachmentTime - timestamp);
        Logger.info(`    Time difference: ${difference}s`);
        
        if (difference < minDifference) {
          minDifference = difference;
          closest = attachment;
        }
      }
    }
    
    // If no attachments have timestamps, use a different strategy
    if (attachmentsWithTimestamps === 0) {
      Logger.info(`No timestamp information found for UI hierarchy attachments. Using attachment order heuristic.`);
      
      // For UI hierarchy attachments without timestamps, prefer the later one
      // when the requested timestamp is > 60s (indicating late in test execution)
      if (timestamp > 60 && attachments.length >= 2) {
        const lastAttachment = attachments[attachments.length - 1];
        if (lastAttachment) {
          closest = lastAttachment; // Use last attachment
          Logger.info(`Selected last attachment "${closest.name || 'unnamed'}" based on late timestamp heuristic (${timestamp}s > 60s)`);
        }
      } else {
        const firstAttachment = attachments[0];
        if (firstAttachment) {
          closest = firstAttachment; // Use first attachment for early timestamps
          Logger.info(`Selected first attachment "${closest.name || 'unnamed'}" based on early timestamp heuristic (${timestamp}s <= 60s)`);
        }
      }
    } else if (closest) {
      Logger.info(`Selected attachment "${closest.name}" with minimum time difference of ${minDifference}s (found timestamps on ${attachmentsWithTimestamps}/${attachments.length} attachments)`);
    }
    
    return closest;
  }

  /**
   * Export UI hierarchy attachment and convert to JSON (legacy plist method)
   */
  // private static async exportUIHierarchyAsJSON(parser: XCResultParser, attachment: TestAttachment, testName: string): Promise<any> {
  //   const attachmentId = attachment.payloadId || attachment.payload_uuid || attachment.payloadUUID;
  //   if (!attachmentId) {
  //     throw new Error('UI Snapshot attachment does not have a valid ID for export');
  //   }

  //   // Export the UI snapshot to a temporary file
  //   const filename = `ui_hierarchy_${testName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.plist`;
  //   const plistPath = await parser.exportAttachment(attachmentId, filename);
    
  //   Logger.info(`Exported UI hierarchy to: ${plistPath}`);

  //   // Convert the plist to JSON using a more robust approach
  //   return await this.convertUIHierarchyToJSON(plistPath);
  // }

  /**
   * Convert UI hierarchy plist to JSON using plutil -p (readable format)
   */
  private static async convertUIHierarchyToJSON(plistPath: string): Promise<any> {
    return new Promise((resolve, reject) => {
      // Use plutil -p to get a readable format, then parse it
      const process = spawn('plutil', ['-p', plistPath], {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';
      
      process.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        if (code === 0) {
          // Parse the plutil -p output
          this.parsePlutilOutput(stdout)
            .then(resolve)
            .catch(reject);
        } else {
          Logger.error(`plutil failed with code ${code}: ${stderr}`);
          reject(new Error(`Failed to read plist: ${stderr}`));
        }
      });

      process.on('error', (error) => {
        reject(new Error(`Failed to run plutil: ${error.message}`));
      });
    });
  }

  /**
   * Parse plutil -p output to extract UI hierarchy information
   */
  private static async parsePlutilOutput(plutilOutput: string): Promise<any> {
    return new Promise((resolve) => {
      try {
        // Extract meaningful UI hierarchy data from plutil output
        const lines = plutilOutput.split('\n');
        
        // Look for the main UI element structure
        const uiElement: any = {
          parseMethod: 'plutil_readable',
          rawPlistSize: lines.length,
        };

        // Extract key information
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i]?.trim();
          if (!line) continue;
          
          // Look for elementType
          if (line.includes('"elementType"')) {
            const nextLine = lines[i + 1]?.trim();
            if (nextLine && nextLine.includes('value =')) {
              const valueMatch = nextLine.match(/value = (\d+)/);
              if (valueMatch && valueMatch[1]) {
                const elementType = parseInt(valueMatch[1]);
                uiElement.elementType = elementType;
                
                // Add description  
                const descriptions: { [key: number]: string } = {
                  1: 'Application', 2: 'Group', 3: 'Window', 8: 'Button',
                  20: 'NavigationBar', 21: 'TabBar', 22: 'TabGroup', 23: 'Toolbar', 25: 'Table', 
                  31: 'CollectionView', 36: 'SegmentedControl', 45: 'ScrollView', 47: 'StaticText', 48: 'TextField'
                };
                if (descriptions[elementType]) {
                  uiElement.elementTypeDescription = descriptions[elementType];
                }
              }
            }
          }
          
          // Look for label
          if (line.includes('"label"')) {
            const nextLine = lines[i + 1]?.trim();
            if (nextLine && nextLine.includes('value =')) {
              const valueMatch = nextLine.match(/value = (\d+)/);
              if (valueMatch && valueMatch[1]) {
                const labelIndex = parseInt(valueMatch[1]);
                // Find the actual label value by looking for index references
                for (let j = 0; j < lines.length; j++) {
                  const currentLine = lines[j];
                  if (currentLine && currentLine.includes(`${labelIndex} =>`)) {
                    const labelLine = lines[j + 1]?.trim();
                    if (labelLine && labelLine.startsWith('"') && labelLine.endsWith('"')) {
                      uiElement.label = labelLine.slice(1, -1); // Remove quotes
                    }
                    break;
                  }
                }
              }
            }
          }
          
          // Look for identifier
          if (line.includes('"identifier"')) {
            const nextLine = lines[i + 1]?.trim();
            if (nextLine && nextLine.includes('value =')) {
              const valueMatch = nextLine.match(/value = (\d+)/);
              if (valueMatch && valueMatch[1]) {
                const idIndex = parseInt(valueMatch[1]);
                // Find the actual identifier value
                for (let j = 0; j < lines.length; j++) {
                  const currentLine = lines[j];
                  if (currentLine && currentLine.includes(`${idIndex} =>`)) {
                    const idLine = lines[j + 1]?.trim();
                    if (idLine && idLine.startsWith('"')) {
                      uiElement.identifier = idLine.slice(1, -1); // Remove quotes
                    }
                    break;
                  }
                }
              }
            }
          }
          
          // Look for enabled
          if (line.includes('"enabled"')) {
            const nextLine = lines[i + 1]?.trim();
            if (nextLine && nextLine.includes('value =')) {
              const valueMatch = nextLine.match(/value = (\d+)/);
              if (valueMatch && valueMatch[1]) {
                const enabledIndex = parseInt(valueMatch[1]);
                // Find the actual enabled value
                for (let j = 0; j < lines.length; j++) {
                  const currentLine = lines[j];
                  if (currentLine && currentLine.includes(`${enabledIndex} =>`)) {
                    const enabledLine = lines[j + 1]?.trim();
                    if (enabledLine === '1' || enabledLine === '0') {
                      uiElement.enabled = enabledLine === '1';
                    }
                    break;
                  }
                }
              }
            }
          }
        }

        // Extract some statistics
        const objectCount = plutilOutput.match(/\d+ =>/g)?.length || 0;
        uiElement.totalObjectsInPlist = objectCount;
        
        // Look for Transit app information and other string values
        if (plutilOutput.includes('Transit')) {
          const transitMatches = plutilOutput.match(/"[^"]*Transit[^"]*"/g) || [];
          uiElement.transitAppReferences = transitMatches;
        }
        
        // Try to extract the label directly from known patterns
        if (plutilOutput.includes('19 => "Transit χ"')) {
          uiElement.label = 'Transit χ';
        }
        
        // Extract all string values for debugging
        const allStrings = plutilOutput.match(/"[^"]+"/g) || [];
        uiElement.allStringsFound = allStrings.slice(0, 10); // First 10 strings

        resolve(uiElement);
      } catch (error) {
        resolve({
          parseMethod: 'plutil_readable',
          error: `Failed to parse plutil output: ${error instanceof Error ? error.message : String(error)}`,
          rawOutputPreview: plutilOutput.slice(0, 500)
        });
      }
    });
  }

  /**
   * Export text-based UI hierarchy attachment and convert to JSON
   */
  private static async exportTextUIHierarchyAsJSON(parser: XCResultParser, attachment: TestAttachment, testName: string): Promise<any> {
    const attachmentId = attachment.payloadId || attachment.payload_uuid || attachment.payloadUUID;
    if (!attachmentId) {
      throw new Error('App UI hierarchy attachment does not have a valid ID for export');
    }

    // Export the UI hierarchy to a temporary file
    const filename = `ui_hierarchy_${testName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.txt`;
    const textPath = await parser.exportAttachment(attachmentId, filename);
    
    Logger.info(`Exported UI hierarchy to: ${textPath}`);

    // Convert the indented text format to JSON
    return await this.convertIndentedUIHierarchyToJSON(textPath);
  }

  /**
   * Convert indented text-based UI hierarchy to structured JSON
   */
  private static async convertIndentedUIHierarchyToJSON(textPath: string): Promise<any> {
    const fs = await import('fs');
    
    try {
      const content = fs.readFileSync(textPath, 'utf8');
      const lines = content.split('\n');
      
      const result = {
        parseMethod: 'indented_text',
        totalLines: lines.length,
        rootElement: null as any,
        flatElements: [] as any[]
      };

      let elementStack: any[] = [];
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line || !line.trim()) continue;
        
        // Calculate indentation level
        const indentLevel = line.search(/\S/);
        const trimmedLine = line.trim();
        
        // Parse element information
        const element = this.parseUIElementLine(trimmedLine, indentLevel);
        
        if (element) {
          // Handle hierarchy based on indentation
          while (elementStack.length > 0 && elementStack[elementStack.length - 1].indentLevel >= indentLevel) {
            elementStack.pop();
          }
          
          element.indentLevel = indentLevel;
          element.children = [];
          
          if (elementStack.length === 0) {
            // Root element
            result.rootElement = element;
          } else {
            // Child element
            const parent = elementStack[elementStack.length - 1];
            parent.children.push(element);
            element.parent = parent.type || 'unknown';
          }
          
          elementStack.push(element);
          result.flatElements.push(element);
        }
      }
      
      return result;
    } catch (error) {
      return {
        parseMethod: 'indented_text',
        error: `Failed to parse indented UI hierarchy: ${error instanceof Error ? error.message : String(error)}`,
        rawContentPreview: ''
      };
    }
  }

  /**
   * Parse a single line of UI element information
   */
  private static parseUIElementLine(line: string, indentLevel: number): any | null {
    // Common patterns in UI hierarchy text format:
    // Application, pid: 12345
    // Window (Main)
    // Button "Submit"
    // StaticText "Hello World"
    // TextField (secure) "password"
    
    if (!line || line.trim() === '') return null;
    
    const element: any = {
      raw: line,
      indentLevel,
      type: 'unknown',
      label: '',
      attributes: {},
      children: []
    };
    
    // Extract element type (first word usually)
    const typeMatch = line.match(/^(\w+)/);
    if (typeMatch) {
      element.type = typeMatch[1];
    }
    
    // Extract quoted text (labels)
    const quotedTextMatch = line.match(/"([^"]*)"/);
    if (quotedTextMatch) {
      element.label = quotedTextMatch[1];
    }
    
    // Extract parenthesized attributes
    const parenthesesMatch = line.match(/\(([^)]*)\)/);
    if (parenthesesMatch) {
      element.attributes.details = parenthesesMatch[1];
    }
    
    // Extract specific patterns
    if (line.includes('pid:')) {
      const pidMatch = line.match(/pid:\s*(\d+)/);
      if (pidMatch && pidMatch[1]) {
        element.attributes.processId = parseInt(pidMatch[1]);
      }
    }
    
    // Extract coordinates/bounds if present
    const boundsMatch = line.match(/\{\{([\d.-]+),\s*([\d.-]+)\},\s*\{([\d.-]+),\s*([\d.-]+)\}\}/);
    if (boundsMatch && boundsMatch[1] && boundsMatch[2] && boundsMatch[3] && boundsMatch[4]) {
      element.attributes.frame = {
        x: parseFloat(boundsMatch[1]),
        y: parseFloat(boundsMatch[2]),
        width: parseFloat(boundsMatch[3]),
        height: parseFloat(boundsMatch[4])
      };
    }
    
    // Extract accessibility identifiers
    if (line.includes('identifier:')) {
      const idMatch = line.match(/identifier:\s*"([^"]*)"/);
      if (idMatch) {
        element.attributes.identifier = idMatch[1];
      }
    }
    
    return element;
  }

  /**
   * Save UI hierarchy data to a JSON file
   */
  private static async saveUIHierarchyJSON(hierarchyData: any, filename: string): Promise<string> {
    const fs = await import('fs');
    const path = await import('path');
    
    // Use same temp directory as other attachments
    const tempDir = path.join(tmpdir(), 'xcode-mcp-attachments');
    
    // Ensure directory exists
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    const jsonPath = path.join(tempDir, filename);
    
    // Write compact JSON
    fs.writeFileSync(jsonPath, JSON.stringify(hierarchyData), 'utf8');
    
    Logger.info(`Saved UI hierarchy JSON to: ${jsonPath}`);
    return jsonPath;
  }

  /**
   * Create slim AI-readable UI hierarchy with index mapping
   */
  private static createSlimUIHierarchy(hierarchyData: any): any {
    const flatElements = hierarchyData.flatElements || [];
    let globalIndex = 0;
    
    // Create index mapping for quick lookup
    const indexMap = new Map();
    flatElements.forEach((element: any, index: number) => {
      indexMap.set(element, index);
    });

    function slim(node: any): any {
      if (node == null || typeof node !== 'object') return node;

      const currentIndex = indexMap.get(node) ?? globalIndex++;
      
      // Extract label from raw field (pattern: label: 'text') or use existing label
      const labelMatch = node.raw?.match(/label: '([^']+)'/);
      const extractedLabel = labelMatch ? labelMatch[1] : undefined;
      
      const slimmed: any = {
        t: node.type,
        l: extractedLabel || node.label || undefined,
        j: currentIndex  // Index reference to full element
      };

      // Frame removed to reduce noise

      // Recurse if children present
      if (Array.isArray(node.children) && node.children.length) {
        slimmed.c = node.children.map(slim);
      }

      // Drop undefined keys to save bytes
      Object.keys(slimmed).forEach(k => slimmed[k] === undefined && delete slimmed[k]);
      return slimmed;
    }

    const slimRoot = slim(hierarchyData.rootElement || hierarchyData);
    
    return {
      parseMethod: 'slim_ui_tree',
      originalElementCount: flatElements.length,
      rootElement: slimRoot
    };
  }

  /**
   * Get UI element details by index from previously exported hierarchy
   */
  public static async xcresultGetUIElement(
    hierarchyJsonPath: string,
    elementIndex: number,
    includeChildren: boolean = false
  ): Promise<McpResult> {
    const fs = await import('fs');
    
    if (!fs.existsSync(hierarchyJsonPath)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `UI hierarchy JSON file not found: ${hierarchyJsonPath}`
      );
    }

    try {
      const hierarchyData = JSON.parse(fs.readFileSync(hierarchyJsonPath, 'utf8'));
      const flatElements = hierarchyData.flatElements || [];
      
      if (elementIndex < 0 || elementIndex >= flatElements.length) {
        throw new McpError(
          ErrorCode.InvalidParams,
          `Element index ${elementIndex} out of range. Available indices: 0-${flatElements.length - 1}`
        );
      }

      const element = flatElements[elementIndex];
      
      // Create result with full element details
      const result: any = {
        index: elementIndex,
        type: element.type,
        label: element.label,
        raw: element.raw,
        indentLevel: element.indentLevel,
        attributes: element.attributes || {}
      };

      if (includeChildren && element.children) {
        result.children = element.children;
      } else if (element.children) {
        result.childrenCount = element.children.length;
        result.hasChildren = true;
      }

      if (element.parent) {
        result.parent = element.parent;
      }

      return {
        content: [{
          type: 'text',
          text: JSON.stringify(result)
        }]
      };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to read UI element: ${errorMessage}`
      );
    }
  }


  /**
   * Find the closest image attachment to a specific timestamp
   */
  private static findClosestImageAttachment(attachments: TestAttachment[], targetTimestamp: number): { attachment: TestAttachment; timeDifference: number } | undefined {
    // Filter to only image attachments
    const imageAttachments = attachments.filter(attachment => {
      const typeId = attachment.uniform_type_identifier || attachment.uniformTypeIdentifier || '';
      const filename = attachment.filename || attachment.name || '';
      
      return typeId.includes('png') || 
             typeId === 'public.png' || 
             typeId.includes('jpeg') ||
             typeId.includes('jpg') ||
             typeId === 'public.jpeg' ||
             filename.toLowerCase().endsWith('.png') ||
             filename.toLowerCase().endsWith('.jpg') ||
             filename.toLowerCase().endsWith('.jpeg');
    });

    if (imageAttachments.length === 0) {
      return undefined;
    }

    // Find the attachment with the smallest time difference
    let closest: { attachment: TestAttachment; timeDifference: number } | undefined;
    let smallestDiff = Infinity;

    for (const attachment of imageAttachments) {
      if (attachment.timestamp !== undefined) {
        const timeDiff = attachment.timestamp - targetTimestamp;
        const absDiff = Math.abs(timeDiff);
        
        if (absDiff < smallestDiff) {
          smallestDiff = absDiff;
          closest = { attachment, timeDifference: timeDiff };
        }
      }
    }

    // If no attachment has a timestamp, return the first image attachment
    if (!closest && imageAttachments.length > 0) {
      const firstImage = imageAttachments[0];
      if (firstImage) {
        return { attachment: firstImage, timeDifference: 0 };
      }
    }
    
    return closest;
  }


  /**
   * Find video attachment by type identifier and filename extension
   */
  private static findVideoAttachment(attachments: TestAttachment[]): TestAttachment | undefined {
    return attachments.find(attachment => {
      const typeId = attachment.uniform_type_identifier || attachment.uniformTypeIdentifier || '';
      const filename = attachment.filename || attachment.name || '';
      
      // Check for video type identifiers or video extensions
      return typeId.includes('mp4') || 
             typeId.includes('quicktime') || 
             typeId === 'public.mpeg-4' ||
             typeId === 'com.apple.quicktime-movie' ||
             filename.toLowerCase().endsWith('.mp4') ||
             filename.toLowerCase().endsWith('.mov');
    });
  }

  /**
   * Export screenshot attachment to temporary directory
   */
  private static async exportScreenshotAttachment(parser: XCResultParser, attachment: TestAttachment): Promise<string> {
    const attachmentId = attachment.payloadId || attachment.payload_uuid || attachment.payloadUUID;
    if (!attachmentId) {
      throw new Error('Attachment does not have a valid ID for export');
    }

    const filename = attachment.filename || attachment.name || `screenshot_${attachmentId}.png`;
    return await parser.exportAttachment(attachmentId, filename);
  }

  /**
   * Extract screenshot from video attachment using ffmpeg at specific timestamp
   */
  private static async extractScreenshotFromVideo(parser: XCResultParser, attachment: TestAttachment, testName: string, timestamp: number): Promise<string> {
    const attachmentId = attachment.payloadId || attachment.payload_uuid || attachment.payloadUUID;
    if (!attachmentId) {
      throw new Error('Video attachment does not have a valid ID for export');
    }

    // Export video to temporary directory
    const videoFilename = attachment.filename || attachment.name || `video_${attachmentId}.mp4`;
    const videoPath = await parser.exportAttachment(attachmentId, videoFilename);
    
    Logger.info(`Exported video to: ${videoPath}`);

    // Generate screenshot path
    const tempDir = join(tmpdir(), 'xcode-mcp-attachments');
    const screenshotFilename = `screenshot_${testName.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.png`;
    const screenshotPath = join(tempDir, screenshotFilename);

    // Extract screenshot using ffmpeg at specific timestamp
    await this.runFFmpeg(videoPath, screenshotPath, timestamp);

    // Verify screenshot was created
    if (!existsSync(screenshotPath)) {
      throw new Error(`Failed to create screenshot at ${screenshotPath}`);
    }

    Logger.info(`Screenshot extracted to: ${screenshotPath}`);
    return screenshotPath;
  }

  /**
   * Run ffmpeg to extract a frame from video as PNG at specific timestamp
   */
  private static async runFFmpeg(videoPath: string, outputPath: string, timestamp: number): Promise<void> {
    return new Promise((resolve, reject) => {
      // Try common ffmpeg paths
      const ffmpegPaths = [
        '/opt/homebrew/bin/ffmpeg',  // Homebrew on Apple Silicon
        '/usr/local/bin/ffmpeg',     // Homebrew on Intel
        'ffmpeg'                     // System PATH
      ];

      let ffmpegPath = 'ffmpeg';
      for (const path of ffmpegPaths) {
        if (existsSync(path)) {
          ffmpegPath = path;
          break;
        }
      }

      Logger.info(`Using ffmpeg at: ${ffmpegPath}`);
      Logger.info(`Extracting frame from: ${videoPath} at ${timestamp}s`);
      Logger.info(`Output path: ${outputPath}`);

      // Extract a frame at the specific timestamp as PNG
      const process = spawn(ffmpegPath, [
        '-i', videoPath,           // Input video
        '-ss', timestamp.toString(), // Seek to specific timestamp
        '-frames:v', '1',          // Extract only 1 frame
        '-q:v', '2',               // High quality
        '-y',                      // Overwrite output file
        outputPath                 // Output PNG file
      ], {
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stderr = '';
      
      process.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      process.on('close', (code) => {
        if (code === 0) {
          Logger.info(`ffmpeg completed successfully`);
          
          // Add a small delay to ensure file is written
          setTimeout(() => {
            if (existsSync(outputPath)) {
              resolve();
            } else {
              reject(new Error(`Screenshot file not found after ffmpeg completion: ${outputPath}`));
            }
          }, 100);
        } else {
          Logger.error(`ffmpeg failed with code ${code}`);
          Logger.error(`ffmpeg stderr: ${stderr}`);
          reject(new Error(`ffmpeg failed with code ${code}: ${stderr}`));
        }
      });

      process.on('error', (error) => {
        Logger.error(`ffmpeg execution error: ${error.message}`);
        reject(new Error(`Failed to run ffmpeg: ${error.message}. Make sure ffmpeg is installed (brew install ffmpeg)`));
      });
    });
  }
}
</file>

<file path="src/utils/XCResultParser.ts">
import { spawn } from 'child_process';
import { existsSync, mkdirSync } from 'fs';
import { stat } from 'fs/promises';
import { tmpdir } from 'os';
import { join } from 'path';
import { Logger } from './Logger.js';
import type { TestAttachment } from '../types/index.js';

// Data models based on XCResultExplorer
export interface TestResultsSummary {
  devicesAndConfigurations: DeviceConfiguration[];
  environmentDescription: string;
  expectedFailures: number;
  failedTests: number;
  finishTime: number;  // Changed from SafeDouble to number
  passedTests: number;
  result: string;
  skippedTests: number;
  startTime: number;   // Changed from SafeDouble to number
  testFailures: TestFailure[];
  title: string;
  totalTestCount: number;
  statistics: any[];   // Added missing field
  topInsights: any[];  // Added missing field
}

export interface DeviceConfiguration {
  device: Device;
  expectedFailures: number;
  failedTests: number;
  passedTests: number;
  skippedTests: number;
  testPlanConfiguration: TestPlanConfiguration;
}

export interface Device {
  architecture: string;
  deviceId: string;
  deviceName: string;
  modelName: string;
  osBuildNumber: string;
  osVersion: string;
  platform: string;
}

export interface TestPlanConfiguration {
  configurationId: string;
  configurationName: string;
}

export interface TestFailure {
  failureText: string;
  targetName: string;
  testIdentifier: number;
  testIdentifierString: string;
  testIdentifierURL: string;
  testName: string;
}

export interface TestResults {
  devices: Device[];
  testNodes: TestNode[];
  testPlanConfigurations: TestPlanConfiguration[];
}

export interface TestNode {
  children?: TestNode[];
  duration?: string;
  durationInSeconds?: number;
  name: string;
  nodeIdentifier?: string;
  nodeIdentifierURL?: string;
  nodeType: string;
  result: string;
}

export interface XCResultAnalysis {
  summary: TestResultsSummary;
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
  passRate: number;
  duration: string;
}

export class XCResultParser {
  private xcresultPath: string;

  constructor(xcresultPath: string) {
    this.xcresultPath = xcresultPath;
  }

  /**
   * Check if xcresult file exists and is readable
   */
  public static isXCResultReadable(xcresultPath: string): boolean {
    if (!existsSync(xcresultPath)) {
      return false;
    }
    
    // Check if we can at least access the Info.plist which should be immediately available
    const infoPlistPath = `${xcresultPath}/Info.plist`;
    return existsSync(infoPlistPath);
  }

  /**
   * Wait for xcresult to be fully written and readable with robust checks
   * Uses proportional timeouts based on test duration - longer tests need more patience
   */
  public static async waitForXCResultReadiness(xcresultPath: string, testDurationMs: number = 1200000): Promise<boolean> {
    // Use test duration as the timeout - longer tests likely produce larger XCResults that need more time
    const timeoutMs = Math.max(testDurationMs, 300000); // Minimum 5 minutes, but scale with test duration
    const startTime = Date.now();
    Logger.info(`Starting robust XCResult readiness check for: ${xcresultPath}`);
    Logger.info(`Total timeout: ${timeoutMs/60000} minutes`);
    
    // Phase 1: Wait for staging folder to disappear - this is CRITICAL 
    // We must not try to read the file while Xcode is still writing to it
    // Based on user insight: we contribute to corruption by reading too early
    Logger.info('Phase 1: Waiting for staging folder to disappear (this indicates Xcode is done writing)...');
    const stagingPath = `${xcresultPath}/Staging`;
    // Use 90% of timeout for staging folder wait since this is the most critical phase
    const stagingTimeout = Math.min(timeoutMs * 0.9, 300000); // 90% of total, max 5 minutes for staging
    
    Logger.info(`Will wait up to ${stagingTimeout/60000} minutes for staging folder to disappear`);
    let lastLogTime = Date.now();
    
    while (Date.now() - startTime < stagingTimeout) {
      if (!existsSync(stagingPath)) {
        Logger.info('Staging folder has disappeared - Xcode finished writing XCResult');
        break;
      }
      
      // Log every 30 seconds to show progress
      if (Date.now() - lastLogTime >= 30000) {
        const elapsed = Math.round((Date.now() - startTime) / 1000);
        Logger.info(`Staging folder still exists after ${elapsed}s - Xcode is still writing XCResult...`);
        lastLogTime = Date.now();
      }
      
      await new Promise(resolve => setTimeout(resolve, 5000)); // Check every 5 seconds for less CPU usage
    }
    
    if (existsSync(stagingPath)) {
      const elapsed = Math.round((Date.now() - startTime) / 60000);
      Logger.warn(`Staging folder still exists after ${elapsed} minutes - Xcode may still be writing`);
      Logger.warn('This might indicate an Xcode issue or very large test results');
      Logger.warn('Proceeding anyway but file may not be complete');
    } else {
      const elapsed = Math.round((Date.now() - startTime) / 1000);
      Logger.info(`Staging folder disappeared after ${elapsed} seconds - ready to proceed`);
    }
    
    // Phase 2: Wait patiently for essential files to appear 
    // Based on user insight: we must not touch xcresulttool until files are completely ready
    Logger.info('Phase 2: Waiting patiently for essential XCResult files to appear...');
    const infoPlistPath = `${xcresultPath}/Info.plist`;
    const databasePath = `${xcresultPath}/database.sqlite3`;
    const dataPath = `${xcresultPath}/Data`;
    
    let lastProgressTime = Date.now();
    while (Date.now() - startTime < timeoutMs) {
      const hasInfoPlist = existsSync(infoPlistPath);
      const hasDatabase = existsSync(databasePath);
      const hasData = existsSync(dataPath);
      
      if (hasInfoPlist && hasDatabase && hasData) {
        Logger.info('All essential XCResult files are present - ready for stabilization check');
        break;
      }
      
      // Log progress every 30 seconds
      if (Date.now() - lastProgressTime >= 30000) {
        Logger.info(`Still waiting for XCResult files - Info.plist: ${hasInfoPlist ? '✓' : '✗'}, database.sqlite3: ${hasDatabase ? '✓' : '✗'}, Data: ${hasData ? '✓' : '✗'}`);
        lastProgressTime = Date.now();
      }
      
      await new Promise(resolve => setTimeout(resolve, 3000)); // Check every 3 seconds
    }
    
    if (!existsSync(infoPlistPath) || !existsSync(databasePath) || !existsSync(dataPath)) {
      const elapsed = Math.round((Date.now() - startTime) / 60000);
      Logger.error(`Essential XCResult files did not appear after ${elapsed} minutes`);
      Logger.error(`This suggests Xcode encountered a serious issue writing the XCResult`);
      return false;
    }
    
    // Phase 3: Critical stabilization check - wait until sizes haven't changed for 10+ seconds
    // This implements user insight: "wait until its size hasnt changed for 10 seconds before trying to read it"
    Logger.info('Phase 3: Waiting for file sizes to stabilize (10+ seconds unchanged)...');
    Logger.info('This is critical - we must not touch xcresulttool until files are completely stable');
    
    let previousSizes: Record<string, number> = {};
    let stableStartTime: number | null = null;
    const requiredStabilitySeconds = 12; // 12 seconds of stability to be extra safe
    
    while (Date.now() - startTime < timeoutMs) {
      try {
        const infoPlistStats = await stat(infoPlistPath);
        const databaseStats = await stat(databasePath);
        const dataStats = await stat(dataPath);
        
        const currentSizes = {
          infoPlist: infoPlistStats.size,
          database: databaseStats.size,
          data: dataStats.size
        };
        
        const sizesMatch = (
          previousSizes.infoPlist === currentSizes.infoPlist &&
          previousSizes.database === currentSizes.database &&
          previousSizes.data === currentSizes.data
        );
        
        if (sizesMatch && Object.keys(previousSizes).length > 0) {
          // Sizes are stable
          if (stableStartTime === null) {
            stableStartTime = Date.now();
            Logger.info(`File sizes stabilized - starting ${requiredStabilitySeconds}s countdown`);
          }
          
          const stableForSeconds = (Date.now() - stableStartTime) / 1000;
          if (stableForSeconds >= requiredStabilitySeconds) {
            Logger.info(`File sizes have been stable for ${Math.round(stableForSeconds)} seconds - ready for xcresulttool`);
            break;
          } else {
            Logger.debug(`File sizes stable for ${Math.round(stableForSeconds)}/${requiredStabilitySeconds} seconds`);
          }
        } else {
          // Sizes changed - reset stability timer
          if (stableStartTime !== null) {
            Logger.info(`File sizes changed - restarting stability check`);
            Logger.debug(`New sizes - Info.plist: ${currentSizes.infoPlist}, database: ${currentSizes.database}, Data: ${currentSizes.data}`);
          }
          stableStartTime = null;
        }
        
        previousSizes = currentSizes;
        await new Promise(resolve => setTimeout(resolve, 2000)); // Check every 2 seconds
      } catch (error) {
        Logger.debug(`Error checking file sizes: ${error}`);
        stableStartTime = null; // Reset on error
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    if (stableStartTime === null || (Date.now() - stableStartTime) / 1000 < requiredStabilitySeconds) {
      const elapsed = Math.round((Date.now() - startTime) / 60000);
      Logger.error(`File sizes did not stabilize within ${elapsed} minutes`);
      Logger.error(`This suggests Xcode is still writing to the XCResult file`);
      return false;
    }
    
    // Add extra safety delay as requested
    Logger.info('Adding extra 5-second safety delay before touching xcresulttool...');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // Phase 4: Attempt to read with retries  
    Logger.info('Phase 4: Attempting to read XCResult with retries...');
    const maxRetries = 14; // Up to 14 retries (total 15 attempts)
    const retryDelay = 15000; // 15 seconds between retries for more patient waiting
    
    for (let attempt = 0; attempt < maxRetries + 1; attempt++) {
      try {
        Logger.info(`Reading attempt ${attempt + 1}/${maxRetries + 1}...`);
        const output = await XCResultParser.runXCResultTool(['get', 'test-results', 'summary', '--path', xcresultPath, '--compact'], 20000);
        // Verify we got actual JSON data, not just empty output
        if (output.trim().length < 10) {
          throw new Error('xcresulttool returned insufficient data');
        }
        // Try to parse the JSON to make sure it's valid
        const parsed = JSON.parse(output);
        if (!parsed.totalTestCount && parsed.totalTestCount !== 0) {
          throw new Error('XCResult data is incomplete - missing totalTestCount');
        }
        Logger.info(`XCResult is ready after ${attempt + 1} attempts: ${xcresultPath}`);
        return true;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        Logger.warn(`Reading attempt ${attempt + 1} failed: ${errorMessage}`);
        
        if (attempt < maxRetries) {
          const timeRemaining = timeoutMs - (Date.now() - startTime);
          if (timeRemaining < retryDelay + 5000) { // Need 5 extra seconds for the actual command
            Logger.warn('Not enough time remaining for another retry');
            break;
          }
          Logger.info(`Waiting ${retryDelay / 1000} seconds before retry...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }
    
    const totalTimeSeconds = (Date.now() - startTime) / 1000;
    Logger.error(`XCResult file failed to become readable after ${maxRetries + 1} attempts over ${totalTimeSeconds} seconds`);
    Logger.error(`This is likely a genuine Xcode bug where the XCResult file remains corrupt after ${Math.round(totalTimeSeconds/60)} minutes of waiting`);
    Logger.error(`XCResult path: ${xcresultPath}`);
    return false;
  }

  /**
   * Get test results summary
   */
  public async getTestResultsSummary(): Promise<TestResultsSummary> {
    Logger.debug(`getTestResultsSummary called for path: ${this.xcresultPath}`);
    Logger.debug(`File exists check: ${existsSync(this.xcresultPath)}`);
    try {
      Logger.debug('About to call runXCResultTool...');
      const output = await XCResultParser.runXCResultTool([
        'get', 'test-results', 'summary',
        '--path', this.xcresultPath,
        '--compact'
      ]);
      
      Logger.debug(`xcresulttool output length: ${output.length} characters`);
      Logger.debug(`xcresulttool output first 200 chars: ${output.substring(0, 200)}`);
      
      const cleanedOutput = this.cleanJSONFloats(output);
      const parsed = JSON.parse(cleanedOutput);
      Logger.debug(`Successfully parsed JSON with keys: ${Object.keys(parsed).join(', ')}`);
      return parsed;
    } catch (error) {
      Logger.error(`Failed to get test results summary from ${this.xcresultPath}: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Cannot read XCResult test summary: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Get detailed test results
   */
  public async getTestResults(): Promise<TestResults> {
    try {
      const output = await XCResultParser.runXCResultTool([
        'get', 'test-results', 'tests',
        '--path', this.xcresultPath,
        '--compact'
      ]);
      
      const cleanedOutput = this.cleanJSONFloats(output);
      return JSON.parse(cleanedOutput);
    } catch (error) {
      Logger.error(`Failed to get detailed test results from ${this.xcresultPath}: ${error instanceof Error ? error.message : String(error)}`);
      throw new Error(`Cannot read XCResult test details: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Analyze xcresult and provide comprehensive summary
   */
  public async analyzeXCResult(): Promise<XCResultAnalysis> {
    try {
      const summary = await this.getTestResultsSummary();
      
      const totalPassRate = summary.totalTestCount > 0 
        ? (summary.passedTests / summary.totalTestCount) * 100 
        : 0;

      const duration = this.formatDuration(summary.finishTime - summary.startTime);

      return {
        summary,
        totalTests: summary.totalTestCount,
        passedTests: summary.passedTests,
        failedTests: summary.failedTests,
        skippedTests: summary.skippedTests,
        passRate: totalPassRate,
        duration
      };
    } catch (error) {
      Logger.error(`Failed to analyze XCResult: ${error instanceof Error ? error.message : String(error)}`);
      // Return a safe fallback analysis
      throw new Error(`XCResult analysis failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Extract individual test details from test results
   */
  public async extractTestDetails(): Promise<{
    failed: Array<{ name: string; id: string }>;
    passed: Array<{ name: string; id: string }>;
    skipped: Array<{ name: string; id: string }>;
  }> {
    try {
      const testResults = await this.getTestResults();
      
      const failedTests: { name: string; id: string }[] = [];
      const passedTests: { name: string; id: string }[] = [];
      const skippedTests: { name: string; id: string }[] = [];
      
      const extractTests = (nodes: any[], depth = 0) => {
        for (const node of nodes) {
          // Only include actual test methods (not test classes/suites)
          if (node.nodeType === 'Test Case' && node.name && node.result) {
            const testInfo = {
              name: node.name,
              id: node.nodeIdentifier || 'unknown'
            };
            
            const result = node.result.toLowerCase();
            if (result === 'failed') {
              failedTests.push(testInfo);
            } else if (result === 'passed') {
              passedTests.push(testInfo);
            } else if (result === 'skipped') {
              skippedTests.push(testInfo);
            }
          }
          
          // Recursively process children
          if (node.children) {
            extractTests(node.children, depth + 1);
          }
        }
      };
      
      extractTests(testResults.testNodes || []);
      
      return {
        failed: failedTests,
        passed: passedTests,
        skipped: skippedTests
      };
    } catch (error) {
      Logger.warn(`Failed to extract test details: ${error}`);
      return {
        failed: [],
        passed: [],
        skipped: []
      };
    }
  }

  /**
   * Format test results summary with optional individual test details
   */
  public async formatTestResultsSummary(
    includeIndividualTests: boolean = false,
    maxPassedTests: number = 5
  ): Promise<string> {
    const analysis = await this.analyzeXCResult();
    
    let message = `📊 Test Results Summary:\n`;
    message += `Result: ${analysis.summary.result === 'Failed' ? '❌' : '✅'} ${analysis.summary.result}\n`;
    message += `Total: ${analysis.totalTests} | Passed: ${analysis.passedTests} ✅ | Failed: ${analysis.failedTests} ❌ | Skipped: ${analysis.skippedTests} ⏭️\n`;
    message += `Pass Rate: ${analysis.passRate.toFixed(1)}%\n`;
    message += `Duration: ${analysis.duration}\n`;
    
    if (includeIndividualTests) {
      const testDetails = await this.extractTestDetails();
      
      if (testDetails.failed.length > 0) {
        message += `\n❌ Failed Tests (${testDetails.failed.length}):\n`;
        testDetails.failed.forEach((test, index) => {
          message += `  ${index + 1}. ${test.name} (ID: ${test.id})\n`;
        });
      }
      
      if (testDetails.skipped.length > 0) {
        message += `\n⏭️ Skipped Tests (${testDetails.skipped.length}):\n`;
        testDetails.skipped.forEach((test, index) => {
          message += `  ${index + 1}. ${test.name} (ID: ${test.id})\n`;
        });
      }
      
      // Only show passed tests if there are failures (to keep output manageable)
      if (testDetails.failed.length > 0 && testDetails.passed.length > 0) {
        message += `\n✅ Passed Tests (${testDetails.passed.length}) - showing first ${maxPassedTests}:\n`;
        testDetails.passed.slice(0, maxPassedTests).forEach((test, index) => {
          message += `  ${index + 1}. ${test.name} (ID: ${test.id})\n`;
        });
        if (testDetails.passed.length > maxPassedTests) {
          message += `  ... and ${testDetails.passed.length - maxPassedTests} more passed tests\n`;
        }
      }
    }
    
    return message;
  }

  /**
   * Get console output for a specific test
   */
  public async getConsoleOutput(testId?: string): Promise<string> {
    try {
      const args = ['get', 'log', '--path', this.xcresultPath, '--type', 'console'];
      if (testId) {
        args.push('--test-id', testId);
      }
      
      const output = await XCResultParser.runXCResultTool(args, 30000);
      return output || 'No console output available';
    } catch (error) {
      return `Error retrieving console output: ${error instanceof Error ? error.message : String(error)}`;
    }
  }

  /**
   * Get test activities for a specific test
   */
  public async getTestActivities(testId: string): Promise<string> {
    try {
      const output = await XCResultParser.runXCResultTool([
        'get', 'test-results', 'activities',
        '--test-id', testId,
        '--path', this.xcresultPath,
        '--compact'
      ], 30000);
      
      return this.formatTestActivities(output);
    } catch (error) {
      return `Error retrieving test activities: ${error instanceof Error ? error.message : String(error)}`;
    }
  }

  /**
   * Get test attachments for a specific test from activities output
   */
  public async getTestAttachments(testId: string): Promise<TestAttachment[]> {
    try {
      Logger.info(`Attempting to get test attachments for test: ${testId}`);
      
      // Give xcresulttool plenty of time to process large files
      const output = await XCResultParser.runXCResultTool([
        'get', 'test-results', 'activities',
        '--test-id', testId,
        '--path', this.xcresultPath,
        '--compact'
      ], 600000); // 10 minutes timeout

      Logger.info(`Successfully retrieved activities data for test: ${testId}`);
      
      const cleanedOutput = this.cleanJSONFloats(output);
      const json = JSON.parse(cleanedOutput);
      const attachments: TestAttachment[] = [];

      // Find test start time for relative timestamp conversion
      const testStartTime = this.findTestStartTime(json);
      
      // Parse attachments from activities
      this.extractAttachmentsFromActivities(json, attachments, undefined, testStartTime);

      Logger.info(`Found ${attachments.length} attachments for test: ${testId}`);
      return attachments;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error(`Failed to get test attachments for ${testId}: ${errorMessage}`);
      
      // If it's a timeout, provide a more specific error
      if (errorMessage.includes('timed out')) {
        throw new Error(`xcresulttool timed out when trying to get attachments for test '${testId}'. This xcresult file may be corrupted, incomplete, or too large. Try with a different test or xcresult file.`);
      }
      
      throw error;
    }
  }

  /**
   * Export an attachment to a temporary directory
   */
  public async exportAttachment(attachmentId: string, filename?: string): Promise<string> {
    // Create temporary directory for attachments
    const tempDir = join(tmpdir(), 'xcode-mcp-attachments');
    if (!existsSync(tempDir)) {
      mkdirSync(tempDir, { recursive: true });
    }

    // Generate output path
    const outputFilename = filename || `attachment_${attachmentId}`;
    const outputPath = join(tempDir, outputFilename);

    // Export attachment using xcresulttool
    await XCResultParser.runXCResultTool([
      'export', 'object',
      '--legacy',
      '--path', this.xcresultPath,
      '--id', attachmentId,
      '--type', 'file',
      '--output-path', outputPath
    ], 30000);

    return outputPath;
  }

  /**
   * Find a test node by ID or index
   */
  public async findTestNode(testIdOrIndex: string): Promise<TestNode | null> {
    const tests = await this.getTestResults();
    
    // Try to find by ID first
    const byId = this.searchTestNodeById(tests.testNodes, testIdOrIndex);
    if (byId) return byId;
    
    // Try to find by index
    const index = parseInt(testIdOrIndex);
    if (!isNaN(index)) {
      return this.findTestNodeByIndex(tests.testNodes, index);
    }
    
    return null;
  }

  /**
   * Format test list with indices
   */
  public async formatTestList(): Promise<string> {
    const analysis = await this.analyzeXCResult();
    const tests = await this.getTestResults();
    
    let output = `🔍 XCResult Analysis - ${this.xcresultPath}\n`;
    output += '='.repeat(80) + '\n\n';
    
    output += `📊 Test Summary\n`;
    output += `Result: ${analysis.summary.result === 'Failed' ? '❌' : '✅'} ${analysis.summary.result}\n`;
    output += `Total: ${analysis.totalTests} | Passed: ${analysis.passedTests} ✅ | Failed: ${analysis.failedTests} ❌ | Skipped: ${analysis.skippedTests} ⏭️\n`;
    output += `Pass Rate: ${analysis.passRate.toFixed(1)}%\n`;
    output += `Duration: ${analysis.duration}\n\n`;
    
    output += `📋 All Tests:\n`;
    output += '-'.repeat(80) + '\n';
    
    let testIndex = 1;
    for (const testNode of tests.testNodes) {
      output += this.formatTestHierarchy(testNode, '', testIndex);
      testIndex = this.countTestCases(testNode) + testIndex;
    }
    
    return output;
  }

  /**
   * Format detailed test information
   */
  public async formatTestDetails(testIdOrIndex: string, includeConsole: boolean = false): Promise<string> {
    const analysis = await this.analyzeXCResult();
    const testNode = await this.findTestNode(testIdOrIndex);
    
    if (!testNode) {
      return `❌ Test '${testIdOrIndex}' not found\n\nRun xcresult_browse without parameters to see all available tests`;
    }
    
    let output = `🔍 Test Details\n`;
    output += '='.repeat(80) + '\n';
    output += `Name: ${testNode.name}\n`;
    output += `ID: ${testNode.nodeIdentifier || 'unknown'}\n`;
    output += `Type: ${testNode.nodeType}\n`;
    output += `Result: ${this.getStatusIcon(testNode.result)} ${testNode.result}\n`;
    
    if (testNode.duration) {
      output += `Duration: ${testNode.duration}\n`;
    }
    output += '\n';
    
    // Show failure details if test failed
    if (testNode.result.toLowerCase().includes('fail')) {
      const failure = analysis.summary.testFailures.find(f => f.testIdentifierString === testNode.nodeIdentifier);
      if (failure) {
        output += `❌ Failure Details:\n`;
        output += `Target: ${failure.targetName}\n`;
        output += `Error: ${failure.failureText}\n\n`;
      }
      
      // Show detailed failure info from test node
      if (testNode.children) {
        output += `📍 Detailed Failure Information:\n`;
        for (const child of testNode.children) {
          if (child.nodeType === 'Failure Message') {
            const parts = child.name.split(': ');
            if (parts.length >= 2) {
              output += `Location: ${parts[0]}\n`;
              output += `Message: ${parts.slice(1).join(': ')}\n`;
            } else {
              output += `Details: ${child.name}\n`;
            }
            output += '\n';
          }
        }
      }
    }
    
    if (includeConsole && testNode.nodeIdentifier) {
      // Get console output and activities
      const consoleOutput = await this.getConsoleOutput(testNode.nodeIdentifier);
      const activities = await this.getTestActivities(testNode.nodeIdentifier);
      
      let consoleSection = `📟 Console Output:\n${consoleOutput}\n\n🔬 Test Activities:\n${activities}\n`;
      
      // Check if console output is very long and should be saved to a file
      const lineCount = consoleSection.split('\n').length;
      const charCount = consoleSection.length;
      
      // If output is longer than 20 lines or 2KB, save to file
      if (lineCount > 20 || charCount > 2000) {
        const { writeFile } = await import('fs/promises');
        const { tmpdir } = await import('os');
        const { join } = await import('path');
        
        // Create a unique filename
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const safeTestName = testNode.name.replace(/[^a-zA-Z0-9]/g, '_');
        const filename = `console_output_${safeTestName}_${timestamp}.txt`;
        const filePath = join(tmpdir(), filename);
        
        await writeFile(filePath, consoleSection, 'utf-8');
        
        const fileSizeKB = Math.round(charCount / 1024);
        
        output += `📟 Console Output:\n`;
        output += `📄 Output saved to file (${lineCount} lines, ${fileSizeKB} KB): ${filePath}\n\n`;
        output += `💡 The console output was too large to display directly. `;
        output += `You can read the file to access the complete console log and test activities.\n`;
      } else {
        output += consoleSection;
      }
    }
    
    return output;
  }

  private static async runXCResultTool(args: string[], timeoutMs: number = 15000): Promise<string> {
    Logger.debug(`Running xcresulttool with args: ${JSON.stringify(['xcresulttool', ...args])}`);
    Logger.debug(`Process environment PATH: ${process.env.PATH?.substring(0, 200)}...`);
    return new Promise((resolve, reject) => {
      let isResolved = false;
      let timeoutHandle: NodeJS.Timeout | null = null;
      
      const childProcess = spawn('xcrun', ['xcresulttool', ...args], {
        stdio: ['pipe', 'pipe', 'pipe'],
        detached: false, // Ensure process is killed with parent
        env: {
          ...process.env,
          PATH: '/usr/bin:/bin:/usr/sbin:/sbin:/Applications/Xcode-16.4.0.app/Contents/Developer/usr/bin:' + (process.env.PATH || '')
        }
      });
      
      let stdout = '';
      let stderr = '';
      
      // Helper function to safely resolve/reject only once
      const safeResolve = (value: string) => {
        if (isResolved) return;
        isResolved = true;
        cleanup();
        resolve(value);
      };
      
      const safeReject = (error: Error) => {
        if (isResolved) return;
        isResolved = true;
        cleanup();
        reject(error);
      };
      
      // Helper function to cleanup resources
      const cleanup = () => {
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
          timeoutHandle = null;
        }
        
        // Forcefully kill the process if it's still running
        if (!childProcess.killed) {
          try {
            // Try graceful termination first
            childProcess.kill('SIGTERM');
            
            // Force kill after 2 seconds if still running
            setTimeout(() => {
              if (!childProcess.killed) {
                try {
                  childProcess.kill('SIGKILL');
                } catch (killError) {
                  Logger.warn('Failed to force kill xcresulttool process:', killError);
                }
              }
            }, 2000);
          } catch (killError) {
            Logger.warn('Failed to kill xcresulttool process:', killError);
          }
        }
        
        // Remove all listeners to prevent memory leaks
        try {
          childProcess.removeAllListeners();
          if (childProcess.stdout) childProcess.stdout.removeAllListeners();
          if (childProcess.stderr) childProcess.stderr.removeAllListeners();
        } catch (listenerError) {
          Logger.warn('Failed to remove process listeners:', listenerError);
        }
      };
      
      // Set up data collection
      childProcess.stdout?.on('data', (data) => {
        stdout += data.toString();
      });
      
      childProcess.stderr?.on('data', (data) => {
        stderr += data.toString();
      });
      
      // Set up timeout with proper cleanup
      timeoutHandle = setTimeout(() => {
        safeReject(new Error(`xcresulttool command timed out after ${timeoutMs}ms`));
      }, timeoutMs);
      
      // Handle process completion
      childProcess.on('close', (code, signal) => {
        Logger.debug(`Process closed: code=${code}, signal=${signal}, stdout.length=${stdout.length}, stderr.length=${stderr.length}`);
        if (code === 0) {
          if (stdout.trim() === '') {
            Logger.warn(`xcresulttool succeeded but returned empty output. stderr: ${stderr}`);
            safeReject(new Error(`xcresulttool exited with code 0 but returned no output. stderr: ${stderr}`));
          } else {
            Logger.debug(`Process succeeded with ${stdout.length} chars of output`);
            safeResolve(stdout);
          }
        } else {
          const errorMsg = signal 
            ? `xcresulttool was killed with signal ${signal}: ${stderr}`
            : `xcresulttool failed with code ${code}: ${stderr}`;
          safeReject(new Error(errorMsg));
        }
      });
      
      // Handle process errors
      childProcess.on('error', (error) => {
        safeReject(new Error(`xcresulttool process error: ${error.message}`));
      });
      
      // Note: Removed exit handler as it fires before close handler and prevents proper output processing
    });
  }

  private cleanJSONFloats(json: string): string {
    // Replace extremely precise floating point numbers with rounded versions
    const pattern = /(\d+\.\d{10,})/g;
    return json.replace(pattern, (match) => {
      const number = parseFloat(match);
      return number.toFixed(6);
    });
  }

  private formatDuration(seconds: number): string {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    if (minutes > 0) {
      return `${minutes}m ${remainingSeconds}s`;
    } else {
      return `${remainingSeconds}s`;
    }
  }

  private formatTestActivities(jsonString: string): string {
    try {
      const json = JSON.parse(jsonString);
      const activities: string[] = [];
      let testStartTime: number | undefined;
      
      if (json.testRuns && Array.isArray(json.testRuns)) {
        for (const testRun of json.testRuns) {
          if (testRun.activities && Array.isArray(testRun.activities)) {
            // Find start time
            for (const activity of testRun.activities) {
              if (activity.title && activity.title.includes('Start Test at') && activity.startTime) {
                testStartTime = activity.startTime;
                break;
              }
            }
            
            // Format all activities
            for (const activity of testRun.activities) {
              this.formatActivity(activity, testStartTime, '', activities);
            }
          }
        }
      }
      
      return activities.length > 0 ? activities.join('\n') : 'No test activities found';
    } catch (error) {
      return `Error parsing test activities: ${error instanceof Error ? error.message : String(error)}`;
    }
  }

  private formatActivity(activity: any, baseTime: number | undefined, indent: string, activities: string[]) {
    if (!activity.title) return;
    
    let formattedLine = indent;
    
    // Add timestamp if available
    if (activity.startTime && baseTime) {
      const relativeTime = activity.startTime - baseTime;
      formattedLine += `t = ${relativeTime.toFixed(2).padStart(8)}s `;
    } else {
      formattedLine += '           ';
    }
    
    // Add failure indicator
    if (activity.isAssociatedWithFailure) {
      formattedLine += '❌ ';
    } else {
      formattedLine += '   ';
    }
    
    formattedLine += activity.title;
    activities.push(formattedLine);
    
    // Recursively format child activities
    if (activity.childActivities && Array.isArray(activity.childActivities)) {
      for (const child of activity.childActivities) {
        this.formatActivity(child, baseTime, indent + '  ', activities);
      }
    }
  }

  private formatTestHierarchy(node: TestNode, prefix: string, startIndex: number): string {
    let output = '';
    let currentIndex = startIndex;
    
    const status = this.getStatusIcon(node.result);
    const duration = node.duration ? ` (${node.duration})` : '';
    const testId = node.nodeIdentifier || 'unknown';
    
    if (node.nodeType === 'Test Case') {
      output += `${prefix}[${currentIndex}] ${status} ${node.name}${duration}\n`;
      output += `${prefix}    ID: ${testId}\n`;
      currentIndex++;
    } else if (node.nodeType === 'Test Suite' || node.nodeType === 'Test Target') {
      const counts = this.calculateTestCounts(node);
      const passRate = counts.total > 0 ? (counts.passed / counts.total * 100) : 0;
      const passRateText = counts.total > 0 ? ` - ${passRate.toFixed(1)}% pass rate (${counts.passed}/${counts.total})` : '';
      output += `${prefix}📁 ${node.name}${passRateText}\n`;
    }
    
    if (node.children) {
      const newPrefix = prefix + (node.nodeType === 'Test Case' ? '  ' : '  ');
      for (const child of node.children) {
        output += this.formatTestHierarchy(child, newPrefix, currentIndex);
        if (child.nodeType === 'Test Case') {
          currentIndex++;
        } else {
          currentIndex += this.countTestCases(child);
        }
      }
    }
    
    return output;
  }

  private calculateTestCounts(node: TestNode): { passed: number; failed: number; total: number } {
    let passed = 0;
    let failed = 0;
    let total = 0;
    
    if (node.nodeType === 'Test Case') {
      total = 1;
      if (node.result.toLowerCase().includes('pass') || node.result.toLowerCase().includes('success')) {
        passed = 1;
      } else if (node.result.toLowerCase().includes('fail')) {
        failed = 1;
      }
    } else if (node.children) {
      for (const child of node.children) {
        const childCounts = this.calculateTestCounts(child);
        passed += childCounts.passed;
        failed += childCounts.failed;
        total += childCounts.total;
      }
    }
    
    return { passed, failed, total };
  }

  private countTestCases(node: TestNode): number {
    if (node.nodeType === 'Test Case') {
      return 1;
    }
    
    let count = 0;
    if (node.children) {
      for (const child of node.children) {
        count += this.countTestCases(child);
      }
    }
    
    return count;
  }

  private searchTestNodeById(nodes: TestNode[], id: string): TestNode | null {
    for (const node of nodes) {
      if (node.nodeIdentifier === id) {
        return node;
      }
      if (node.children) {
        const found = this.searchTestNodeById(node.children, id);
        if (found) return found;
      }
    }
    return null;
  }

  private findTestNodeByIndex(nodes: TestNode[], targetIndex: number): TestNode | null {
    let currentIndex = 1;
    
    const search = (nodes: TestNode[]): TestNode | null => {
      for (const node of nodes) {
        if (node.nodeType === 'Test Case') {
          if (currentIndex === targetIndex) {
            return node;
          }
          currentIndex++;
        }
        
        if (node.children) {
          const found = search(node.children);
          if (found) return found;
        }
      }
      return null;
    };
    
    return search(nodes);
  }

  private getStatusIcon(result: string): string {
    const lowerResult = result.toLowerCase();
    if (lowerResult.includes('pass') || lowerResult.includes('success')) {
      return '✅';
    } else if (lowerResult.includes('fail')) {
      return '❌';
    } else if (lowerResult.includes('skip')) {
      return '⏭️';
    } else {
      return '❓';
    }
  }

  /**
   * Extract attachments from activities JSON recursively
   */
  private extractAttachmentsFromActivities(json: any, attachments: TestAttachment[], parentTimestamp?: number, testStartTime?: number): void {
    if (!json) return;

    // Extract timestamp from current activity if available
    let currentTimestamp = parentTimestamp;
    if (json.timestamp && !isNaN(json.timestamp)) {
      currentTimestamp = json.timestamp;
    }

    // Check if current object has attachments
    if (json.attachments && Array.isArray(json.attachments)) {
      for (const attachment of json.attachments) {
        // Handle various property name variations
        const testAttachment: TestAttachment = {
          payloadId: attachment.payloadId || attachment.payload_uuid || attachment.payloadUUID,
          payload_uuid: attachment.payload_uuid || attachment.payloadId || attachment.payloadUUID,
          payloadUUID: attachment.payloadUUID || attachment.payloadId || attachment.payload_uuid,
          uniform_type_identifier: attachment.uniform_type_identifier || attachment.uniformTypeIdentifier,
          uniformTypeIdentifier: attachment.uniformTypeIdentifier || attachment.uniform_type_identifier,
          filename: attachment.filename || attachment.name,
          name: attachment.name || attachment.filename,
          payloadSize: attachment.payloadSize || attachment.payload_size,
          payload_size: attachment.payload_size || attachment.payloadSize
        };
        
        // Add timestamp if available - prefer attachment's own timestamp, fallback to current activity timestamp
        if (attachment.timestamp !== undefined && !isNaN(attachment.timestamp)) {
          // Convert absolute timestamp to relative timestamp from test start
          if (testStartTime !== undefined) {
            testAttachment.timestamp = attachment.timestamp - testStartTime;
          } else {
            testAttachment.timestamp = attachment.timestamp;
          }
        } else if (currentTimestamp !== undefined) {
          testAttachment.timestamp = currentTimestamp;
        }
        
        attachments.push(testAttachment);
      }
    }

    // Recursively check testRuns
    if (json.testRuns && Array.isArray(json.testRuns)) {
      for (const testRun of json.testRuns) {
        this.extractAttachmentsFromActivities(testRun, attachments, currentTimestamp, testStartTime);
      }
    }

    // Recursively check activities
    if (json.activities && Array.isArray(json.activities)) {
      for (const activity of json.activities) {
        this.extractAttachmentsFromActivities(activity, attachments, currentTimestamp, testStartTime);
      }
    }

    // Recursively check childActivities
    if (json.childActivities && Array.isArray(json.childActivities)) {
      for (const childActivity of json.childActivities) {
        this.extractAttachmentsFromActivities(childActivity, attachments, currentTimestamp, testStartTime);
      }
    }
  }

  /**
   * Find the test start time from the activities JSON to enable relative timestamp calculation
   */
  private findTestStartTime(json: any): number | undefined {
    // Look for the earliest startTime in the test activities
    let earliestStartTime: number | undefined;

    const findEarliestTime = (obj: any): void => {
      if (!obj) return;
      
      // Check current object for startTime
      if (obj.startTime !== undefined && !isNaN(obj.startTime)) {
        if (earliestStartTime === undefined || obj.startTime < earliestStartTime) {
          earliestStartTime = obj.startTime;
        }
      }
      
      // Recursively check nested structures
      if (obj.testRuns && Array.isArray(obj.testRuns)) {
        obj.testRuns.forEach(findEarliestTime);
      }
      if (obj.activities && Array.isArray(obj.activities)) {
        obj.activities.forEach(findEarliestTime);
      }
      if (obj.childActivities && Array.isArray(obj.childActivities)) {
        obj.childActivities.forEach(findEarliestTime);
      }
    };

    findEarliestTime(json);
    return earliestStartTime;
  }
}
</file>

<file path="src/XcodeServer.ts">
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import {
  CallToolRequestSchema,
  ErrorCode,
  ListToolsRequestSchema,
  McpError,
  CallToolResult,
} from '@modelcontextprotocol/sdk/types.js';
import { BuildTools } from './tools/BuildTools.js';
import { ProjectTools } from './tools/ProjectTools.js';
import { InfoTools } from './tools/InfoTools.js';
import { XCResultTools } from './tools/XCResultTools.js';
import { PathValidator } from './utils/PathValidator.js';
import { EnvironmentValidator } from './utils/EnvironmentValidator.js';
import { Logger } from './utils/Logger.js';
import type { 
  EnvironmentValidation, 
  ToolLimitations, 
  McpResult
} from './types/index.js';


export class XcodeServer {
  public server: Server;
  public currentProjectPath: string | null = null;
  private environmentValidation: EnvironmentValidation | null = null;
  private isValidated = false;
  private canOperateInDegradedMode = false;

  constructor() {
    this.server = new Server(
      {
        name: 'xcode-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
  }

  /**
   * Validates the environment and sets up the server accordingly
   */
  public async validateEnvironment(): Promise<EnvironmentValidation> {
    if (this.isValidated && this.environmentValidation) {
      return this.environmentValidation;
    }

    try {
      this.environmentValidation = await EnvironmentValidator.validateEnvironment();
      this.isValidated = true;
      this.canOperateInDegradedMode = this.environmentValidation.overall.canOperateInDegradedMode;

      // Log validation results
      const validationStatus = this.environmentValidation.overall.valid ? 'PASSED' : 
        this.canOperateInDegradedMode ? 'DEGRADED' : 'FAILED';
      Logger.info('Environment Validation:', validationStatus);

      if (!this.environmentValidation.overall.valid) {
        Logger.warn('Environment issues detected:');
        [...this.environmentValidation.overall.criticalFailures, 
         ...this.environmentValidation.overall.nonCriticalFailures].forEach(component => {
          const result = this.environmentValidation![component];
          if (result && 'valid' in result) {
            const validationResult = result as import('./types/index.js').EnvironmentValidationResult;
            Logger.warn(`  ${component}: ${validationResult.message || 'Status unknown'}`);
          }
        });
      }

      return this.environmentValidation;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      Logger.error('Environment validation failed:', errorMessage);
      // Create minimal validation result for graceful degradation
      this.environmentValidation = {
        overall: { 
          valid: false, 
          canOperateInDegradedMode: false,
          criticalFailures: ['validation'],
          nonCriticalFailures: []
        }
      };
      this.isValidated = true;
      return this.environmentValidation;
    }
  }

  /**
   * Checks if a tool operation should be blocked due to environment issues
   */
  public async validateToolOperation(toolName: string): Promise<McpResult | null> {
    // Health check tool should never be blocked
    if (toolName === 'xcode_health_check') {
      return null;
    }

    const validation = await this.validateEnvironment();
    
    if (validation.overall.valid) {
      return null; // All good
    }

    // Check for critical failures that prevent all operations
    if (!validation.overall.canOperateInDegradedMode) {
      const criticalFailures = validation.overall.criticalFailures
        .map(component => {
          const result = validation[component];
          if (result && 'valid' in result) {
            const validationResult = result as import('./types/index.js').EnvironmentValidationResult;
            return validationResult.message || 'Unknown failure';
          }
          return 'Unknown failure';
        })
        .filter(Boolean)
        .join(', ');
      
      return {
        content: [{
          type: 'text',
          text: `❌ Cannot execute ${toolName}: Critical environment failures detected.\n\n${criticalFailures}\n\nPlease run the 'xcode_health_check' tool for detailed recovery instructions.`
        }]
      };
    }

    // Check for specific tool limitations in degraded mode
    const limitations = this.getToolLimitations(toolName, validation);
    if (limitations.blocked) {
      return {
        content: [{
          type: 'text',
          text: `❌ Cannot execute ${toolName}: ${limitations.reason}\n\nRecovery instructions:\n${limitations.instructions?.map(i => `• ${i}`).join('\n') || ''}`
        }]
      };
    }

    // Issue warning for degraded functionality but allow operation
    if (limitations.degraded) {
      Logger.warn(`${toolName} operating in degraded mode - ${limitations.reason}`);
    }

    return null; // Operation can proceed
  }

  /**
   * Determines tool limitations based on environment validation
   */
  private getToolLimitations(toolName: string, validation: EnvironmentValidation): ToolLimitations {
    // Health check tool should never be limited
    if (toolName === 'xcode_health_check') {
      return { blocked: false, degraded: false };
    }

    const buildTools = ['xcode_build', 'xcode_test', 'xcode_run', 'xcode_debug', 'xcode_clean'];
    const xcodeTools = [...buildTools, 'xcode_open_project', 'xcode_get_schemes', 'xcode_set_active_scheme', 
                       'xcode_get_run_destinations', 'xcode_get_workspace_info', 'xcode_get_projects'];
    const xcresultTools = ['xcresult_browse', 'xcresult_browser_get_console', 'xcresult_summary', 'xcresult_get_screenshot', 'xcresult_get_ui_hierarchy', 'xcresult_get_ui_element', 'xcresult_list_attachments', 'xcresult_export_attachment'];

    // Check Xcode availability
    if (xcodeTools.includes(toolName) && !validation.xcode?.valid) {
      return {
        blocked: true,
        degraded: false,
        reason: 'Xcode is not properly installed or accessible',
        instructions: validation.xcode?.recoveryInstructions || [
          'Install Xcode from the Mac App Store',
          'Launch Xcode once to complete installation'
        ]
      };
    }

    // Check osascript availability  
    if (xcodeTools.includes(toolName) && !validation.osascript?.valid) {
      return {
        blocked: true,
        degraded: false,
        reason: 'JavaScript for Automation (JXA) is not available',
        instructions: validation.osascript?.recoveryInstructions || [
          'This tool requires macOS',
          'Ensure osascript is available'
        ]
      };
    }

    // Build tools have additional dependencies and warnings
    if (buildTools.includes(toolName)) {
      if (!validation.xclogparser?.valid) {
        return {
          blocked: false,
          degraded: true,
          reason: 'XCLogParser not available - build results will have limited detail',
          instructions: validation.xclogparser?.recoveryInstructions || [
            'Install XCLogParser with: brew install xclogparser'
          ]
        };
      }

      if (!validation.permissions?.valid && 
          !validation.permissions?.degradedMode?.available) {
        return {
          blocked: true,
          degraded: false,
          reason: 'Automation permissions not granted',
          instructions: validation.permissions?.recoveryInstructions || [
            'Grant automation permissions in System Preferences'
          ]
        };
      }
    }

    // XCResult tools only need xcresulttool (part of Xcode Command Line Tools)
    if (xcresultTools.includes(toolName)) {
      // Check if we can run xcresulttool - this is included with Xcode Command Line Tools
      if (!validation.xcode?.valid) {
        return {
          blocked: true,
          degraded: false,
          reason: 'XCResult tools require Xcode Command Line Tools for xcresulttool',
          instructions: [
            'Install Xcode Command Line Tools: xcode-select --install',
            'Or install full Xcode from the Mac App Store'
          ]
        };
      }
    }

    return { blocked: false, degraded: false };
  }

  /**
   * Enhances error messages with configuration guidance
   */
  public async enhanceErrorWithGuidance(error: Error | { message?: string }, _toolName: string): Promise<string | null> {
    const errorMessage = error.message || error.toString();
    
    // Import ErrorHelper for common error patterns
    const { ErrorHelper } = await import('./utils/ErrorHelper.js');
    const commonError = ErrorHelper.parseCommonErrors(error as Error);
    if (commonError) {
      return commonError;
    }

    // Additional configuration-specific error patterns
    if (errorMessage.includes('command not found')) {
      if (errorMessage.includes('xclogparser')) {
        return `❌ XCLogParser not found\n\n💡 To fix this:\n• Install XCLogParser: brew install xclogparser\n• Or download from: https://github.com/MobileNativeFoundation/XCLogParser\n\nNote: Build operations will work but with limited error details.`;
      }
      if (errorMessage.includes('osascript')) {
        return `❌ macOS scripting tools not available\n\n💡 This indicates a critical system issue:\n• This MCP server requires macOS\n• Ensure you're running on a Mac with system tools available\n• Try restarting your terminal`;
      }
    }

    if (errorMessage.includes('No such file or directory')) {
      if (errorMessage.includes('Xcode.app')) {
        return `❌ Xcode application not found\n\n💡 To fix this:\n• Install Xcode from the Mac App Store\n• Ensure Xcode is in /Applications/Xcode.app\n• Launch Xcode once to complete installation`;
      }
    }

    // Only convert actual operation timeouts, not build errors containing 'timeout:' or transport errors
    if ((errorMessage.includes(' timeout') || errorMessage.includes('timed out') || errorMessage.includes('timeout after')) && 
        !errorMessage.includes('Body Timeout Error') &&
        !errorMessage.includes('Transport error') &&
        !errorMessage.includes('SSE error') &&
        !errorMessage.includes('terminated') &&
        !errorMessage.includes("'timeout:'") &&
        !errorMessage.includes("timeout:' in call") &&
        !errorMessage.includes('argument label') &&
        !errorMessage.includes('TEST BUILD FAILED')) {
      return `❌ Operation timed out\n\n💡 This might indicate:\n• Xcode is not responding (try restarting Xcode)\n• System performance issues\n• Large project taking longer than expected\n• Network issues if downloading dependencies`;
    }

    return null; // No specific guidance available
  }

  private setupToolHandlers(): void {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'xcode_open_project',
            description: 'Open an Xcode project or workspace',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_close_project',
            description: 'Close the currently active Xcode project or workspace (automatically stops any running actions first)',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_build',
            description: 'Build a specific Xcode project or workspace with the specified scheme. If destination is not provided, uses the currently active destination.',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file to build (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
                scheme: {
                  type: 'string',
                  description: 'Name of the scheme to build',
                },
                destination: {
                  type: 'string',
                  description: 'Build destination (optional - uses active destination if not provided)',
                },
              },
              required: ['xcodeproj', 'scheme'],
            },
          },
          {
            name: 'xcode_get_schemes',
            description: 'Get list of available schemes for a specific project',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_set_active_scheme',
            description: 'Set the active scheme for a specific project',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
                schemeName: {
                  type: 'string',
                  description: 'Name of the scheme to activate',
                },
              },
              required: ['xcodeproj', 'schemeName'],
            },
          },
          {
            name: 'xcode_clean',
            description: 'Clean the build directory for a specific project',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_test',
            description: 'Run tests for a specific project',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
                commandLineArguments: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Additional command line arguments',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_run',
            description: 'Run a specific project with the specified scheme',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
                scheme: {
                  type: 'string',
                  description: 'Name of the scheme to run',
                },
                commandLineArguments: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Additional command line arguments',
                },
              },
              required: ['xcodeproj', 'scheme'],
            },
          },
          {
            name: 'xcode_debug',
            description: 'Start debugging session for a specific project',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
                scheme: {
                  type: 'string',
                  description: 'Scheme name (optional)',
                },
                skipBuilding: {
                  type: 'boolean',
                  description: 'Whether to skip building',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_stop',
            description: 'Stop the current scheme action',
            inputSchema: {
              type: 'object',
              properties: {},
            },
          },
          {
            name: 'find_xcresults',
            description: 'Find all XCResult files for a specific project with timestamps and file information',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_get_run_destinations',
            description: 'Get list of available run destinations for a specific project',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_get_workspace_info',
            description: 'Get information about a specific workspace',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_get_projects',
            description: 'Get list of projects in a specific workspace',
            inputSchema: {
              type: 'object',
              properties: {
                xcodeproj: {
                  type: 'string',
                  description: 'Absolute path to the .xcodeproj file (or .xcworkspace if available) - e.g., /path/to/project.xcodeproj',
                },
              },
              required: ['xcodeproj'],
            },
          },
          {
            name: 'xcode_open_file',
            description: 'Open a file in Xcode',
            inputSchema: {
              type: 'object',
              properties: {
                filePath: {
                  type: 'string',
                  description: 'Absolute path to the file to open',
                },
                lineNumber: {
                  type: 'number',
                  description: 'Optional line number to navigate to',
                },
              },
              required: ['filePath'],
            },
          },
          {
            name: 'xcode_health_check',
            description: 'Perform a comprehensive health check of the XcodeMCP environment and configuration',
            inputSchema: {
              type: 'object',
              properties: {},
            },
          },
          {
            name: 'xcresult_browse',
            description: 'Browse XCResult files - list all tests or show details for a specific test. Returns comprehensive test results including pass/fail status, failure details, and browsing instructions. Large console output (>20 lines or >2KB) is automatically saved to a temporary file.',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
                test_id: {
                  type: 'string',
                  description: 'Optional test ID or index number to show details for a specific test',
                },
                include_console: {
                  type: 'boolean',
                  description: 'Whether to include console output and test activities (only used with test_id)',
                  default: false,
                },
              },
              required: ['xcresult_path'],
            },
          },
          {
            name: 'xcresult_browser_get_console',
            description: 'Get console output and test activities for a specific test in an XCResult file. Large output (>20 lines or >2KB) is automatically saved to a temporary file.',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
                test_id: {
                  type: 'string',
                  description: 'Test ID or index number to get console output for',
                },
              },
              required: ['xcresult_path', 'test_id'],
            },
          },
          {
            name: 'xcresult_summary',
            description: 'Get a quick summary of test results from an XCResult file',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
              },
              required: ['xcresult_path'],
            },
          },
          {
            name: 'xcresult_get_screenshot',
            description: 'Get screenshot from a failed test at specific timestamp - extracts frame from video attachment using ffmpeg',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
                test_id: {
                  type: 'string',
                  description: 'Test ID or index number to get screenshot for',
                },
                timestamp: {
                  type: 'number',
                  description: 'Timestamp in seconds when to extract the screenshot. WARNING: Use a timestamp BEFORE the failure (e.g., if failure is at 30.71s, use 30.69s) as failure timestamps often show the home screen after the app has crashed or reset.',
                },
              },
              required: ['xcresult_path', 'test_id', 'timestamp'],
            },
          },
          {
            name: 'xcresult_get_ui_hierarchy',
            description: 'Get UI hierarchy attachment from test. Returns raw accessibility tree (best for AI), slim AI-readable JSON (default), or full JSON.',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
                test_id: {
                  type: 'string',
                  description: 'Test ID or index number to get UI hierarchy for',
                },
                timestamp: {
                  type: 'number',
                  description: 'Optional timestamp in seconds to find the closest UI snapshot. If not provided, uses the first available UI snapshot.',
                },
                full_hierarchy: {
                  type: 'boolean',
                  description: 'Set to true to get the full hierarchy (several MB). Default is false for AI-readable slim version.',
                },
                raw_format: {
                  type: 'boolean',
                  description: 'Set to true to get the raw accessibility tree text (most AI-friendly). Default is false for JSON format.',
                },
              },
              required: ['xcresult_path', 'test_id'],
            },
          },
          {
            name: 'xcresult_get_ui_element',
            description: 'Get full details of a specific UI element by index from a previously exported UI hierarchy JSON file',
            inputSchema: {
              type: 'object',
              properties: {
                hierarchy_json_path: {
                  type: 'string',
                  description: 'Absolute path to the UI hierarchy JSON file (the full version saved by xcresult_get_ui_hierarchy)',
                },
                element_index: {
                  type: 'number',
                  description: 'Index of the element to get details for (the "j" value from the slim hierarchy)',
                },
                include_children: {
                  type: 'boolean',
                  description: 'Whether to include children in the response. Defaults to false.',
                },
              },
              required: ['hierarchy_json_path', 'element_index'],
            },
          },
          {
            name: 'xcresult_list_attachments',
            description: 'List all attachments for a specific test - shows attachment names, types, and indices for export',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
                test_id: {
                  type: 'string',
                  description: 'Test ID or index number to list attachments for',
                },
              },
              required: ['xcresult_path', 'test_id'],
            },
          },
          {
            name: 'xcresult_export_attachment',
            description: 'Export a specific attachment by index - can convert App UI hierarchy attachments to JSON',
            inputSchema: {
              type: 'object',
              properties: {
                xcresult_path: {
                  type: 'string',
                  description: 'Absolute path to the .xcresult file',
                },
                test_id: {
                  type: 'string',
                  description: 'Test ID or index number that contains the attachment',
                },
                attachment_index: {
                  type: 'number',
                  description: 'Index number of the attachment to export (1-based, from xcresult_list_attachments)',
                },
                convert_to_json: {
                  type: 'boolean',
                  description: 'If true and attachment is an App UI hierarchy, convert to JSON format',
                },
              },
              required: ['xcresult_path', 'test_id', 'attachment_index'],
            },
          },
        ],
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request: any): Promise<CallToolResult> => {
      const { name, arguments: args = {} } = request.params as { name: string; arguments?: Record<string, unknown> };

      try {
        // Handle health check tool first (no environment validation needed)
        if (name === 'xcode_health_check') {
          const report = await EnvironmentValidator.createHealthCheckReport();
          return { content: [{ type: 'text', text: report }] };
        }

        // Validate environment for all other tools
        const validationError = await this.validateToolOperation(name);
        if (validationError) {
          return validationError;
        }

        switch (name) {
          case 'xcode_open_project':
            if (!args.xcodeproj) {
              throw new McpError(
                ErrorCode.InvalidParams,
                `Missing required parameter: xcodeproj\n\n💡 Expected: absolute path to .xcodeproj or .xcworkspace file`
              );
            }
            const result = await ProjectTools.openProject(args.xcodeproj as string);
            if (result && 'content' in result && result.content?.[0] && 'text' in result.content[0]) {
              const textContent = result.content[0];
              if (textContent.type === 'text' && typeof textContent.text === 'string') {
                if (!textContent.text.includes('Error') && !textContent.text.includes('does not exist')) {
                  this.currentProjectPath = args.xcodeproj as string;
                }
              }
            }
            return result;
          case 'xcode_close_project':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            try {
              const validationError = PathValidator.validateProjectPath(args.xcodeproj as string);
              if (validationError) return validationError;
              
              const closeResult = await ProjectTools.closeProject();
              this.currentProjectPath = null;
              return closeResult;
            } catch (closeError) {
              // Ensure close project never crashes the server
              Logger.error('Close project error (handled):', closeError);
              this.currentProjectPath = null;
              return { content: [{ type: 'text', text: 'Project close attempted - may have completed with dialogs' }] };
            }
          case 'xcode_build':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            if (!args.scheme) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: scheme`);
            }
            return await BuildTools.build(
              args.xcodeproj as string, 
              args.scheme as string, 
              (args.destination as string) || null, 
              this.openProject.bind(this)
            );
          case 'xcode_clean':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            return await BuildTools.clean(args.xcodeproj as string, this.openProject.bind(this));
          case 'xcode_test':
            if (!args.xcodeproj) {
              throw new McpError(
                ErrorCode.InvalidParams,
                `Missing required parameter: xcodeproj\n\n💡 To fix this:\n• Specify the absolute path to your .xcodeproj or .xcworkspace file using the "xcodeproj" parameter\n• Example: /Users/username/MyApp/MyApp.xcodeproj\n• You can drag the project file from Finder to get the path`
              );
            }
            return await BuildTools.test(
              args.xcodeproj as string, 
              (args.commandLineArguments as string[]) || [], 
              this.openProject.bind(this)
            );
          case 'xcode_run':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            if (!args.scheme) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: scheme`);
            }
            return await BuildTools.run(
              args.xcodeproj as string, 
              args.scheme as string,
              (args.commandLineArguments as string[]) || [], 
              this.openProject.bind(this)
            );
          case 'xcode_debug':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            if (!args.scheme) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: scheme`);
            }
            return await BuildTools.debug(
              args.xcodeproj as string, 
              args.scheme as string, 
              args.skipBuilding as boolean, 
              this.openProject.bind(this)
            );
          case 'xcode_stop':
            return await BuildTools.stop();
          case 'find_xcresults':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            return await BuildTools.findXCResults(args.xcodeproj as string);
          case 'xcode_get_schemes':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            return await ProjectTools.getSchemes(args.xcodeproj as string, this.openProject.bind(this));
          case 'xcode_get_run_destinations':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            return await ProjectTools.getRunDestinations(args.xcodeproj as string, this.openProject.bind(this));
          case 'xcode_set_active_scheme':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            if (!args.schemeName) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: schemeName`);
            }
            return await ProjectTools.setActiveScheme(
              args.xcodeproj as string, 
              args.schemeName as string, 
              this.openProject.bind(this)
            );
          case 'xcode_get_workspace_info':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            return await InfoTools.getWorkspaceInfo(args.xcodeproj as string, this.openProject.bind(this));
          case 'xcode_get_projects':
            if (!args.xcodeproj) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcodeproj`);
            }
            return await InfoTools.getProjects(args.xcodeproj as string, this.openProject.bind(this));
          case 'xcode_open_file':
            if (!args.filePath) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: filePath`);
            }
            return await InfoTools.openFile(args.filePath as string, args.lineNumber as number);
          case 'xcresult_browse':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            return await XCResultTools.xcresultBrowse(
              args.xcresult_path as string,
              args.test_id as string | undefined,
              args.include_console as boolean || false
            );
          case 'xcresult_browser_get_console':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            if (!args.test_id) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: test_id`);
            }
            return await XCResultTools.xcresultBrowserGetConsole(
              args.xcresult_path as string,
              args.test_id as string
            );
          case 'xcresult_summary':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            return await XCResultTools.xcresultSummary(args.xcresult_path as string);
          case 'xcresult_get_screenshot':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            if (!args.test_id) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: test_id`);
            }
            if (args.timestamp === undefined) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: timestamp`);
            }
            return await XCResultTools.xcresultGetScreenshot(
              args.xcresult_path as string,
              args.test_id as string,
              args.timestamp as number
            );
          case 'xcresult_get_ui_hierarchy':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            if (!args.test_id) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: test_id`);
            }
            return await XCResultTools.xcresultGetUIHierarchy(
              args.xcresult_path as string,
              args.test_id as string,
              args.timestamp as number | undefined,
              args.full_hierarchy as boolean | undefined,
              args.raw_format as boolean | undefined
            );
          case 'xcresult_get_ui_element':
            if (!args.hierarchy_json_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: hierarchy_json_path`);
            }
            if (args.element_index === undefined) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: element_index`);
            }
            return await XCResultTools.xcresultGetUIElement(
              args.hierarchy_json_path as string,
              args.element_index as number,
              args.include_children as boolean | undefined
            );
          case 'xcresult_list_attachments':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            if (!args.test_id) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: test_id`);
            }
            return await XCResultTools.xcresultListAttachments(
              args.xcresult_path as string,
              args.test_id as string
            );
          case 'xcresult_export_attachment':
            if (!args.xcresult_path) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: xcresult_path`);
            }
            if (!args.test_id) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: test_id`);
            }
            if (args.attachment_index === undefined) {
              throw new McpError(ErrorCode.InvalidParams, `Missing required parameter: attachment_index`);
            }
            return await XCResultTools.xcresultExportAttachment(
              args.xcresult_path as string,
              args.test_id as string,
              args.attachment_index as number,
              args.convert_to_json as boolean | undefined
            );
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${name}`
            );
        }
      } catch (error) {
        // Enhanced error handling that doesn't crash the server
        Logger.error(`Tool execution error for ${name}:`, error);
        
        // Check if it's a configuration-related error that we can provide guidance for
        const enhancedError = await this.enhanceErrorWithGuidance(error as Error, name);
        if (enhancedError) {
          return { content: [{ type: 'text', text: enhancedError }] };
        }

        // For other errors, provide a helpful message but don't crash
        const errorMessage = error instanceof McpError ? error.message : 
          error instanceof Error ? `Tool execution failed: ${error.message}` : 
          `Tool execution failed: ${String(error)}`;
        
        return { 
          content: [{ 
            type: 'text', 
            text: `❌ ${name} failed: ${errorMessage}\n\n💡 If this persists, try running 'xcode_health_check' to diagnose potential configuration issues.`
          }] 
        };
      }
    });
  }

  public async openProject(projectPath: string): Promise<McpResult> {
    const result = await ProjectTools.openProjectAndWaitForLoad(projectPath);
    if (result && 'content' in result && result.content?.[0] && 'text' in result.content[0]) {
      const textContent = result.content[0];
      if (textContent.type === 'text' && typeof textContent.text === 'string') {
        if (!textContent.text.includes('❌') && !textContent.text.includes('Error') && !textContent.text.includes('does not exist')) {
          this.currentProjectPath = projectPath;
        }
      }
    }
    return result;
  }

  public async executeJXA(script: string): Promise<string> {
    const { JXAExecutor } = await import('./utils/JXAExecutor.js');
    return JXAExecutor.execute(script);
  }

  public validateProjectPath(projectPath: string): McpResult | null {
    return PathValidator.validateProjectPath(projectPath);
  }

  public async findProjectDerivedData(projectPath: string): Promise<string | null> {
    const { BuildLogParser } = await import('./utils/BuildLogParser.js');
    return BuildLogParser.findProjectDerivedData(projectPath);
  }

  public async getLatestBuildLog(projectPath: string) {
    const { BuildLogParser } = await import('./utils/BuildLogParser.js');
    return BuildLogParser.getLatestBuildLog(projectPath);
  }

  public async parseBuildLog(logPath: string, retryCount?: number, maxRetries?: number) {
    const { BuildLogParser } = await import('./utils/BuildLogParser.js');
    return BuildLogParser.parseBuildLog(logPath, retryCount, maxRetries);
  }

  public async canParseLog(logPath: string): Promise<boolean> {
    const { BuildLogParser } = await import('./utils/BuildLogParser.js');
    return BuildLogParser.canParseLog(logPath);
  }

  public async getCustomDerivedDataLocationFromXcodePreferences(): Promise<string | null> {
    const { BuildLogParser } = await import('./utils/BuildLogParser.js');
    return BuildLogParser.getCustomDerivedDataLocationFromXcodePreferences();
  }
}
</file>

<file path="package.json">
{
  "name": "xcodemcp",
  "version": "1.8.0",
  "description": "Model Context Protocol server for Xcode build automation and log parsing",
  "main": "dist/index.js",
  "type": "module",
  "bin": {
    "xcodemcp": "dist/index.js"
  },
  "files": [
    "dist/**/*",
    "package.json",
    "README.md"
  ],
  "scripts": {
    "build": "tsc",
    "build:watch": "tsc --watch",
    "clean": "rm -rf dist",
    "start": "node dist/index.js",
    "dev": "npm run build:watch & node --watch dist/index.js",
    "dev:ts": "tsx --watch src/index.ts",
    "prepare": "npm run build",
    "prepublishOnly": "npm run clean && npm run build",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.6.0",
    "eventsource": "^4.0.0",
    "node-fetch": "^3.3.2"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@vitest/coverage-v8": "^3.2.3",
    "@vitest/ui": "^3.2.3",
    "tsx": "^4.7.0",
    "typescript": "^5.3.0",
    "vitest": "^3.2.3"
  },
  "engines": {
    "node": ">=18"
  },
  "os": [
    "darwin"
  ],
  "keywords": [
    "mcp",
    "xcode",
    "build",
    "automation",
    "ios",
    "macos",
    "swift",
    "xclogparser",
    "model-context-protocol"
  ],
  "author": "Felix Lapalme",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lapfelix/XcodeMCP.git"
  },
  "homepage": "https://github.com/lapfelix/XcodeMCP#readme",
  "bugs": {
    "url": "https://github.com/lapfelix/XcodeMCP/issues"
  }
}
</file>

<file path="src/tools/BuildTools.ts">
import { stat } from 'fs/promises';
import { readdir } from 'fs/promises';
import { join } from 'path';
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { JXAExecutor } from '../utils/JXAExecutor.js';
import { BuildLogParser } from '../utils/BuildLogParser.js';
import { PathValidator } from '../utils/PathValidator.js';
import { ErrorHelper } from '../utils/ErrorHelper.js';
import { ParameterNormalizer } from '../utils/ParameterNormalizer.js';
import { Logger } from '../utils/Logger.js';
import { XCResultParser } from '../utils/XCResultParser.js';
import type { McpResult, OpenProjectCallback } from '../types/index.js';

export class BuildTools {
  public static async build(
    projectPath: string, 
    schemeName: string, 
    destination: string | null = null, 
    openProject: OpenProjectCallback
  ): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    // Normalize the scheme name for better matching
    const normalizedSchemeName = ParameterNormalizer.normalizeSchemeName(schemeName);
    
    const setSchemeScript = `
        (function() {
          const app = Application('Xcode');
          const workspace = app.activeWorkspaceDocument();
          if (!workspace) throw new Error('No active workspace');
          
          const schemes = workspace.schemes();
          const schemeNames = schemes.map(scheme => scheme.name());
          
          // Try exact match first
          let targetScheme = schemes.find(scheme => scheme.name() === ${JSON.stringify(normalizedSchemeName)});
          
          // If not found, try original name
          if (!targetScheme) {
            targetScheme = schemes.find(scheme => scheme.name() === ${JSON.stringify(schemeName)});
          }
          
          if (!targetScheme) {
            throw new Error('Scheme not found. Available: ' + JSON.stringify(schemeNames));
          }
          
          workspace.activeScheme = targetScheme;
          return 'Scheme set to ' + targetScheme.name();
        })()
      `;
      
      try {
        await JXAExecutor.execute(setSchemeScript);
      } catch (error) {
        const enhancedError = ErrorHelper.parseCommonErrors(error as Error);
        if (enhancedError) {
          return { content: [{ type: 'text', text: enhancedError }] };
        }
        
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes('not found')) {
          try {
            // Get available schemes
            const availableSchemes = await this._getAvailableSchemes();
              
            // Try to find a close match with fuzzy matching
            const bestMatch = ParameterNormalizer.findBestMatch(schemeName, availableSchemes);
            let message = `❌ Scheme '${schemeName}' not found\n\nAvailable schemes:\n`;
            
            availableSchemes.forEach(scheme => {
              if (scheme === bestMatch) {
                message += `  • ${scheme} ← Did you mean this?\n`;
              } else {
                message += `  • ${scheme}\n`;
              }
            });
            
            return { content: [{ type: 'text', text: message }] };
          } catch {
            return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Scheme '${schemeName}' not found`, ErrorHelper.getSchemeNotFoundGuidance(schemeName)) }] };
          }
        }
        
        return { content: [{ type: 'text', text: `Failed to set scheme '${schemeName}': ${errorMessage}` }] };
      }

    if (destination) {
      // Normalize the destination name for better matching
      const normalizedDestination = ParameterNormalizer.normalizeDestinationName(destination);
      
      const setDestinationScript = `
        (function() {
          const app = Application('Xcode');
          const workspace = app.activeWorkspaceDocument();
          if (!workspace) throw new Error('No active workspace');
          
          const destinations = workspace.runDestinations();
          const destinationNames = destinations.map(dest => dest.name());
          
          // Try exact match first
          let targetDestination = destinations.find(dest => dest.name() === ${JSON.stringify(normalizedDestination)});
          
          // If not found, try original name
          if (!targetDestination) {
            targetDestination = destinations.find(dest => dest.name() === ${JSON.stringify(destination)});
          }
          
          if (!targetDestination) {
            throw new Error('Destination not found. Available: ' + JSON.stringify(destinationNames));
          }
          
          workspace.activeRunDestination = targetDestination;
          return 'Destination set to ' + targetDestination.name();
        })()
      `;
      
      try {
        await JXAExecutor.execute(setDestinationScript);
      } catch (error) {
        const enhancedError = ErrorHelper.parseCommonErrors(error as Error);
        if (enhancedError) {
          return { content: [{ type: 'text', text: enhancedError }] };
        }
        
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes('not found')) {
          try {
            // Extract available destinations from error message if present
            let availableDestinations: string[] = [];
            if (errorMessage.includes('Available:')) {
              const availablePart = errorMessage.split('Available: ')[1];
              // Find the JSON array part
              const jsonMatch = availablePart?.match(/\[.*?\]/);
              if (jsonMatch) {
                try {
                  availableDestinations = JSON.parse(jsonMatch[0]);
                } catch {
                  availableDestinations = await this._getAvailableDestinations();
                }
              }
            } else {
              availableDestinations = await this._getAvailableDestinations();
            }
              
            // Try to find a close match with fuzzy matching
            const bestMatch = ParameterNormalizer.findBestMatch(destination, availableDestinations);
            let guidance = ErrorHelper.getDestinationNotFoundGuidance(destination, availableDestinations);
            
            if (bestMatch && bestMatch !== destination) {
              guidance += `\n• Did you mean '${bestMatch}'?`;
            }
            
            return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Destination '${destination}' not found`, guidance) }] };
          } catch {
            return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Destination '${destination}' not found`, ErrorHelper.getDestinationNotFoundGuidance(destination)) }] };
          }
        }
        
        return { content: [{ type: 'text', text: `Failed to set destination '${destination}': ${errorMessage}` }] };
      }
    }

    const buildScript = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        workspace.build();
        
        return 'Build started';
      })()
    `;
    
    const buildStartTime = Date.now();
    
    try {
      await JXAExecutor.execute(buildScript);
      
      // Check for and handle "replace existing build" alert
      await this._handleReplaceExistingBuildAlert();
    } catch (error) {
      const enhancedError = ErrorHelper.parseCommonErrors(error as Error);
      if (enhancedError) {
        return { content: [{ type: 'text', text: enhancedError }] };
      }
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { content: [{ type: 'text', text: `Failed to start build: ${errorMessage}` }] };
    }

    Logger.info('Waiting for new build log to appear after build start...');
    
    let attempts = 0;
    let newLog = null;
    const initialWaitAttempts = 3600; // 1 hour max to wait for build log

    while (attempts < initialWaitAttempts) {
      const currentLog = await BuildLogParser.getLatestBuildLog(projectPath);
      
      if (currentLog) {
        const logTime = currentLog.mtime.getTime();
        const buildTime = buildStartTime;
        Logger.debug(`Checking log: ${currentLog.path}, log time: ${logTime}, build time: ${buildTime}, diff: ${logTime - buildTime}ms`);
        
        if (logTime > buildTime) {
          newLog = currentLog;
          Logger.info(`Found new build log created after build start: ${newLog.path}`);
          break;
        }
      } else {
        Logger.debug(`No build log found yet, attempt ${attempts + 1}/${initialWaitAttempts}`);
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      attempts++;
    }

    if (!newLog) {
      return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Build started but no new build log appeared within ${initialWaitAttempts} seconds`, ErrorHelper.getBuildLogNotFoundGuidance()) }] };
    }

    Logger.info(`Monitoring build completion for log: ${newLog.path}`);
    
    attempts = 0;
    const maxAttempts = 3600; // 1 hour max for build completion
    let lastLogSize = 0;
    let stableCount = 0;

    while (attempts < maxAttempts) {
      try {
        const logStats = await stat(newLog.path);
        const currentLogSize = logStats.size;
        
        if (currentLogSize === lastLogSize) {
          stableCount++;
          if (stableCount >= 1) {
            Logger.debug(`Log stable for ${stableCount}s, trying to parse...`);
            const results = await BuildLogParser.parseBuildLog(newLog.path);
            Logger.debug(`Parse result has ${results.errors.length} errors, ${results.warnings.length} warnings`);
            const isParseFailure = results.errors.some(error => 
              typeof error === 'string' && error.includes('XCLogParser failed to parse the build log.')
            );
            if (results && !isParseFailure) {
              Logger.info(`Build completed, log parsed successfully: ${newLog.path}`);
              break;
            }
          }
        } else {
          lastLogSize = currentLogSize;
          stableCount = 0;
        }
      } catch (error) {
        const currentLog = await BuildLogParser.getLatestBuildLog(projectPath);
        if (currentLog && currentLog.path !== newLog.path && currentLog.mtime.getTime() > buildStartTime) {
          Logger.debug(`Build log changed to: ${currentLog.path}`);
          newLog = currentLog;
          lastLogSize = 0;
          stableCount = 0;
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      attempts++;
    }

    if (attempts >= maxAttempts) {
      return { content: [{ type: 'text', text: `Build timed out after ${maxAttempts} seconds` }] };
    }
    
    const results = await BuildLogParser.parseBuildLog(newLog.path);
    
    let message = '';
    const schemeInfo = schemeName ? ` for scheme '${schemeName}'` : '';
    const destInfo = destination ? ` and destination '${destination}'` : '';
    
    Logger.info(`Build completed${schemeInfo}${destInfo} - ${results.errors.length} errors, ${results.warnings.length} warnings, status: ${results.buildStatus || 'unknown'}`);
    
    // Handle stopped/interrupted builds
    if (results.buildStatus === 'stopped') {
      message = `⏹️ BUILD INTERRUPTED${schemeInfo}${destInfo}\n\nThe build was stopped or interrupted before completion.\n\n💡 This may happen when:\n  • The build was cancelled manually\n  • Xcode was closed during the build\n  • System resources were exhausted\n\nTry running the build again to complete it.`;
      return { content: [{ type: 'text', text: message }] };
    }
    
    if (results.errors.length > 0) {
      message = `❌ BUILD FAILED${schemeInfo}${destInfo} (${results.errors.length} errors)\n\nERRORS:\n`;
      results.errors.forEach(error => {
        message += `  • ${error}\n`;
        Logger.error('Build error:', error);
      });
      throw new McpError(
        ErrorCode.InternalError,
        message
      );
    } else if (results.warnings.length > 0) {
      message = `⚠️ BUILD COMPLETED WITH WARNINGS${schemeInfo}${destInfo} (${results.warnings.length} warnings)\n\nWARNINGS:\n`;
      results.warnings.forEach(warning => {
        message += `  • ${warning}\n`;
        Logger.warn('Build warning:', warning);
      });
    } else {
      message = `✅ BUILD SUCCESSFUL${schemeInfo}${destInfo}`;
    }

    return { content: [{ type: 'text', text: message }] };
  }

  public static async clean(projectPath: string, openProject: OpenProjectCallback): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const actionResult = workspace.clean();
        
        while (true) {
          if (actionResult.completed()) {
            break;
          }
          delay(0.5);
        }
        
        return \`Clean completed. Result ID: \${actionResult.id()}\`;
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }

  public static async test(
    projectPath: string, 
    commandLineArguments: string[] = [], 
    openProject: OpenProjectCallback
  ): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    // Get initial xcresult files to detect new ones
    const initialXCResults = await this._findXCResultFiles(projectPath);
    const testStartTime = Date.now();
    Logger.info(`Test start time: ${new Date(testStartTime).toISOString()}, found ${initialXCResults.length} initial XCResult files`);

    // Start the test action

    const hasArgs = commandLineArguments && commandLineArguments.length > 0;
    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        ${hasArgs 
          ? `const actionResult = workspace.test({withCommandLineArguments: ${JSON.stringify(commandLineArguments)}});`
          : `const actionResult = workspace.test();`
        }
        
        // Return immediately - we'll monitor the build separately
        return JSON.stringify({ 
          actionId: actionResult.id(),
          message: 'Test started'
        });
      })()
    `;
    
    try {
      const startResult = await JXAExecutor.execute(script);
      const { actionId, message } = JSON.parse(startResult);
      
      Logger.info(`${message} with action ID: ${actionId}`);
      
      // Check for and handle "replace existing build" alert
      await this._handleReplaceExistingBuildAlert();
      
      // Check for build errors with polling approach
      Logger.info('Monitoring for build logs...');
      
      // Poll for build logs for up to 30 seconds
      let foundLogs = false;
      for (let i = 0; i < 6; i++) {
        await new Promise(resolve => setTimeout(resolve, 5000));
        const logs = await BuildLogParser.getRecentBuildLogs(projectPath, testStartTime);
        if (logs.length > 0) {
          Logger.info(`Found ${logs.length} build logs after ${(i + 1) * 5} seconds`);
          foundLogs = true;
          break;
        }
        Logger.info(`No logs found after ${(i + 1) * 5} seconds, continuing to wait...`);
      }
      
      if (!foundLogs) {
        Logger.info('No build logs found after 30 seconds - build may not have started yet');
      }
      
      Logger.info('Build monitoring complete, proceeding to analysis...');
      
      // Get ALL recent build logs for analysis (test might create multiple logs)
      Logger.info(`DEBUG: testStartTime = ${testStartTime} (${new Date(testStartTime)})`);
      Logger.info(`DEBUG: projectPath = ${projectPath}`);
      
      // First check if we can find DerivedData
      const derivedData = await BuildLogParser.findProjectDerivedData(projectPath);
      Logger.info(`DEBUG: derivedData = ${derivedData}`);
      
      const recentLogs = await BuildLogParser.getRecentBuildLogs(projectPath, testStartTime);
      Logger.info(`DEBUG: recentLogs.length = ${recentLogs.length}`);
      if (recentLogs.length > 0) {
        Logger.info(`Analyzing ${recentLogs.length} recent build logs created during test...`);
        
        let totalErrors: string[] = [];
        let totalWarnings: string[] = [];
        let hasStoppedBuild = false;
        
        // Analyze each recent log to catch build errors in any of them
        for (const log of recentLogs) {
          try {
            Logger.info(`Analyzing build log: ${log.path}`);
            const results = await BuildLogParser.parseBuildLog(log.path);
            Logger.info(`Log analysis: ${results.errors.length} errors, ${results.warnings.length} warnings, status: ${results.buildStatus || 'unknown'}`);
            
            // Check for stopped builds
            if (results.buildStatus === 'stopped') {
              hasStoppedBuild = true;
            }
            
            // Accumulate errors and warnings from all logs
            totalErrors.push(...results.errors);
            totalWarnings.push(...results.warnings);
            
          } catch (error) {
            Logger.warn(`Failed to parse build log ${log.path}: ${error instanceof Error ? error.message : error}`);
          }
        }
        
        Logger.info(`Total build analysis: ${totalErrors.length} errors, ${totalWarnings.length} warnings, stopped builds: ${hasStoppedBuild}`);
        
        Logger.info(`DEBUG: totalErrors = ${JSON.stringify(totalErrors)}`);
        Logger.info(`DEBUG: totalErrors.length = ${totalErrors.length}`);
        Logger.info(`DEBUG: totalErrors.length > 0 = ${totalErrors.length > 0}`);
        Logger.info(`DEBUG: hasStoppedBuild = ${hasStoppedBuild}`);
        
        // Handle stopped builds first
        if (hasStoppedBuild && totalErrors.length === 0) {
          let message = `⏹️ TEST BUILD INTERRUPTED${hasArgs ? ` (test with arguments ${JSON.stringify(commandLineArguments)})` : ''}\n\nThe build was stopped or interrupted before completion.\n\n💡 This may happen when:\n  • The build was cancelled manually\n  • Xcode was closed during the build\n  • System resources were exhausted\n\nTry running the test again to complete it.`;
          return { content: [{ type: 'text', text: message }] };
        }
        
        if (totalErrors.length > 0) {
          let message = `❌ TEST BUILD FAILED (${totalErrors.length} errors)\n\nERRORS:\n`;
          totalErrors.forEach(error => {
            message += `  • ${error}\n`;
            Logger.error('Test build error:', error);
          });
          
          if (totalWarnings.length > 0) {
            message += `\n⚠️ WARNINGS (${totalWarnings.length}):\n`;
            totalWarnings.slice(0, 10).forEach(warning => {
              message += `  • ${warning}\n`;
              Logger.warn('Test build warning:', warning);
            });
            if (totalWarnings.length > 10) {
              message += `  ... and ${totalWarnings.length - 10} more warnings\n`;
            }
          }
          
          Logger.error('ABOUT TO THROW McpError for test build failure');
          throw new McpError(ErrorCode.InternalError, message);
        } else if (totalWarnings.length > 0) {
          Logger.warn(`Test build completed with ${totalWarnings.length} warnings`);
          totalWarnings.slice(0, 10).forEach(warning => {
            Logger.warn('Test build warning:', warning);
          });
          if (totalWarnings.length > 10) {
            Logger.warn(`... and ${totalWarnings.length - 10} more warnings`);
          }
        }
      } else {
        Logger.info(`DEBUG: No recent build logs found since ${new Date(testStartTime)}`);
      }

      // Since build passed, now wait for test execution to complete
      Logger.info('Build succeeded, waiting for test execution to complete...');
      
      // Monitor test completion with proper AppleScript checking and 6-hour safety timeout
      const maxTestTime = 21600000; // 6 hours safety timeout
      let testCompleted = false;
      let monitoringSeconds = 0;
      
      Logger.info('Monitoring test completion with 6-hour safety timeout...');
      
      while (!testCompleted && (Date.now() - testStartTime) < maxTestTime) {
        try {
          // Check test completion via AppleScript every 30 seconds
          const checkScript = `
            (function() {
              const app = Application('Xcode');
              const workspace = app.activeWorkspaceDocument();
              if (!workspace) return 'No workspace';
              
              const actions = workspace.schemeActionResults();
              for (let i = 0; i < actions.length; i++) {
                const action = actions[i];
                if (action.id() === "${actionId}") {
                  const status = action.status();
                  const completed = action.completed();
                  return status + ':' + completed;
                }
              }
              return 'Action not found';
            })()
          `;
          
          const result = await JXAExecutor.execute(checkScript, 15000);
          const [status, completed] = result.split(':');
          
          // Log progress every 2 minutes
          if (monitoringSeconds % 120 === 0) {
            Logger.info(`Test monitoring: ${Math.floor(monitoringSeconds/60)}min - Action ${actionId}: status=${status}, completed=${completed}`);
          }
          
          // Check if test is complete
          if (completed === 'true' && (status === 'succeeded' || status === 'failed' || status === 'cancelled' || status === 'error occurred')) {
            testCompleted = true;
            Logger.info(`Test completed after ${Math.floor(monitoringSeconds/60)} minutes: status=${status}`);
            break;
          }
          
        } catch (error) {
          Logger.warn(`Test monitoring error at ${Math.floor(monitoringSeconds/60)}min: ${error instanceof Error ? error.message : error}`);
        }
        
        // Wait 30 seconds before next check
        await new Promise(resolve => setTimeout(resolve, 30000));
        monitoringSeconds += 30;
      }
      
      if (!testCompleted) {
        Logger.warn('Test monitoring reached 6-hour timeout - proceeding anyway');
      }
      
      Logger.info('Test monitoring result: Test completion detected or timeout reached');
      
      // Only AFTER test completion is confirmed, look for the xcresult file
      Logger.info('Test execution completed, now looking for XCResult file...');
      let newXCResult = await this._findNewXCResultFile(projectPath, initialXCResults, testStartTime);
      
      // If no xcresult found yet, wait for it to appear (should be quick now that tests are done)
      if (!newXCResult) {
        Logger.info('No xcresult file found yet, waiting for it to appear...');
        let attempts = 0;
        const maxWaitAttempts = 15; // 15 seconds to find the file after test completion
        
        while (attempts < maxWaitAttempts && !newXCResult) {
          await new Promise(resolve => setTimeout(resolve, 1000));
          newXCResult = await this._findNewXCResultFile(projectPath, initialXCResults, testStartTime);
          attempts++;
        }
        
        // If still no XCResult found, the test likely didn't run at all
        if (!newXCResult) {
          Logger.warn('No XCResult file found - test may not have run or current scheme has no tests');
          return { 
            content: [{ 
              type: 'text', 
              text: `⚠️ TEST EXECUTION UNCLEAR\n\nNo XCResult file was created, which suggests:\n• The current scheme may not have test targets configured\n• Tests may have been skipped\n• There may be configuration issues\n\n💡 Try:\n• Use a scheme with test targets (look for schemes ending in '-Tests')\n• Check that the project has test targets configured\n• Run tests manually in Xcode first to verify setup\n\nAvailable schemes: Use 'xcode_get_schemes' to see all schemes` 
            }] 
          };
        }
      }
      
      let testResult: { status: string, error: string | undefined } = { status: 'completed', error: undefined };
      
      if (newXCResult) {
        Logger.info(`Found xcresult file: ${newXCResult}, waiting for it to be fully written...`);
        
        // Calculate how long the test took
        const testEndTime = Date.now();
        const testDurationMs = testEndTime - testStartTime;
        const testDurationMinutes = Math.round(testDurationMs / 60000);
        
        // Wait 8% of test duration before even attempting to read XCResult
        // This gives Xcode plenty of time to finish writing everything
        const proportionalWaitMs = Math.round(testDurationMs * 0.08);
        const proportionalWaitSeconds = Math.round(proportionalWaitMs / 1000);
        
        Logger.info(`Test ran for ${testDurationMinutes} minutes`);
        Logger.info(`Applying 8% wait time: ${proportionalWaitSeconds} seconds before checking XCResult`);
        Logger.info(`This prevents premature reads that could contribute to file corruption`);
        
        await new Promise(resolve => setTimeout(resolve, proportionalWaitMs));
        
        // Now use the robust waiting method with the test duration for context
        const isReady = await XCResultParser.waitForXCResultReadiness(newXCResult, testDurationMs); // Pass test duration for proportional timeouts
        
        if (isReady) {
          // File is ready, verify analysis works
          try {
            Logger.info('XCResult file is ready, performing final verification...');
            const parser = new XCResultParser(newXCResult);
            const analysis = await parser.analyzeXCResult();
          
            if (analysis && analysis.totalTests >= 0) {
              Logger.info(`XCResult parsing successful! Found ${analysis.totalTests} tests`);
              testResult = { status: 'completed', error: undefined };
            } else {
              Logger.error('XCResult parsed but incomplete test data found');
              testResult = { 
                status: 'failed', 
                error: `XCResult file exists but contains incomplete test data. This may indicate an Xcode bug.` 
              };
            }
          } catch (parseError) {
            Logger.error(`XCResult file appears to be corrupt: ${parseError instanceof Error ? parseError.message : parseError}`);
            testResult = { 
              status: 'failed', 
              error: `XCResult file is corrupt or unreadable. This is likely an Xcode bug. Parse error: ${parseError instanceof Error ? parseError.message : parseError}` 
            };
          }
        } else {
          Logger.error('XCResult file failed to become ready within 3 minutes');
          testResult = { 
            status: 'failed', 
            error: `XCResult file failed to become readable within 3 minutes despite multiple verification attempts. This indicates an Xcode bug where the file remains corrupt or incomplete.` 
          };
        }
      } else {
        Logger.warn('No xcresult file found after test completion');
        testResult = { status: 'completed', error: 'No XCResult file found' };
      }
      
      if (newXCResult) {
        Logger.info(`Found xcresult: ${newXCResult}`);
        
        // Check if the xcresult file is corrupt
        if (testResult.status === 'failed' && testResult.error) {
          // XCResult file is corrupt
          let message = `❌ XCODE BUG DETECTED${hasArgs ? ` (test with arguments ${JSON.stringify(commandLineArguments)})` : ''}\n\n`;
          message += `XCResult Path: ${newXCResult}\n\n`;
          message += `⚠️ ${testResult.error}\n\n`;
          message += `This is a known Xcode issue where the .xcresult file becomes corrupt even though Xcode reports test completion.\n\n`;
          message += `💡 Troubleshooting steps:\n`;
          message += `  1. Restart Xcode and retry\n`;
          message += `  2. Delete DerivedData and retry\n\n`;
          message += `The corrupt XCResult file is at:\n${newXCResult}`;
          
          return { content: [{ type: 'text', text: message }] };
        }
        
        // We already confirmed the xcresult is readable in our completion detection loop
        // No need to wait again - proceed directly to analysis
        if (testResult.status === 'completed') {
          try {
            // Use shared utility to format test results with individual test details
            const parser = new XCResultParser(newXCResult);
            const testSummary = await parser.formatTestResultsSummary(true, 5);
            
            let message = `🧪 TESTS COMPLETED${hasArgs ? ` with arguments ${JSON.stringify(commandLineArguments)}` : ''}\n\n`;
            message += `XCResult Path: ${newXCResult}\n`;
            message += testSummary + `\n\n`;
            
            const analysis = await parser.analyzeXCResult();
            if (analysis.failedTests > 0) {
              message += `💡 Inspect test results:\n`;
              message += `  • Browse results: xcresult_browse <path>\n`;
              message += `  • Get console output: xcresult_browser_get_console <path> <test-id>\n`;
              message += `  • Get screenshots: xcresult_get_screenshot <path> <test-id> <timestamp>\n`;
              message += `  • Get UI hierarchy: xcresult_get_ui_hierarchy <path> <test-id> <timestamp>\n`;
              message += `  • Get element details: xcresult_get_ui_element <hierarchy-json> <index>\n`;
              message += `  • List attachments: xcresult_list_attachments <path> <test-id>\n`;
              message += `  • Export attachments: xcresult_export_attachment <path> <test-id> <index>\n`;
              message += `  • Quick summary: xcresult_summary <path>\n`;
              message += `\n💡 Tip: Use console output to find failure timestamps for screenshots and UI hierarchies`;
            } else {
              message += `✅ All tests passed!\n\n`;
              message += `💡 Explore test results:\n`;
              message += `  • Browse results: xcresult_browse <path>\n`;
              message += `  • Get console output: xcresult_browser_get_console <path> <test-id>\n`;
              message += `  • Get screenshots: xcresult_get_screenshot <path> <test-id> <timestamp>\n`;
              message += `  • Get UI hierarchy: xcresult_get_ui_hierarchy <path> <test-id> <timestamp>\n`;
              message += `  • Get element details: xcresult_get_ui_element <hierarchy-json> <index>\n`;
              message += `  • List attachments: xcresult_list_attachments <path> <test-id>\n`;
              message += `  • Export attachments: xcresult_export_attachment <path> <test-id> <index>\n`;
              message += `  • Quick summary: xcresult_summary <path>`;
            }
            
            return { content: [{ type: 'text', text: message }] };
          } catch (parseError) {
            Logger.warn(`Failed to parse xcresult: ${parseError}`);
            // Fall back to basic result
            let message = `🧪 TESTS COMPLETED${hasArgs ? ` with arguments ${JSON.stringify(commandLineArguments)}` : ''}\n\n`;
            message += `XCResult Path: ${newXCResult}\n`;
            message += `Status: ${testResult.status}\n\n`;
            message += `Note: XCResult parsing failed, but test file is available for manual inspection.\n\n`;
            message += `💡 Inspect test results:\n`;
            message += `  • Browse results: xcresult_browse <path>\n`;
            message += `  • Get console output: xcresult_browser_get_console <path> <test-id>\n`;
            message += `  • Get screenshots: xcresult_get_screenshot <path> <test-id> <timestamp>\n`;
            message += `  • Get UI hierarchy: xcresult_get_ui_hierarchy <path> <test-id> <timestamp>\n`;
            message += `  • Get element details: xcresult_get_ui_element <hierarchy-json> <index>\n`;
            message += `  • List attachments: xcresult_list_attachments <path> <test-id>\n`;
            message += `  • Export attachments: xcresult_export_attachment <path> <test-id> <index>\n`;
            message += `  • Quick summary: xcresult_summary <path>`;
            
            return { content: [{ type: 'text', text: message }] };
          }
        } else {
          // Test completion detection timed out
          let message = `🧪 TESTS ${testResult.status.toUpperCase()}${hasArgs ? ` with arguments ${JSON.stringify(commandLineArguments)}` : ''}\n\n`;
          message += `XCResult Path: ${newXCResult}\n`;
          message += `Status: ${testResult.status}\n\n`;
          message += `⚠️ Test completion detection timed out, but XCResult file is available.\n\n`;
          message += `💡 Inspect test results:\n`;
          message += `  • Browse results: xcresult_browse <path>\n`;
          message += `  • Get console output: xcresult_browser_get_console <path> <test-id>\n`;
          message += `  • Get screenshots: xcresult_get_screenshot <path> <test-id> <timestamp>\n`;
          message += `  • Get UI hierarchy: xcresult_get_ui_hierarchy <path> <test-id> <timestamp>\n`;
          message += `  • Get element details: xcresult_get_ui_element <hierarchy-json> <index>\n`;
          message += `  • List attachments: xcresult_list_attachments <path> <test-id>\n`;
          message += `  • Export attachments: xcresult_export_attachment <path> <test-id> <index>\n`;
          message += `  • Quick summary: xcresult_summary <path>`;
          
          return { content: [{ type: 'text', text: message }] };
        }
      } else {
        // No xcresult found - fall back to basic result
        if (testResult.status === 'failed') {
          return { content: [{ type: 'text', text: `❌ TEST FAILED\n\n${testResult.error || 'Test execution failed'}\n\nNote: No XCResult file found for detailed analysis.` }] };
        }
        
        const message = `🧪 TESTS COMPLETED${hasArgs ? ` with arguments ${JSON.stringify(commandLineArguments)}` : ''}\n\nStatus: ${testResult.status}\n\nNote: No XCResult file found for detailed analysis.`;
        return { content: [{ type: 'text', text: message }] };
      }
    } catch (error) {
      // Re-throw McpErrors to properly signal build failures
      if (error instanceof McpError) {
        throw error;
      }
      
      const enhancedError = ErrorHelper.parseCommonErrors(error as Error);
      if (enhancedError) {
        return { content: [{ type: 'text', text: enhancedError }] };
      }
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { content: [{ type: 'text', text: `Failed to run tests: ${errorMessage}` }] };
    }
  }

  public static async run(
    projectPath: string, 
    schemeName: string,
    commandLineArguments: string[] = [], 
    openProject: OpenProjectCallback
  ): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    await openProject(projectPath);

    // Set the scheme
    const normalizedSchemeName = ParameterNormalizer.normalizeSchemeName(schemeName);
    
    const setSchemeScript = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        const schemes = workspace.schemes();
        const schemeNames = schemes.map(scheme => scheme.name());
        
        // Try exact match first
        let targetScheme = schemes.find(scheme => scheme.name() === ${JSON.stringify(normalizedSchemeName)});
        
        // If not found, try original name
        if (!targetScheme) {
          targetScheme = schemes.find(scheme => scheme.name() === ${JSON.stringify(schemeName)});
        }
        
        if (!targetScheme) {
          throw new Error('Scheme not found. Available: ' + JSON.stringify(schemeNames));
        }
        
        workspace.activeScheme = targetScheme;
        return 'Scheme set to ' + targetScheme.name();
      })()
    `;
    
    try {
      await JXAExecutor.execute(setSchemeScript);
    } catch (error) {
      const enhancedError = ErrorHelper.parseCommonErrors(error as Error);
      if (enhancedError) {
        return { content: [{ type: 'text', text: enhancedError }] };
      }
      
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes('not found')) {
        try {
          // Get available schemes
          const availableSchemes = await this._getAvailableSchemes();
            
          // Try to find a close match with fuzzy matching
          const bestMatch = ParameterNormalizer.findBestMatch(schemeName, availableSchemes);
          let message = `❌ Scheme '${schemeName}' not found\n\nAvailable schemes:\n`;
          
          availableSchemes.forEach(scheme => {
            if (scheme === bestMatch) {
              message += `  • ${scheme} ← Did you mean this?\n`;
            } else {
              message += `  • ${scheme}\n`;
            }
          });
          
          return { content: [{ type: 'text', text: message }] };
        } catch {
          return { content: [{ type: 'text', text: ErrorHelper.createErrorWithGuidance(`Scheme '${schemeName}' not found`, ErrorHelper.getSchemeNotFoundGuidance(schemeName)) }] };
        }
      }
      
      return { content: [{ type: 'text', text: `Failed to set scheme '${schemeName}': ${errorMessage}` }] };
    }

    const initialLog = await BuildLogParser.getLatestBuildLog(projectPath);
    const initialTime = Date.now();

    const hasArgs = commandLineArguments && commandLineArguments.length > 0;
    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        ${hasArgs 
          ? `const result = workspace.run({withCommandLineArguments: ${JSON.stringify(commandLineArguments)}});`
          : `const result = workspace.run();`
        }
        return \`Run started. Result ID: \${result.id()}\`;
      })()
    `;
    
    const runResult = await JXAExecutor.execute(script);
    
    // Check for and handle "replace existing build" alert
    await this._handleReplaceExistingBuildAlert();

    let newLog = null;
    let attempts = 0;
    const maxAttempts = 60;

    while (attempts < maxAttempts) {
      newLog = await BuildLogParser.getLatestBuildLog(projectPath);
      
      if (newLog && (!initialLog || newLog.path !== initialLog.path || 
                     newLog.mtime.getTime() > initialTime)) {
        break;
      }
      
      await new Promise(resolve => setTimeout(resolve, 500));
      attempts++;
    }

    if (!newLog) {
      return { content: [{ type: 'text', text: `${runResult}\n\nNote: Run triggered but no build log found (app may have launched without building)` }] };
    }

    let lastModified = 0;
    let stableCount = 0;
    attempts = 0;
    const buildMaxAttempts = 7200; // 1 hour max for run operation build (600 attempts × 500ms = 5min -> 7200 × 500ms = 1hr)

    while (attempts < buildMaxAttempts) {
      const currentLog = await BuildLogParser.getLatestBuildLog(projectPath);
      if (currentLog) {
        const currentModified = currentLog.mtime.getTime();
        if (currentModified === lastModified) {
          stableCount++;
          if (stableCount >= 6) {
            break;
          }
        } else {
          lastModified = currentModified;
          stableCount = 0;
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 500));
      attempts++;
    }

    const results = await BuildLogParser.parseBuildLog(newLog.path);
    
    let message = `${runResult}\n\n`;
    Logger.info(`Run build completed - ${results.errors.length} errors, ${results.warnings.length} warnings, status: ${results.buildStatus || 'unknown'}`);
    
    // Handle stopped/interrupted builds
    if (results.buildStatus === 'stopped') {
      message += `⏹️ BUILD INTERRUPTED\n\nThe build was stopped or interrupted before completion.\n\n💡 This may happen when:\n  • The build was cancelled manually\n  • Xcode was closed during the build\n  • System resources were exhausted\n\nTry running the build again to complete it.`;
      return { content: [{ type: 'text', text: message }] };
    }
    
    if (results.errors.length > 0) {
      message += `❌ BUILD FAILED (${results.errors.length} errors)\n\nERRORS:\n`;
      results.errors.forEach(error => {
        message += `  • ${error}\n`;
        Logger.error('Run build error:', error);
      });
      throw new McpError(
        ErrorCode.InternalError,
        message
      );
    } else if (results.warnings.length > 0) {
      message += `⚠️ BUILD COMPLETED WITH WARNINGS (${results.warnings.length} warnings)\n\nWARNINGS:\n`;
      results.warnings.forEach(warning => {
        message += `  • ${warning}\n`;
        Logger.warn('Run build warning:', warning);
      });
    } else {
      message += '✅ BUILD SUCCESSFUL - App should be launching';
    }

    return { content: [{ type: 'text', text: message }] };
  }

  public static async debug(
    projectPath: string, 
    scheme?: string, 
    skipBuilding = false, 
    openProject?: OpenProjectCallback
  ): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    if (openProject) {
      await openProject(projectPath);
    }

    const hasParams = scheme || skipBuilding;
    let paramsObj: { scheme?: string; skipBuilding?: boolean } = {};
    if (scheme) paramsObj.scheme = scheme;
    if (skipBuilding) paramsObj.skipBuilding = skipBuilding;
    
    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        ${hasParams 
          ? `const result = workspace.debug(${JSON.stringify(paramsObj)});`
          : `const result = workspace.debug();`
        }
        return \`Debug started. Result ID: \${result.id()}\`;
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    
    // Check for and handle "replace existing build" alert
    await this._handleReplaceExistingBuildAlert();
    
    return { content: [{ type: 'text', text: result }] };
  }

  public static async stop(): Promise<McpResult> {
    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) throw new Error('No active workspace');
        
        workspace.stop();
        return 'Stop command sent';
      })()
    `;
    
    const result = await JXAExecutor.execute(script);
    return { content: [{ type: 'text', text: result }] };
  }

  private static async _getAvailableSchemes(): Promise<string[]> {
    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) return JSON.stringify([]);
        
        const schemes = workspace.schemes();
        const schemeNames = schemes.map(scheme => scheme.name());
        return JSON.stringify(schemeNames);
      })()
    `;
    
    try {
      const result = await JXAExecutor.execute(script);
      return JSON.parse(result);
    } catch {
      return [];
    }
  }

  private static async _getAvailableDestinations(): Promise<string[]> {
    const script = `
      (function() {
        const app = Application('Xcode');
        const workspace = app.activeWorkspaceDocument();
        if (!workspace) return [];
        
        const destinations = workspace.runDestinations();
        return destinations.map(dest => dest.name());
      })()
    `;
    
    try {
      const result = await JXAExecutor.execute(script);
      return JSON.parse(result);
    } catch {
      return [];
    }
  }

  private static async _findXCResultFiles(projectPath: string): Promise<{ path: string; mtime: number; size?: number }[]> {
    const xcresultFiles: { path: string; mtime: number; size?: number }[] = [];
    
    try {
      // Use existing BuildLogParser logic to find the correct DerivedData directory
      const derivedData = await BuildLogParser.findProjectDerivedData(projectPath);
      
      if (derivedData) {
        // Look for xcresult files in the Test logs directory
        const testLogsDir = join(derivedData, 'Logs', 'Test');
        try {
          const files = await readdir(testLogsDir);
          const xcresultDirs = files.filter(file => file.endsWith('.xcresult'));
          
          for (const xcresultDir of xcresultDirs) {
            const fullPath = join(testLogsDir, xcresultDir);
            try {
              const stats = await stat(fullPath);
              xcresultFiles.push({
                path: fullPath,
                mtime: stats.mtime.getTime(),
                size: stats.size
              });
            } catch {
              // Ignore files we can't stat
            }
          }
        } catch (error) {
          Logger.debug(`Could not read test logs directory: ${error}`);
        }
      }
    } catch (error) {
      Logger.warn(`Error finding xcresult files: ${error}`);
    }
    
    return xcresultFiles.sort((a, b) => b.mtime - a.mtime);
  }


  private static async _findNewXCResultFile(
    projectPath: string, 
    initialFiles: { path: string; mtime: number }[], 
    testStartTime: number
  ): Promise<string | null> {
    const maxAttempts = 30; // 30 seconds
    let attempts = 0;
    
    while (attempts < maxAttempts) {
      const currentFiles = await this._findXCResultFiles(projectPath);
      
      // Look for new files created after test start
      for (const file of currentFiles) {
        const wasInitialFile = initialFiles.some(initial => 
          initial.path === file.path && initial.mtime === file.mtime
        );
        
        if (!wasInitialFile && file.mtime >= testStartTime - 5000) { // 5s buffer
          Logger.info(`Found new xcresult file: ${file.path}, mtime: ${new Date(file.mtime)}, test start: ${new Date(testStartTime)}`);
          return file.path;
        } else if (!wasInitialFile) {
          Logger.warn(`Found xcresult file but too old: ${file.path}, mtime: ${new Date(file.mtime)}, test start: ${new Date(testStartTime)}, diff: ${file.mtime - testStartTime}ms`);
        } else {
          Logger.debug(`Skipping initial file: ${file.path}, mtime: ${new Date(file.mtime)}`);
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      attempts++;
    }
    
    // If no new file found, look for files created AFTER test start time
    const allFiles = await this._findXCResultFiles(projectPath);
    
    // Find files created after the test started (not just within the timeframe)
    const filesAfterTestStart = allFiles.filter(file => file.mtime > testStartTime);
    
    if (filesAfterTestStart.length > 0) {
      // Return the newest file that was created after the test started
      const mostRecentAfterTest = filesAfterTestStart[0]; // Already sorted newest first
      if (mostRecentAfterTest) {
        Logger.warn(`Using most recent xcresult file created after test start: ${mostRecentAfterTest.path}`);
        return mostRecentAfterTest.path;
      }
    } else if (allFiles.length > 0) {
      const mostRecent = allFiles[0];
      if (mostRecent) {
        Logger.debug(`Most recent file too old: ${mostRecent.path}, mtime: ${new Date(mostRecent.mtime)}, test start: ${new Date(testStartTime)}`);
      }
    }
    
    return null;
  }

  /**
   * Find XCResult files for a given project
   */
  public static async findXCResults(projectPath: string): Promise<McpResult> {
    const validationError = PathValidator.validateProjectPath(projectPath);
    if (validationError) return validationError;

    try {
      const xcresultFiles = await this._findXCResultFiles(projectPath);
      
      if (xcresultFiles.length === 0) {
        return { 
          content: [{ 
            type: 'text', 
            text: `No XCResult files found for project: ${projectPath}\n\nXCResult files are created when you run tests. Try running tests first with 'xcode_test'.`
          }] 
        };
      }

      let message = `🔍 Found ${xcresultFiles.length} XCResult file(s) for project: ${projectPath}\n\n`;
      message += `📁 XCResult Files (sorted by newest first):\n`;
      message += '='.repeat(80) + '\n';

      xcresultFiles.forEach((file, index) => {
        const date = new Date(file.mtime);
        const timeAgo = this._getTimeAgo(file.mtime);
        
        message += `${index + 1}. ${file.path}\n`;
        message += `   📅 Created: ${date.toLocaleString()} (${timeAgo})\n`;
        message += `   📊 Size: ${this._formatFileSize(file.size || 0)}\n\n`;
      });

      message += `💡 Usage:\n`;
      message += `  • View results: xcresult_browse "<path>"\n`;
      message += `  • Get console: xcresult_browser_get_console "<path>" <test-id>\n`;
      
      return { content: [{ type: 'text', text: message }] };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { 
        content: [{ 
          type: 'text', 
          text: `Failed to find XCResult files: ${errorMessage}` 
        }] 
      };
    }
  }

  private static _getTimeAgo(timestamp: number): string {
    const now = Date.now();
    const diff = now - timestamp;
    
    const minutes = Math.floor(diff / (1000 * 60));
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (minutes < 1) return 'just now';
    if (minutes < 60) return `${minutes} minute${minutes === 1 ? '' : 's'} ago`;
    if (hours < 24) return `${hours} hour${hours === 1 ? '' : 's'} ago`;
    return `${days} day${days === 1 ? '' : 's'} ago`;
  }

  private static _formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 bytes';
    
    const k = 1024;
    const sizes = ['bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
  }

  /**
   * Handle alerts that appear when starting builds/tests while another operation is in progress.
   * This includes "replace existing build" alerts and similar dialog overlays.
   */
  private static async _handleReplaceExistingBuildAlert(): Promise<void> {
    const alertScript = `
      (function() {
        try {
          // Use System Events approach first as it's more reliable for sheet dialogs
          const systemEvents = Application('System Events');
          const xcodeProcesses = systemEvents.processes.whose({name: 'Xcode'});
          
          if (xcodeProcesses.length > 0) {
            const xcodeProcess = xcodeProcesses[0];
            const windows = xcodeProcess.windows();
            
            // Check for sheets in regular windows (most common case)
            for (let i = 0; i < windows.length; i++) {
              try {
                const window = windows[i];
                const sheets = window.sheets();
                
                if (sheets && sheets.length > 0) {
                  const sheet = sheets[0];
                  const buttons = sheet.buttons();
                  
                  // Look for Replace, Continue, OK, Yes buttons (in order of preference)
                  const preferredButtons = ['Replace', 'Continue', 'OK', 'Yes', 'Stop and Replace'];
                  
                  for (const preferredButton of preferredButtons) {
                    for (let b = 0; b < buttons.length; b++) {
                      try {
                        const button = buttons[b];
                        const buttonTitle = button.title();
                        
                        if (buttonTitle === preferredButton) {
                          button.click();
                          return 'Sheet alert handled: clicked ' + buttonTitle;
                        }
                      } catch (e) {
                        // Continue to next button
                      }
                    }
                  }
                  
                  // If no preferred button found, try partial matches
                  for (let b = 0; b < buttons.length; b++) {
                    try {
                      const button = buttons[b];
                      const buttonTitle = button.title();
                      
                      if (buttonTitle && (
                        buttonTitle.toLowerCase().includes('replace') ||
                        buttonTitle.toLowerCase().includes('continue') ||
                        buttonTitle.toLowerCase().includes('stop') ||
                        buttonTitle.toLowerCase() === 'ok' ||
                        buttonTitle.toLowerCase() === 'yes'
                      )) {
                        button.click();
                        return 'Sheet alert handled: clicked ' + buttonTitle + ' (partial match)';
                      }
                    } catch (e) {
                      // Continue to next button
                    }
                  }
                  
                  // Log available buttons for debugging
                  const availableButtons = [];
                  for (let b = 0; b < buttons.length; b++) {
                    try {
                      availableButtons.push(buttons[b].title());
                    } catch (e) {
                      availableButtons.push('(unnamed)');
                    }
                  }
                  
                  return 'Sheet found but no suitable button. Available: ' + JSON.stringify(availableButtons);
                }
              } catch (e) {
                // Continue to next window
              }
            }
            
            // Check for modal dialogs
            const dialogs = xcodeProcess.windows.whose({subrole: 'AXDialog'});
            for (let d = 0; d < dialogs.length; d++) {
              try {
                const dialog = dialogs[d];
                const buttons = dialog.buttons();
                
                for (let b = 0; b < buttons.length; b++) {
                  try {
                    const button = buttons[b];
                    const buttonTitle = button.title();
                    
                    if (buttonTitle && (
                      buttonTitle.toLowerCase().includes('replace') ||
                      buttonTitle.toLowerCase().includes('continue') ||
                      buttonTitle.toLowerCase().includes('stop') ||
                      buttonTitle.toLowerCase() === 'ok' ||
                      buttonTitle.toLowerCase() === 'yes'
                    )) {
                      button.click();
                      return 'Dialog alert handled: clicked ' + buttonTitle;
                    }
                  } catch (e) {
                    // Continue to next button
                  }
                }
              } catch (e) {
                // Continue to next dialog
              }
            }
          }
          
          // Fallback to Xcode app approach for embedded alerts
          const app = Application('Xcode');
          const windows = app.windows();
          
          for (let i = 0; i < windows.length; i++) {
            try {
              const window = windows[i];
              const sheets = window.sheets();
              
              if (sheets && sheets.length > 0) {
                const sheet = sheets[0];
                const buttons = sheet.buttons();
                
                for (let j = 0; j < buttons.length; j++) {
                  try {
                    const button = buttons[j];
                    const buttonName = button.name();
                    
                    if (buttonName && (
                      buttonName.toLowerCase().includes('replace') ||
                      buttonName.toLowerCase().includes('continue') ||
                      buttonName.toLowerCase().includes('stop') ||
                      buttonName.toLowerCase() === 'ok' ||
                      buttonName.toLowerCase() === 'yes'
                    )) {
                      button.click();
                      return 'Xcode app sheet handled: clicked ' + buttonName;
                    }
                  } catch (e) {
                    // Continue to next button
                  }
                }
              }
            } catch (e) {
              // Continue to next window
            }
          }
          
          return 'No alert found';
          
        } catch (error) {
          return 'Alert check failed: ' + error.message;
        }
      })()
    `;
    
    try {
      Logger.info('Running alert detection script...');
      const result = await JXAExecutor.execute(alertScript);
      Logger.info(`Alert detection result: ${result}`);
      if (result && result !== 'No alert found') {
        Logger.info(`Alert handling: ${result}`);
      } else {
        Logger.info('No alerts detected');
      }
    } catch (error) {
      // Don't fail the main operation if alert handling fails
      Logger.info(`Alert handling failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
}
</file>

</files>
